import React, { useState, useEffect, useMemo } from 'react';
import { createTheme, ThemeProvider, CssBaseline, useMediaQuery } from '@mui/material';
import { 
  AppBar, Toolbar, Typography, Box, Container, Card, CardContent, 
  Button, IconButton, Grid, TextField, Select, MenuItem, FormControl,
  InputLabel, Checkbox, FormControlLabel, Drawer, Divider, List, ListItem,
  ListItemText, ListItemIcon, Dialog, DialogTitle, DialogContent, DialogActions,
  Snackbar, Alert, Paper, Tabs, Tab, TableContainer, Table, TableHead, TableBody,
  TableRow, TableCell, Chip, Menu, InputAdornment
} from '@mui/material';
import { 
  Add as AddIcon, 
  DarkMode as DarkModeIcon, 
  LightMode as LightModeIcon,
  ChevronLeft as ChevronLeftIcon,
  ChevronRight as ChevronRightIcon,
  FilterList as FilterListIcon,
  Download as DownloadIcon,
  Delete as DeleteIcon,
  Edit as EditIcon,
  Person as PersonIcon,
  Category as CategoryIcon,
  Payment as PaymentIcon,
  DateRange as DateRangeIcon,
  Dashboard as DashboardIcon,
  AttachMoney as AttachMoneyIcon,
  MenuOpen as MenuOpenIcon,
  KeyboardArrowDown as KeyboardArrowDownIcon
} from '@mui/icons-material';
import { LocalizationProvider, DatePicker } from '@mui/x-date-pickers';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { ptBR } from 'date-fns/locale';
import Chart from 'chart.js/auto';
import { Line, Bar, Pie, Doughnut } from 'react-chartjs-2';
import { format, startOfMonth, endOfMonth, eachDayOfInterval, parseISO, isWithinInterval, addMonths, subMonths } from 'date-fns';

// Função para gerar ID único
const generateId = () => Math.random().toString(36).substr(2, 9);

// Valores iniciais
const initialExpenseState = {
  id: '',
  date: format(new Date(), 'yyyy-MM-dd'),
  description: '',
  category: '',
  amount: '',
  type: '',
  paymentMethod: '',
  isInstallment: false,
  installmentCount: 1,
  person: '',
  status: 'pendente'
};

// Categorias e tipos
const categories = ['Moradia', 'Alimentação', 'Transporte', 'Lazer', 'Saúde', 'Educação', 'Serviços', 'Vestuário', 'Outros'];
const types = ['Essencial', 'Variável', 'Supérfluo', 'Dívida', 'Educação', 'Lazer'];
const paymentMethods = ['Pix', 'Crédito', 'Débito', 'Dinheiro', 'Carnê', 'Boleto', 'Transferência'];
const people = ['Wagner', 'Bárbara', 'Joaquim', 'Família'];

// Funções auxiliares
const formatCurrency = (value) => {
  return new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
  }).format(Number(value) || 0);
};

const downloadCSV = (data, filename) => {
  // Cria cabeçalhos CSV
  const headers = Object.keys(data[0]).join(',');
  // Converte cada objeto em uma linha CSV
  const csvRows = data.map(row => 
    Object.values(row).map(value => 
      typeof value === 'string' ? `"${value}"` : value
    ).join(',')
  );
  
  // Combina cabeçalhos e linhas
  const csvContent = [headers, ...csvRows].join('\n');
  
  // Cria um blob e link para download
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

function App() {
  // Estado para tema claro/escuro
  const prefersDarkMode = useMediaQuery('(prefers-color-scheme: dark)');
  const [darkMode, setDarkMode] = useState(() => {
    const savedMode = localStorage.getItem('darkMode');
    return savedMode !== null ? JSON.parse(savedMode) : prefersDarkMode;
  });

  // Estados para armazenar as despesas e filtros
  const [expenses, setExpenses] = useState(() => {
    const savedExpenses = localStorage.getItem('expenses');
    return savedExpenses ? JSON.parse(savedExpenses) : [];
  });
  
  const [newExpense, setNewExpense] = useState(initialExpenseState);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [selectedExpense, setSelectedExpense] = useState(null);
  const [editMode, setEditMode] = useState(false);
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'success' });
  
  // Estados para navegação de data
  const [currentMonth, setCurrentMonth] = useState(new Date());
  
  // Estado para filtros
  const [filters, setFilters] = useState({
    startDate: format(startOfMonth(new Date()), 'yyyy-MM-dd'),
    endDate: format(endOfMonth(new Date()), 'yyyy-MM-dd'),
    category: '',
    type: '',
    paymentMethod: '',
    person: '',
    minAmount: '',
    maxAmount: '',
  });
  
  // Estado para abas
  const [tabValue, setTabValue] = useState(0);
  
  // Menu de exportação
  const [exportAnchorEl, setExportAnchorEl] = useState(null);
  
  // Tema baseado no modo claro/escuro
  const theme = useMemo(() => createTheme({
    palette: {
      mode: darkMode ? 'dark' : 'light',
      primary: {
        main: '#4285F4', // Google Blue
        dark: '#3367d6',
        light: '#5e97f6'
      },
      secondary: {
        main: '#0F9D58', // Google Green
      },
      error: {
        main: '#DB4437', // Google Red
      },
      warning: {
        main: '#F4B400', // Google Yellow
      },
      background: {
        default: darkMode ? '#121212' : '#F5F5F5',
        paper: darkMode ? '#1e1e1e' : '#FFFFFF',
      },
    },
    typography: {
      fontFamily: '"Google Sans", "Roboto", "Arial", sans-serif'
    },
    components: {
      MuiCard: {
        styleOverrides: {
          root: {
            borderRadius: 12,
            boxShadow: darkMode 
              ? '0 4px 20px 0 rgba(0,0,0,0.5)' 
              : '0 1px 3px 0 rgba(60,64,67,0.3), 0 4px 8px 3px rgba(60,64,67,0.15)',
          }
        }
      },
      MuiButton: {
        styleOverrides: {
          root: {
            borderRadius: 8,
            textTransform: 'none',
            fontWeight: 500
          }
        }
      },
      MuiChip: {
        styleOverrides: {
          root: {
            borderRadius: 8
          }
        }
      }
    }
  }), [darkMode]);
  
  // Salvar despesas no localStorage quando o estado mudar
  useEffect(() => {
    localStorage.setItem('expenses', JSON.stringify(expenses));
  }, [expenses]);
  
  // Salvar preferência de tema
  useEffect(() => {
    localStorage.setItem('darkMode', JSON.stringify(darkMode));
  }, [darkMode]);
  
  // Filtrar despesas com base nos critérios atuais
  const filteredExpenses = useMemo(() => {
    return expenses.filter(expense => {
      const expenseDate = parseISO(expense.date);
      const startDate = filters.startDate ? parseISO(filters.startDate) : null;
      const endDate = filters.endDate ? parseISO(filters.endDate) : null;
      
      // Verificar data
      const dateMatch = !startDate || !endDate || isWithinInterval(expenseDate, { start: startDate, end: endDate });
      
      // Verificar categoria
      const categoryMatch = !filters.category || expense.category === filters.category;
      
      // Verificar tipo
      const typeMatch = !filters.type || expense.type === filters.type;
      
      // Verificar método de pagamento
      const paymentMatch = !filters.paymentMethod || expense.paymentMethod === filters.paymentMethod;
      
      // Verificar pessoa
      const personMatch = !filters.person || expense.person === filters.person;
      
      // Verificar valor mínimo
      const minAmountMatch = !filters.minAmount || Number(expense.amount) >= Number(filters.minAmount);
      
      // Verificar valor máximo
      const maxAmountMatch = !filters.maxAmount || Number(expense.amount) <= Number(filters.maxAmount);
      
      return dateMatch && categoryMatch && typeMatch && paymentMatch && personMatch && minAmountMatch && maxAmountMatch;
    });
  }, [expenses, filters]);
  
  // Calcular KPIs
  const kpis = useMemo(() => {
    // Total do mês
    const total = filteredExpenses.reduce((sum, expense) => sum + Number(expense.amount), 0);
    
    // Média por dia (se houver pelo menos uma despesa)
    const startDate = parseISO(filters.startDate);
    const endDate = parseISO(filters.endDate);
    const daysInPeriod = filteredExpenses.length > 0 
      ? eachDayOfInterval({ start: startDate, end: endDate }).length 
      : 1;
    const average = total / daysInPeriod;
    
    // Categoria mais cara
    const categoryTotals = {};
    filteredExpenses.forEach(expense => {
      const category = expense.category || 'Sem categoria';
      categoryTotals[category] = (categoryTotals[category] || 0) + Number(expense.amount);
    });
    
    let topCategory = 'Nenhuma';
    let topCategoryAmount = 0;
    
    Object.entries(categoryTotals).forEach(([category, amount]) => {
      if (amount > topCategoryAmount) {
        topCategory = category;
        topCategoryAmount = amount;
      }
    });
    
    // Pessoa que mais gastou
    const personTotals = {};
    filteredExpenses.forEach(expense => {
      const person = expense.person || 'Não especificado';
      personTotals[person] = (personTotals[person] || 0) + Number(expense.amount);
    });
    
    let topSpender = 'Ninguém';
    let topSpenderAmount = 0;
    
    Object.entries(personTotals).forEach(([person, amount]) => {
      if (amount > topSpenderAmount) {
        topSpender = person;
        topSpenderAmount = amount;
      }
    });
    
    // Projeção para o final do mês (baseada na média diária)
    const daysInMonth = eachDayOfInterval({ 
      start: startOfMonth(currentMonth), 
      end: endOfMonth(currentMonth) 
    }).length;
    
    const projection = average * daysInMonth;
    
    return {
      total,
      average,
      topCategory,
      topSpender,
      projection
    };
  }, [filteredExpenses, filters.startDate, filters.endDate, currentMonth]);
  
  // Dados para os gráficos
  const chartData = useMemo(() => {
    // Dados para o gráfico de linha (despesas ao longo do tempo)
    const dateLabels = eachDayOfInterval({
      start: parseISO(filters.startDate),
      end: parseISO(filters.endDate)
    }).map(date => format(date, 'dd/MM'));
    
    const dailyExpenses = dateLabels.map(dateLabel => {
      const day = dateLabel.split('/')[0];
      const month = dateLabel.split('/')[1];
      
      // Somar todas as despesas deste dia
      return filteredExpenses
        .filter(exp => {
          const expDate = format(parseISO(exp.date), 'dd/MM');
          return expDate === dateLabel;
        })
        .reduce((sum, exp) => sum + Number(exp.amount), 0);
    });
    
    // Dados para o gráfico de pizza (por tipo)
    const typeLabels = types;
    const typeData = typeLabels.map(type => {
      return filteredExpenses
        .filter(exp => exp.type === type)
        .reduce((sum, exp) => sum + Number(exp.amount), 0);
    });
    
    // Dados para o gráfico de barras (por categoria)
    const categoryLabels = categories;
    const categoryData = categoryLabels.map(category => {
      return filteredExpenses
        .filter(exp => exp.category === category)
        .reduce((sum, exp) => sum + Number(exp.amount), 0);
    });
    
    // Dados para o gráfico de pessoas
    const peopleLabels = people;
    const peopleData = peopleLabels.map(person => {
      return filteredExpenses
        .filter(exp => exp.person === person)
        .reduce((sum, exp) => sum + Number(exp.amount), 0);
    });
    
    return {
      line: {
        labels: dateLabels,
        datasets: [{
          label: 'Despesas',
          data: dailyExpenses,
          fill: false,
          borderColor: '#4285F4',
          backgroundColor: 'rgba(66, 133, 244, 0.2)',
          tension: 0.4,
          pointRadius: 3,
          pointBackgroundColor: '#4285F4',
          pointBorderColor: '#FFFFFF',
          pointBorderWidth: 1,
          pointHoverRadius: 5,
          pointHoverBackgroundColor: '#3367d6',
          fill: true
        }]
      },
      pie: {
        labels: typeLabels,
        datasets: [{
          data: typeData,
          backgroundColor: [
            'rgba(66, 133, 244, 0.8)',   // Google Blue
            'rgba(219, 68, 55, 0.8)',    // Google Red
            'rgba(244, 180, 0, 0.8)',    // Google Yellow
            'rgba(15, 157, 88, 0.8)',    // Google Green
            'rgba(138, 78, 222, 0.8)',   // Purple
            'rgba(255, 109, 0, 0.8)'     // Orange
          ],
          borderColor: darkMode ? '#1e1e1e' : '#fff',
          borderWidth: 2
        }]
      },
      bar: {
        labels: categoryLabels,
        datasets: [{
          label: 'Gastos por Categoria',
          data: categoryData,
          backgroundColor: 'rgba(66, 133, 244, 0.7)',
          borderColor: '#4285F4',
          borderWidth: 1,
          borderRadius: 8,
          hoverBackgroundColor: '#3367d6'
        }]
      },
      people: {
        labels: peopleLabels,
        datasets: [{
          label: 'Gastos por Pessoa',
          data: peopleData,
          backgroundColor: [
            'rgba(66, 133, 244, 0.8)',   // Wagner
            'rgba(219, 68, 55, 0.8)',    // Bárbara
            'rgba(244, 180, 0, 0.8)',    // Joaquim
            'rgba(15, 157, 88, 0.8)'     // Família
          ],
          borderColor: darkMode ? '#1e1e1e' : '#fff',
          borderWidth: 2
        }]
      }
    };
  }, [filteredExpenses, filters.startDate, filters.endDate, darkMode]);
  
  // Opções para os gráficos
  const chartOptions = {
    line: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: false,
        },
        tooltip: {
          backgroundColor: darkMode ? 'rgba(30, 30, 30, 0.9)' : 'rgba(255, 255, 255, 0.9)',
          titleColor: darkMode ? '#fff' : '#333', 
          bodyColor: darkMode ? '#fff' : '#333',
          borderColor: darkMode ? '#444' : '#ddd',
          borderWidth: 1,
          displayColors: false,
          callbacks: {
            label: function(context) {
              return formatCurrency(context.raw);
            }
          }
        }
      },
      scales: {
        x: {
          grid: {
            display: false,
            drawBorder: false
          },
          ticks: {
            color: darkMode ? '#aaa' : '#666',
            maxRotation: 0,
            autoSkip: true,
            maxTicksLimit: 10
          }
        },
        y: {
          grid: {
            color: darkMode ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.05)',
            drawBorder: false
          },
          ticks: {
            color: darkMode ? '#aaa' : '#666',
            callback: function(value) {
              return formatCurrency(value);
            }
          }
        }
      }
    },
    pie: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'right',
          labels: {
            boxWidth: 15,
            padding: 15,
            color: darkMode ? '#ddd' : '#555'
          }
        },
        tooltip: {
          backgroundColor: darkMode ? 'rgba(30, 30, 30, 0.9)' : 'rgba(255, 255, 255, 0.9)',
          titleColor: darkMode ? '#fff' : '#333', 
          bodyColor: darkMode ? '#fff' : '#333',
          borderColor: darkMode ? '#444' : '#ddd',
          borderWidth: 1,
          callbacks: {
            label: function(context) {
              const label = context.label || '';
              const value = formatCurrency(context.raw);
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const percentage = Math.round((context.raw / total) * 100);
              return `${label}: ${value} (${percentage}%)`;
            }
          }
        }
      }
    },
    bar: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          backgroundColor: darkMode ? 'rgba(30, 30, 30, 0.9)' : 'rgba(255, 255, 255, 0.9)',
          titleColor: darkMode ? '#fff' : '#333', 
          bodyColor: darkMode ? '#fff' : '#333',
          borderColor: darkMode ? '#444' : '#ddd',
          borderWidth: 1,
          callbacks: {
            label: function(context) {
              return formatCurrency(context.raw);
            }
          }
        }
      },
      scales: {
        x: {
          grid: {
            display: false,
            drawBorder: false
          },
          ticks: {
            color: darkMode ? '#aaa' : '#666'
          }
        },
        y: {
          grid: {
            color: darkMode ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.05)',
            drawBorder: false
          },
          ticks: {
            color: darkMode ? '#aaa' : '#666',
            callback: function(value) {
              return formatCurrency(value);
            }
          }
        }
      }
    },
    people: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'right',
          labels: {
            boxWidth: 15,
            padding: 15,
            color: darkMode ? '#ddd' : '#555'
          }
        },
        tooltip: {
          backgroundColor: darkMode ? 'rgba(30, 30, 30, 0.9)' : 'rgba(255, 255, 255, 0.9)',
          titleColor: darkMode ? '#fff' : '#333', 
          bodyColor: darkMode ? '#fff' : '#333',
          borderColor: darkMode ? '#444' : '#ddd',
          borderWidth: 1,
          callbacks: {
            label: function(context) {
              const label = context.label || '';
              const value = formatCurrency(context.raw);
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const percentage = Math.round((context.raw / total) * 100);
              return `${label}: ${value} (${percentage}%)`;
            }
          }
        }
      }
    }
  };
  
  // Funções para navegação de mês
  const nextMonth = () => {
    const next = addMonths(currentMonth, 1);
    setCurrentMonth(next);
    setFilters({
      ...filters,
      startDate: format(startOfMonth(next), 'yyyy-MM-dd'),
      endDate: format(endOfMonth(next), 'yyyy-MM-dd')
    });
  };
  
  const prevMonth = () => {
    const prev = subMonths(currentMonth, 1);
    setCurrentMonth(prev);
    setFilters({
      ...filters,
      startDate: format(startOfMonth(prev), 'yyyy-MM-dd'),
      endDate: format(endOfMonth(prev), 'yyyy-MM-dd')
    });
  };
  
  // Funções para abrir/fechar o diálogo
  const handleOpenDialog = () => {
    setNewExpense(initialExpenseState);
    setEditMode(false);
    setDialogOpen(true);
  };
  
  const handleCloseDialog = () => {
    setDialogOpen(false);
    setSelectedExpense(null);
  };
  
  // Função para lidar com alterações de campos
  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    
    if (type === 'checkbox') {
      setNewExpense(prev => ({
        ...prev,
        [name]: checked
      }));
    } else {
      setNewExpense(prev => ({
        ...prev,
        [name]: value
      }));
    }
  };
  
  // Função para enviar o formulário
  const handleSubmit = (e) => {
    e.preventDefault();
    
    const expenseData = {
      ...newExpense,
      id: editMode ? selectedExpense.id : generateId(),
      amount: Number(newExpense.amount) || 0
    };
    
    if (editMode) {
      // Atualizar despesa existente
      setExpenses(prev => prev.map(expense => 
        expense.id === selectedExpense.id ? expenseData : expense
      ));
      setSnackbar({
        open: true, 
        message: 'Despesa atualizada com sucesso!', 
        severity: 'success'
      });
    } else {
      // Adicionar nova despesa
      setExpenses(prev => [...prev, expenseData]);
      setSnackbar({
        open: true, 
        message: 'Despesa adicionada com sucesso!', 
        severity: 'success'
      });
    }
    
    handleCloseDialog();
  };
  
  // Função para editar uma despesa
  const handleEditExpense = (expense) => {
    setSelectedExpense(expense);
    setNewExpense(expense);
    setEditMode(true);
    setDialogOpen(true);
  };
  
  // Função para excluir uma despesa
  const handleDeleteExpense = (id) => {
    setExpenses(prev => prev.filter(expense => expense.id !== id));
    setSnackbar({
      open: true, 
      message: 'Despesa excluída com sucesso!', 
      severity: 'success'
    });
  };
  
  // Função para lidar com alterações nos filtros
  const handleFilterChange = (e) => {
    const { name, value } = e.target;
    setFilters(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  // Função para aplicar os filtros atuais
  const applyFilters = () => {
    setDrawerOpen(false);
  };
  
  // Função para redefinir os filtros
  const resetFilters = () => {
    setFilters({
      startDate: format(startOfMonth(currentMonth), 'yyyy-MM-dd'),
      endDate: format(endOfMonth(currentMonth), 'yyyy-MM-dd'),
      category: '',
      type: '',
      paymentMethod: '',
      person: '',
      minAmount: '',
      maxAmount: '',
    });
    setDrawerOpen(false);
  };
  
  // Funções para exportação
  const handleExportClick = (event) => {
    setExportAnchorEl(event.currentTarget);
  };
  
  const handleExportClose = () => {
    setExportAnchorEl(null);
  };
  
  const handleExportCSV = () => {
    downloadCSV(filteredExpenses, `financas-familia-${format(currentMonth, 'MMM-yyyy')}.csv`);
    handleExportClose();
    setSnackbar({
      open: true, 
      message: 'Relatório CSV exportado com sucesso!', 
      severity: 'success'
    });
  };
  
  // Função para fechar o Snackbar
  const handleCloseSnackbar = () => {
    setSnackbar(prev => ({
      ...prev,
      open: false
    }));
  };
  
  // Função para alternar entre abas
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };
  
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
        {/* AppBar */}
        <AppBar 
          position="sticky" 
          elevation={0}
          sx={{ 
            backgroundColor: theme.palette.background.paper,
            color: theme.palette.text.primary,
            borderBottom: `1px solid ${theme.palette.divider}`
          }}
        >
          <Toolbar sx={{ justifyContent: 'space-between' }}>
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <IconButton 
                edge="start" 
                color="inherit" 
                onClick={() => setDrawerOpen(true)}
                sx={{ mr: 2 }}
              >
                <FilterListIcon />
              </IconButton>
              <Typography variant="h6" noWrap component="div">
                Vida Financeira da Família
              </Typography>
            </Box>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <IconButton onClick={prevMonth}>
                  <ChevronLeftIcon />
                </IconButton>
                <Typography variant="body1" sx={{ minWidth: 100, textAlign: 'center' }}>
                  {format(currentMonth, 'MMMM yyyy', { locale: ptBR })}
                </Typography>
                <IconButton onClick={nextMonth}>
                  <ChevronRightIcon />
                </IconButton>
              </Box>
              <IconButton onClick={() => setDarkMode(!darkMode)}>
                {darkMode ? <LightModeIcon /> : <DarkModeIcon />}
              </IconButton>
              <Box sx={{ display: { xs: 'none', md: 'block' } }}>
                <Button
                  variant="contained"
                  color="primary"
                  startIcon={<DownloadIcon />}
                  onClick={handleExportClick}
                  sx={{ mr: 1 }}
                >
                  Exportar
                </Button>
              </Box>
              <Button
                variant="contained"
                color="primary"
                startIcon={<AddIcon />}
                onClick={handleOpenDialog}
              >
                Nova Despesa
              </Button>
            </Box>
          </Toolbar>
        </AppBar>
        
        {/* Menu de Exportação */}
        <Menu
          anchorEl={exportAnchorEl}
          open={Boolean(exportAnchorEl)}
          onClose={handleExportClose}
        >
          <MenuItem onClick={handleExportCSV}>
            Exportar para CSV
          </MenuItem>
        </Menu>
        
        {/* Drawer de Filtros */}
        <Drawer
          anchor="left"
          open={drawerOpen}
          onClose={() => setDrawerOpen(false)}
        >
          <Box
            sx={{ width: 300 }}
            role="presentation"
          >
            <Box sx={{ 
              display: 'flex', 
              alignItems: 'center', 
              justifyContent: 'space-between', 
              p: 2, 
              borderBottom: `1px solid ${theme.palette.divider}` 
            }}>
              <Typography variant="h6">Filtros</Typography>
              <IconButton onClick={() => setDrawerOpen(false)}>
                <MenuOpenIcon />
              </IconButton>
            </Box>
            <Box sx={{ p: 2 }}>
              <Box sx={{ mb: 2 }}>
                <Typography variant="subtitle2" sx={{ mb: 1 }}>Período</Typography>
                <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ptBR}>
                  <Box sx={{ display: 'flex', gap: 2, flexDirection: 'column' }}>
                    <DatePicker
  label="Data Inicial"
  value={parseISO(filters.startDate)}
  onChange={(newValue) => {
    if (newValue) {
      setFilters(prev => ({
        ...prev,
        startDate: format(newValue, 'yyyy-MM-dd')
      }));
    }
  }}
  renderInput={(params) => <TextField {...params} fullWidth size="small" />}
/>
                    <DatePicker
                        label="Data Final"
                        value={parseISO(filters.endDate)}
                        onChange={(newValue) => {
                          if (newValue) {
                            setFilters(prev => ({
                              ...prev,
                              endDate: format(newValue, 'yyyy-MM-dd')
                            }));
                          }
                        }}
                        renderInput={(params) => <TextField {...params} fullWidth size="small" />}
                    />
                  </Box>
                </LocalizationProvider>
              </Box>
              
              <Box sx={{ mb: 2 }}>
                <Typography variant="subtitle2" sx={{ mb: 1 }}>Categoria</Typography>
                <FormControl fullWidth size="small">
                  <Select
                    name="category"
                    value={filters.category}
                    onChange={handleFilterChange}
                    displayEmpty
                  >
                    <MenuItem value="">Todas</MenuItem>
                    {categories.map((category) => (
                      <MenuItem key={category} value={category}>{category}</MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Box>
              
              <Box sx={{ mb: 2 }}>
                <Typography variant="subtitle2" sx={{ mb: 1 }}>Tipo</Typography>
                <FormControl fullWidth size="small">
                  <Select
                    name="type"
                    value={filters.type}
                    onChange={handleFilterChange}
                    displayEmpty
                  >
                    <MenuItem value="">Todos</MenuItem>
                    {types.map((type) => (
                      <MenuItem key={type} value={type}>{type}</MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Box>
              
              <Box sx={{ mb: 2 }}>
                <Typography variant="subtitle2" sx={{ mb: 1 }}>Forma de Pagamento</Typography>
                <FormControl fullWidth size="small">
                  <Select
                    name="paymentMethod"
                    value={filters.paymentMethod}
                    onChange={handleFilterChange}
                    displayEmpty
                  >
                    <MenuItem value="">Todas</MenuItem>
                    {paymentMethods.map((method) => (
                      <MenuItem key={method} value={method}>{method}</MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Box>
              
              <Box sx={{ mb: 2 }}>
                <Typography variant="subtitle2" sx={{ mb: 1 }}>Pessoa</Typography>
                <FormControl fullWidth size="small">
                  <Select
                    name="person"
                    value={filters.person}
                    onChange={handleFilterChange}
                    displayEmpty
                  >
                    <MenuItem value="">Todas</MenuItem>
                    {people.map((person) => (
                      <MenuItem key={person} value={person}>{person}</MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Box>
              
              <Box sx={{ mb: 2 }}>
                <Typography variant="subtitle2" sx={{ mb: 1 }}>Valor</Typography>
                <Box sx={{ display: 'flex', gap: 1 }}>
                  <TextField
                    name="minAmount"
                    label="Mínimo"
                    type="number"
                    size="small"
                    fullWidth
                    value={filters.minAmount}
                    onChange={handleFilterChange}
                    InputProps={{
                      startAdornment: <InputAdornment position="start">R$</InputAdornment>,
                    }}
                  />
                  <TextField
                    name="maxAmount"
                    label="Máximo"
                    type="number"
                    size="small"
                    fullWidth
                    value={filters.maxAmount}
                    onChange={handleFilterChange}
                    InputProps={{
                      startAdornment: <InputAdornment position="start">R$</InputAdornment>,
                    }}
                  />
                </Box>
              </Box>
              
              <Box sx={{ display: 'flex', gap: 2, mt: 3 }}>
                <Button 
                  variant="outlined" 
                  fullWidth
                  onClick={resetFilters}
                >
                  Limpar
                </Button>
                <Button 
                  variant="contained" 
                  color="primary" 
                  fullWidth
                  onClick={applyFilters}
                >
                  Aplicar
                </Button>
              </Box>
            </Box>
          </Box>
        </Drawer>
        
        {/* Conteúdo Principal */}
        <Container maxWidth="xl" sx={{ py: 4, flexGrow: 1 }}>
          {/* KPIs */}
          <Grid container spacing={3} sx={{ mb: 4 }}>
            <Grid item xs={12} sm={6} md={3}>
              <Card sx={{ height: '100%' }}>
                <CardContent>
                  <Typography color="textSecondary" gutterBottom>
                    Total do Período
                  </Typography>
                  <Typography variant="h4" component="div">
                    {formatCurrency(kpis.total)}
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} sm={6} md={3}>
              <Card sx={{ height: '100%' }}>
                <CardContent>
                  <Typography color="textSecondary" gutterBottom>
                    Média por Dia
                  </Typography>
                  <Typography variant="h4" component="div">
                    {formatCurrency(kpis.average)}
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} sm={6} md={3}>
              <Card sx={{ height: '100%' }}>
                <CardContent>
                  <Typography color="textSecondary" gutterBottom>
                    Categoria Principal
                  </Typography>
                  <Typography variant="h4" component="div">
                    {kpis.topCategory}
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} sm={6} md={3}>
              <Card sx={{ height: '100%' }}>
                <CardContent>
                  <Typography color="textSecondary" gutterBottom>
                    Projeção Mensal
                  </Typography>
                  <Typography variant="h4" component="div">
                    {formatCurrency(kpis.projection)}
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
          </Grid>
          
          {/* Abas para diferentes visualizações */}
          <Paper sx={{ mb: 4 }}>
            <Tabs
              value={tabValue}
              onChange={handleTabChange}
              variant="scrollable"
              scrollButtons="auto"
              sx={{ borderBottom: 1, borderColor: 'divider' }}
            >
              <Tab icon={<DashboardIcon />} label="Dashboard" />
              <Tab icon={<AttachMoneyIcon />} label="Despesas" />
              <Tab icon={<PersonIcon />} label="Por Pessoa" />
            </Tabs>
          </Paper>
          
          {/* Conteúdo da aba de Dashboard */}
          {tabValue === 0 && (
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <Card sx={{ height: '100%', minHeight: 400 }}>
                  <CardContent>
                    <Typography color="textSecondary" gutterBottom>
                      Despesas ao Longo do Tempo
                    </Typography>
                    <Box sx={{ height: 300 }}>
                      <Line data={chartData.line} options={chartOptions.line} />
                    </Box>
                  </CardContent>
                </Card>
              </Grid>
              <Grid item xs={12} md={6}>
                <Card sx={{ height: '100%', minHeight: 400 }}>
                  <CardContent>
                    <Typography color="textSecondary" gutterBottom>
                      Distribuição por Tipo
                    </Typography>
                    <Box sx={{ height: 300 }}>
                      <Doughnut data={chartData.pie} options={chartOptions.pie} />
                    </Box>
                  </CardContent>
                </Card>
              </Grid>
              <Grid item xs={12} md={6}>
                <Card sx={{ height: '100%', minHeight: 400 }}>
                  <CardContent>
                    <Typography color="textSecondary" gutterBottom>
                      Gastos por Categoria
                    </Typography>
                    <Box sx={{ height: 300 }}>
                      <Bar data={chartData.bar} options={chartOptions.bar} />
                    </Box>
                  </CardContent>
                </Card>
              </Grid>
              <Grid item xs={12} md={6}>
                <Card sx={{ height: '100%', minHeight: 400 }}>
                  <CardContent>
                    <Typography color="textSecondary" gutterBottom>
                      Gastos por Pessoa
                    </Typography>
                    <Box sx={{ height: 300 }}>
                      <Pie data={chartData.people} options={chartOptions.people} />
                    </Box>
                  </CardContent>
                </Card>
              </Grid>
            </Grid>
          )}
          
          {/* Conteúdo da aba de Despesas */}
          {tabValue === 1 && (
            <Card>
              <CardContent>
                <Typography variant="h6" sx={{ mb: 2 }}>
                  Lista de Despesas
                </Typography>
                <TableContainer>
                  <Table>
                    <TableHead>
                      <TableRow>
                        <TableCell>Data</TableCell>
                        <TableCell>Descrição</TableCell>
                        <TableCell>Categoria</TableCell>
                        <TableCell>Tipo</TableCell>
                        <TableCell>Pessoa</TableCell>
                        <TableCell align="right">Valor</TableCell>
                        <TableCell>Pagamento</TableCell>
                        <TableCell>Ações</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {filteredExpenses.length === 0 ? (
                        <TableRow>
                          <TableCell colSpan={8} align="center">
                            Nenhuma despesa encontrada para os filtros atuais.
                          </TableCell>
                        </TableRow>
                      ) : (
                        filteredExpenses.map((expense) => (
                          <TableRow key={expense.id}>
                            <TableCell>{format(parseISO(expense.date), 'dd/MM/yyyy')}</TableCell>
                            <TableCell>{expense.description || 'Sem descrição'}</TableCell>
                            <TableCell>
                              {expense.category ? (
                                <Chip 
                                  label={expense.category} 
                                  size="small" 
                                  sx={{ 
                                    backgroundColor: expense.category === 'Moradia' ? 'rgba(66, 133, 244, 0.1)' :
                                                    expense.category === 'Alimentação' ? 'rgba(219, 68, 55, 0.1)' :
                                                    expense.category === 'Transporte' ? 'rgba(244, 180, 0, 0.1)' :
                                                    expense.category === 'Lazer' ? 'rgba(15, 157, 88, 0.1)' :
                                                    'rgba(66, 133, 244, 0.1)',
                                    color: expense.category === 'Moradia' ? '#4285F4' :
                                           expense.category === 'Alimentação' ? '#DB4437' :
                                           expense.category === 'Transporte' ? '#F4B400' :
                                           expense.category === 'Lazer' ? '#0F9D58' :
                                           '#4285F4',
                                  }}
                                />
                              ) : (
                                'Não especificada'
                              )}
                            </TableCell>
                            <TableCell>
                              {expense.type ? (
                                <Chip 
                                  label={expense.type} 
                                  size="small" 
                                  sx={{ 
                                    backgroundColor: expense.type === 'Essencial' ? 'rgba(15, 157, 88, 0.1)' :
                                                    expense.type === 'Variável' ? 'rgba(66, 133, 244, 0.1)' :
                                                    expense.type === 'Supérfluo' ? 'rgba(219, 68, 55, 0.1)' :
                                                    expense.type === 'Dívida' ? 'rgba(244, 180, 0, 0.1)' :
                                                    'rgba(66, 133, 244, 0.1)',
                                    color: expense.type === 'Essencial' ? '#0F9D58' :
                                           expense.type === 'Variável' ? '#4285F4' :
                                           expense.type === 'Supérfluo' ? '#DB4437' :
                                           expense.type === 'Dívida' ? '#F4B400' :
                                           '#4285F4',
                                  }}
                                />
                              ) : (
                                'Não especificado'
                              )}
                            </TableCell>
                            <TableCell>{expense.person || 'Não especificada'}</TableCell>
                            <TableCell align="right">{formatCurrency(expense.amount)}</TableCell>
                            <TableCell>{expense.paymentMethod || 'Não especificado'}</TableCell>
                            <TableCell>
                              <IconButton
                                size="small"
                                onClick={() => handleEditExpense(expense)}
                                color="primary"
                              >
                                <EditIcon fontSize="small" />
                              </IconButton>
                              <IconButton
                                size="small"
                                onClick={() => handleDeleteExpense(expense.id)}
                                color="error"
                              >
                                <DeleteIcon fontSize="small" />
                              </IconButton>
                            </TableCell>
                          </TableRow>
                        ))
                      )}
                    </TableBody>
                  </Table>
                </TableContainer>
              </CardContent>
            </Card>
          )}
          
          {/* Conteúdo da aba Por Pessoa */}
          {tabValue === 2 && (
            <Grid container spacing={3}>
              <Grid item xs={12}>
                <Card sx={{ minHeight: 500 }}>
                  <CardContent>
                    <Typography variant="h6" sx={{ mb: 2 }}>
                      Gastos por Membro da Família
                    </Typography>
                    <Box sx={{ height: 400 }}>
                      <Pie data={chartData.people} options={chartOptions.people} />
                    </Box>
                  </CardContent>
                </Card>
              </Grid>
              {people.map(person => {
                const personExpenses = filteredExpenses.filter(e => e.person === person);
                const total = personExpenses.reduce((sum, e) => sum + Number(e.amount), 0);
                
                if (personExpenses.length === 0) return null;
                
                return (
                  <Grid item xs={12} md={6} key={person}>
                    <Card>
                      <CardContent>
                        <Typography variant="h6" sx={{ mb: 2 }}>
                          {person} - {formatCurrency(total)}
                        </Typography>
                        <TableContainer>
                          <Table size="small">
                            <TableHead>
                              <TableRow>
                                <TableCell>Data</TableCell>
                                <TableCell>Descrição</TableCell>
                                <TableCell>Categoria</TableCell>
                                <TableCell align="right">Valor</TableCell>
                              </TableRow>
                            </TableHead>
                            <TableBody>
                              {personExpenses.map(expense => (
                                <TableRow key={expense.id}>
                                  <TableCell>{format(parseISO(expense.date), 'dd/MM/yyyy')}</TableCell>
                                  <TableCell>{expense.description || 'Sem descrição'}</TableCell>
                                  <TableCell>{expense.category || 'Não especificada'}</TableCell>
                                  <TableCell align="right">{formatCurrency(expense.amount)}</TableCell>
                                </TableRow>
                              ))}
                            </TableBody>
                          </Table>
                        </TableContainer>
                      </CardContent>
                    </Card>
                  </Grid>
                );
              })}
            </Grid>
          )}
        </Container>
        
        {/* Diálogo para adicionar/editar despesa */}
        <Dialog open={dialogOpen} onClose={handleCloseDialog} maxWidth="sm" fullWidth>
          <DialogTitle>
            {editMode ? 'Editar Despesa' : 'Nova Despesa'}
          </DialogTitle>
          <DialogContent>
            <Box component="form" onSubmit={handleSubmit} sx={{ mt: 2 }}>
              <Grid container spacing={2}>
                <Grid item xs={12}>
                  <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ptBR}>
                    <DatePicker
                      label="Data"
                      value={parseISO(newExpense.date)}
                      onChange={(newValue) => {
                        if (newValue) {
                          setNewExpense(prev => ({
                            ...prev,
                            date: format(newValue, 'yyyy-MM-dd')
                          }));
                        }
                      }}
                      renderInput={(params) => <TextField {...params} fullWidth />}
                    />
                  </LocalizationProvider>
                </Grid>
                <Grid item xs={12}>
                  <TextField
                    name="description"
                    label="Descrição"
                    value={newExpense.description}
                    onChange={handleInputChange}
                    fullWidth
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <FormControl fullWidth>
                    <InputLabel>Categoria</InputLabel>
                    <Select
                      name="category"
                      value={newExpense.category}
                      onChange={handleInputChange}
                      label="Categoria"
                    >
                      <MenuItem value="">
                        <em>Nenhuma</em>
                      </MenuItem>
                      {categories.map((category) => (
                        <MenuItem key={category} value={category}>
                          {category}
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    name="amount"
                    label="Valor (R$)"
                    type="number"
                    value={newExpense.amount}
                    onChange={handleInputChange}
                    fullWidth
                    InputProps={{
                      startAdornment: <InputAdornment position="start">R$</InputAdornment>,
                    }}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <FormControl fullWidth>
                    <InputLabel>Tipo</InputLabel>
                    <Select
                      name="type"
                      value={newExpense.type}
                      onChange={handleInputChange}
                      label="Tipo"
                    >
                      <MenuItem value="">
                        <em>Nenhum</em>
                      </MenuItem>
                      {types.map((type) => (
                        <MenuItem key={type} value={type}>
                          {type}
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>
                <Grid item xs={12} sm={6}>
                  <FormControl fullWidth>
                    <InputLabel>Forma de Pagamento</InputLabel>
                    <Select
                      name="paymentMethod"
                      value={newExpense.paymentMethod}
                      onChange={handleInputChange}
                      label="Forma de Pagamento"
                    >
                      <MenuItem value="">
                        <em>Nenhuma</em>
                      </MenuItem>
                      {paymentMethods.map((method) => (
                        <MenuItem key={method} value={method}>
                          {method}
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>
                <Grid item xs={12}>
                  <FormControlLabel
                    control={
                      <Checkbox
                        name="isInstallment"
                        checked={newExpense.isInstallment}
                        onChange={handleInputChange}
                      />
                    }
                    label="Pagamento Parcelado"
                  />
                </Grid>
                {newExpense.isInstallment && (
                  <Grid item xs={12}>
                    <TextField
                      name="installmentCount"
                      label="Número de Parcelas"
                      type="number"
                      value={newExpense.installmentCount}
                      onChange={handleInputChange}
                      fullWidth
                    />
                  </Grid>
                )}
                <Grid item xs={12}>
                  <FormControl fullWidth>
                    <InputLabel>Pessoa</InputLabel>
                    <Select
                      name="person"
                      value={newExpense.person}
                      onChange={handleInputChange}
                      label="Pessoa"
                    >
                      <MenuItem value="">
                        <em>Nenhuma</em>
                      </MenuItem>
                      {people.map((person) => (
                        <MenuItem key={person} value={person}>
                          {person}
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>
              </Grid>
            </Box>
          </DialogContent>
          <DialogActions>
            <Button onClick={handleCloseDialog}>Cancelar</Button>
            <Button variant="contained" color="primary" onClick={handleSubmit}>
              {editMode ? 'Atualizar' : 'Adicionar'}
            </Button>
          </DialogActions>
        </Dialog>
        
        {/* Snackbar para mensagens de feedback */}
        <Snackbar 
          open={snackbar.open} 
          autoHideDuration={4000} 
          onClose={handleCloseSnackbar}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
        >
          <Alert 
            onClose={handleCloseSnackbar} 
            severity={snackbar.severity} 
            variant="filled"
            sx={{ width: '100%' }}
          >
            {snackbar.message}
          </Alert>
        </Snackbar>
      </Box>
    </ThemeProvider>
  );
}

export default App;
