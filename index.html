<!-- ===== INÍCIO: BLOCO 1 (Corrigido) ============================== -->
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema Financeiro Familiar Premium</title>

    <meta name="description" content="Gerencie suas finanças familiares com uma interface premium, intuitiva e poderosa.">
    <meta name="theme-color" content="#0A84FF">

    <!-- Favicon (Caminhos relativos - assumindo que estão na mesma pasta ou subpasta 'assets') -->
    <!-- Ajuste o caminho se necessário (ex: "assets/favicon.ico") -->
    <!-- Se não tiver os arquivos, pode comentar estas linhas temporariamente -->
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="manifest" href="site.webmanifest">
    <link rel="mask-icon" href="safari-pinned-tab.svg" color="#0a84ff">
    <meta name="msapplication-TileColor" content="#0a84ff">

    <!-- Pré-conexão para otimizar carregamento -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">

    <!-- Fonte Principal (Inter) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Ícones (Font Awesome via CDN) -->
    <!-- O atributo integrity foi removido do Font Awesome também por segurança, embora geralmente funcione -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <!-- Arquivo CSS Principal -->
    <!-- !!! GARANTA QUE 'style.css' ESTEJA NA MESMA PASTA QUE ESTE ARQUIVO HTML !!! -->
    <link rel="stylesheet" href="style.css">

    <!-- Chart.js (via CDN) -->
    <!-- !!! ATRIBUTOS integrity E crossorigin REMOVIDOS PARA EVITAR ERRO LOCAL !!! -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>

</head>
<!-- ===== FIM: BLOCO 1 (Corrigido) ================================ -->

/* ===== INÍCIO: BLOCO 2 ============================== */
/* ==== VARIÁVEIS CSS GLOBAIS E TEMAS ==== */

:root {
    /* ===== Cores Semânticas (Base Claro) ===== */
    /* Usando cores padrão Apple/Material You como referência */
    --color-primary-base: #0A84FF; /* Azul */
    --color-success-base: #30D158; /* Verde */
    --color-danger-base:  #FF453A; /* Vermelho */
    --color-warning-base: #FF9F0A; /* Laranja */
    --color-info-base:    #64D2FF; /* Azul Claro */

    /* Níveis de importância (usar com moderação para destaque) */
    --color-importance-extreme: var(--color-danger-base);
    --color-importance-urgent: var(--color-warning-base);
    --color-importance-important: var(--color-primary-base);

    /* Financeiro */
    --color-finance-positive: var(--color-success-base);
    --color-finance-negative: var(--color-danger-base);
    --color-finance-neutral: #8A8A8E; /* Cinza neutro Apple */
    --color-finance-pending: var(--color-warning-base);
    --color-finance-scheduled: var(--color-info-base);
    --color-finance-paid: var(--color-success-base);

    /* ===== Tipografia ===== */
    --font-family-base: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    /* Escala Modular de Tipografia */
    --font-size-xs:   0.75rem;    /* 12px */
    --font-size-sm:   0.875rem;   /* 14px */
    --font-size-md:   1rem;       /* 16px - Base */
    --font-size-lg:   1.125rem;   /* 18px */
    --font-size-xl:   1.25rem;    /* 20px */
    --font-size-2xl:  1.5rem;     /* 24px */
    --font-size-3xl:  1.875rem;   /* 30px */
    /* Pesos */
    --font-weight-regular: 400;
    --font-weight-medium: 500;
    --font-weight-semibold: 600;
    --font-weight-bold: 700;
    /* Altura da Linha */
    --line-height-tight:  1.25;
    --line-height-normal: 1.5;
    --line-height-relaxed: 1.75;

    /* ===== Espaçamentos (Escala Modular 4px) ===== */
    --spacing-unit: 4px;
    --spacing-1:  calc(1 * var(--spacing-unit)); /* 4px */
    --spacing-2:  calc(2 * var(--spacing-unit)); /* 8px */
    --spacing-3:  calc(3 * var(--spacing-unit)); /* 12px */
    --spacing-4:  calc(4 * var(--spacing-unit)); /* 16px */
    --spacing-5:  calc(5 * var(--spacing-unit)); /* 20px */
    --spacing-6:  calc(6 * var(--spacing-unit)); /* 24px */
    --spacing-8:  calc(8 * var(--spacing-unit)); /* 32px */
    --spacing-10: calc(10 * var(--spacing-unit)); /* 40px */
    --spacing-12: calc(12 * var(--spacing-unit)); /* 48px */
    --spacing-16: calc(16 * var(--spacing-unit)); /* 64px */

    /* ===== Bordas ===== */
    --border-radius-sm:  4px;
    --border-radius-md:  8px;  /* Padrão para inputs, botões */
    --border-radius-lg:  12px; /* Padrão para cards */
    --border-radius-xl:  16px;
    --border-radius-full: 9999px;
    --border-width: 1px;
    --border-width-lg: 2px;

    /* ===== Sombras (Estilo Suave iOS/macOS) ===== */
    --shadow-color-light: rgba(0, 0, 0, 0.08);
    --shadow-color-dark: rgba(0, 0, 0, 0.4);
    --shadow-sm: 0 1px 2px 0 var(--shadow-color);
    --shadow-md: 0 4px 8px 0 var(--shadow-color); /* Sombra padrão para cards */
    --shadow-lg: 0 10px 20px 0 var(--shadow-color);
    --shadow-xl: 0 20px 40px 0 var(--shadow-color);
    --shadow-inset: inset 0 2px 4px 0 var(--shadow-color);

    /* ===== Transições ===== */
    --transition-duration-fast: 0.15s;
    --transition-duration-normal: 0.25s; /* Padrão */
    --transition-duration-slow: 0.4s;
    --transition-timing-function: ease-in-out;
    --transition-base: all var(--transition-duration-normal) var(--transition-timing-function);
    --transition-fast: all var(--transition-duration-fast) var(--transition-timing-function);
    --transition-colors: background-color var(--transition-duration-normal) var(--transition-timing-function),
                         color var(--transition-duration-normal) var(--transition-timing-function),
                         border-color var(--transition-duration-normal) var(--transition-timing-function);

    /* ===== Z-index ===== */
    --z-index-base: 1;
    --z-index-sticky: 100;
    --z-index-dropdown: 1000;
    --z-index-modal-backdrop: 1040;
    --z-index-modal: 1050;
    --z-index-toast: 1100;

    /* ===== Layout Base ===== */
    --container-max-width: 1440px; /* Largura máxima para conteúdo centralizado */
    --header-height: 64px;
    --sidebar-width: 260px;
    --sidebar-width-collapsed: 80px; /* Largura da sidebar recolhida */
}

/* ============================================ */
/* ==========      TEMA CLARO      ========== */
/* ============================================ */
[data-theme="light"] {
    /* Cores Semânticas */
    --color-primary: var(--color-primary-base);
    --color-success: var(--color-success-base);
    --color-danger: var(--color-danger-base);
    --color-warning: var(--color-warning-base);
    --color-info: var(--color-info-base);

    /* Cores Neutras e de Superfície */
    --color-background: #F2F2F7;           /* Fundo Cinza Claro Apple */
    --color-surface: #FFFFFF;              /* Superfície Branca (Cards, Modais) */
    --color-surface-variant: #F9F9F9;      /* Variação levemente acinzentada */
    --color-surface-hover: #EFEFF4;        /* Hover sutil (cinza um pouco mais escuro) */

    /* Cores de Texto */
    --color-text-primary: #1D1D1F;         /* Texto Principal Preto Suave Apple */
    --color-text-secondary: #6E6E73;       /* Texto Secundário Cinza Apple */
    --color-text-tertiary: #AEAEB2;        /* Texto Terciário Cinza Mais Claro Apple */
    --color-text-disabled: #C6C6C8;        /* Texto Desabilitado */
    --color-text-on-primary: #FFFFFF;      /* Texto sobre cor primária */
    --color-text-on-danger: #FFFFFF;       /* Texto sobre cor de perigo */
    --color-text-placeholder: #C7C7CD;     /* Cor para placeholder */

    /* Cores de Borda */
    --color-border: #D1D1D6;               /* Borda Padrão Cinza Apple */
    --color-border-light: #E5E5EA;         /* Borda Mais Clara / Divisores */
    --color-border-focus: var(--color-primary-base); /* Borda ao focar elemento */

    /* Sombra */
    --shadow-color: var(--shadow-color-light);
}

/* ============================================ */
/* ==========      TEMA ESCURO     ========== */
/* ============================================ */
[data-theme="dark"] {
    /* Cores Semânticas (manter vibrantes ou ajustar levemente se necessário) */
    --color-primary: #0A84FF; /* Manter o mesmo azul vibrante */
    --color-success: #32D74B; /* Verde um pouco mais vibrante no escuro */
    --color-danger:  #FF453A;
    --color-warning: #FF9F0A;
    --color-info:    #64D2FF;

    /* Cores Neutras e de Superfície */
    --color-background: #000000;           /* Fundo Preto Apple */
    --color-surface: #1C1C1E;              /* Superfície Cinza Escuro Apple (Cards) */
    --color-surface-variant: #2C2C2E;      /* Variação de superfície (e.g., header, sidebar) */
    --color-surface-hover: #3A3A3C;        /* Hover sutil */

    /* Cores de Texto */
    --color-text-primary: #FFFFFF;         /* Texto Principal Branco */
    --color-text-secondary: #EBEBF599;     /* Texto Secundário (Branco com 60% opacidade) Apple */
    --color-text-tertiary: #EBEBF54D;      /* Texto Terciário (Branco com 30% opacidade) Apple */
    --color-text-disabled: #EBEBF52E;      /* Texto Desabilitado (Branco com 18% opacidade) */
    --color-text-on-primary: #FFFFFF;
    --color-text-on-danger: #FFFFFF;
    --color-text-placeholder: #EBEBF54D;   /* Cor para placeholder */

    /* Cores de Borda */
    --color-border: #38383A;               /* Borda Padrão Cinza Escuro Apple */
    --color-border-light: #48484A;         /* Borda Mais Clara / Divisores */
    --color-border-focus: var(--color-primary-base);

    /* Sombra */
    --shadow-color: var(--shadow-color-dark);
}
/* ===== FIM: BLOCO 2 ================================ */

<!-- ===== INÍCIO: BLOCO 3 ============================== -->
<body data-theme="light"> <!-- Inicia com tema claro por padrão -->

    <div class="app-container">

        <!-- ===== Barra Lateral (Sidebar) ===== -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="#" class="app-logo" aria-label="Página inicial do Sistema Financeiro">
                    <!-- Ícone SVG Simples (Leve e nítido) -->
                    <svg class="logo-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"/>
                    </svg>
                    <span class="app-title">Financeiro Premium</span>
                </a>
                 <!-- Botão de Pin/Unpin (opcional, para futuras melhorias) -->
                 <button class="sidebar-action-btn sidebar-toggle-pin" id="sidebar-pin-toggle" title="Fixar/Desafixar barra lateral" aria-label="Fixar ou desafixar barra lateral">
                    <i class="fas fa-thumbtack"></i>
                </button>
            </div>

            <nav class="sidebar-nav" aria-label="Navegação principal">
                <ul class="nav-menu">
                    <li class="nav-item active" data-module="dashboard" role="menuitem">
                        <i class="fas fa-chart-pie nav-icon" aria-hidden="true"></i>
                        <span class="nav-text">Dashboard</span>
                    </li>
                    <li class="nav-item" data-module="monthly-analysis" role="menuitem">
                        <i class="fas fa-calendar-alt nav-icon" aria-hidden="true"></i>
                        <span class="nav-text">Análise Mensal</span>
                    </li>
                    <li class="nav-item" data-module="cash-projection" role="menuitem">
                        <i class="fas fa-chart-line nav-icon" aria-hidden="true"></i>
                        <span class="nav-text">Projeção de Caixa</span>
                    </li>
                    <li class="nav-item" data-module="financial-goals" role="menuitem">
                        <i class="fas fa-bullseye nav-icon" aria-hidden="true"></i>
                        <span class="nav-text">Metas Financeiras</span>
                    </li>
                    <li class="nav-item" data-module="settings" role="menuitem">
                        <i class="fas fa-cog nav-icon" aria-hidden="true"></i>
                        <span class="nav-text">Ajustes</span>
                    </li>
                </ul>
            </nav>

            <div class="sidebar-footer">
                <button id="theme-toggle" class="sidebar-action-btn theme-toggle-btn" title="Alternar tema claro/escuro" aria-label="Alternar tema">
                    <i class="fas fa-moon theme-icon-moon" aria-hidden="true"></i>
                    <i class="fas fa-sun theme-icon-sun" aria-hidden="true" style="display: none;"></i>
                </button>
                <!-- Pode adicionar link de perfil, logout etc. aqui -->
                 <div class="sidebar-user-profile" title="Configurações do usuário (Futuro)">
                     <i class="fas fa-user-circle"></i>
                 </div>
            </div>
        </aside>

        <!-- ===== Conteúdo Principal ===== -->
        <main class="main-content" id="main-content">
            <header class="content-header">
                <div class="header-left">
                    <button class="header-action-btn sidebar-toggle-mobile" id="sidebar-toggle-mobile" title="Alternar menu" aria-label="Abrir ou fechar menu lateral">
                        <i class="fas fa-bars"></i>
                    </button>
                    <h2 id="current-module-title" class="module-title" aria-live="polite">Dashboard</h2>
                </div>
                <div class="header-center" id="header-filters-container">
                    <!-- Filtros globais (Mês/Ano, etc.) serão inseridos aqui dinamicamente -->
                    <div class="filter-group">
                        <label for="global-month-year-filter" class="sr-only">Filtrar por Mês/Ano</label>
                        <select id="global-month-year-filter" class="filter-select" aria-label="Selecionar Mês e Ano para filtrar dados">
                            <!-- Opções preenchidas via JS -->
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="global-person-filter" class="sr-only">Filtrar por Pessoa</label>
                        <select id="global-person-filter" class="filter-select" aria-label="Selecionar pessoa para filtrar dados">
                            <option value="all">Todas as Pessoas</option>
                            <!-- Opções preenchidas via JS -->
                        </select>
                     </div>
                </div>
                <div class="header-right">
                    <button id="new-transaction-btn" class="btn btn-primary btn-with-icon">
                        <i class="fas fa-plus" aria-hidden="true"></i>
                        <span class="btn-text">Nova Transação</span>
                    </button>
                </div>
            </header>

            <div class="content-area" id="content-area" role="region" aria-live="polite" aria-atomic="true">
                <!-- O conteúdo dinâmico dos módulos será carregado aqui -->
                <div class="loading-spinner-container active" id="loading-spinner"> <!-- Começa visível -->
                    <i class="fas fa-spinner fa-spin loading-icon" aria-hidden="true"></i>
                    <span class="sr-only">Carregando conteúdo...</span>
                </div>
            </div>
        </main>

        <!-- ===== Overlay para Modais e Sidebar Mobile ===== -->
        <div class="overlay" id="overlay" aria-hidden="true"></div>

    </div> <!-- Fim .app-container -->

    <!-- ====================================================== -->
    <!-- ========= ÁREA DE MODAIS (Fora do Fluxo) =========== -->
    <!-- ====================================================== -->
    <!-- Será preenchida com os modais nos próximos blocos -->
    <div id="modal-container"></div>

    <!-- ====================================================== -->
    <!-- ===== ÁREA DE TOASTS (Notificações Rápidas) ===== -->
    <!-- ====================================================== -->
    <div id="toast-container" class="toast-container" aria-live="assertive"></div>


    <!-- ====================================================== -->
    <!-- ============= SCRIPTS PRINCIPAIS =================== -->
    <!-- ====================================================== -->

    <!-- Firebase SDK (via CDN) -->
    <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-firestore-compat.js"></script>
    <!-- Se precisar de Auth no futuro: <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-auth-compat.js"></script> -->

    <!-- Chart.js (via CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js" integrity="sha256-R4pqcOYV8lt7odmcUf99UEZvXtlER7CLYPAyLtfj7B0=" crossorigin="anonymous"></script>

    <!-- Arquivos JavaScript Locais (Organizados por responsabilidade) -->
    <!-- Estes arquivos serão criados/preenchidos nos próximos blocos -->
    <!-- <script src="js/config.js"></script> -->
    <!-- <script src="js/utils.js"></script> -->
    <!-- <script src="js/firebaseService.js"></script> -->
    <!-- <script src="js/uiComponents.js"></script> -->
    <!-- <script src="js/modules/dashboard.js"></script> -->
    <!-- <script src="js/modules/monthlyAnalysis.js"></script> -->
    <!-- <script src="js/modules/cashProjection.js"></script> -->
    <!-- <script src="js/modules/financialGoals.js"></script> -->
    <!-- <script src="js/modules/settings.js"></script> -->
    <!-- <script src="js/app.js"></script> -->

</body>
<!-- ===== FIM: BLOCO 3 ================================ -->

/* ===== INÍCIO: BLOCO 4 ============================== */
/* ==== CSS BASE - RESET, GLOBAIS, TIPOGRAFIA ==== */

/* ----- Reset Básico Moderno ----- */
*,
*::before,
*::after {
  box-sizing: border-box; /* Garante que padding e border não aumentem o tamanho do elemento */
  margin: 0;
  padding: 0;
  -webkit-tap-highlight-color: transparent; /* Remove highlight azul no toque em mobile */
}

/* ----- Estilos Globais HTML e Body ----- */
html {
  font-size: 16px; /* Define 1rem = 16px */
  height: 100%;
  /* Melhora a rolagem em alguns navegadores */
  scroll-behavior: smooth;
}

body {
  height: 100%;
  font-family: var(--font-family-base);
  font-size: var(--font-size-md);
  line-height: var(--line-height-normal);
  color: var(--color-text-primary);
  background-color: var(--color-background);
  overflow-x: hidden; /* Previne scroll horizontal indesejado */
  /* Melhora a renderização de fontes */
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
  /* Aplica transição suave na mudança de tema */
  transition: var(--transition-colors);
}

/* ----- Tipografia Base ----- */
h1, h2, h3, h4, h5, h6 {
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  margin-bottom: var(--spacing-4); /* 16px */
  color: var(--color-text-primary);
}

h1 { font-size: var(--font-size-3xl); } /* 30px */
h2 { font-size: var(--font-size-2xl); } /* 24px */
h3 { font-size: var(--font-size-xl); }  /* 20px */
h4 { font-size: var(--font-size-lg); }  /* 18px */
h5 { font-size: var(--font-size-md); }  /* 16px */
h6 { font-size: var(--font-size-sm); }  /* 14px */

p {
  margin-bottom: var(--spacing-4); /* 16px */
  color: var(--color-text-secondary);
}

a {
  color: var(--color-primary);
  text-decoration: none;
  transition: color var(--transition-duration-fast) ease-in-out;
}

a:hover, a:focus {
  color: color-mix(in srgb, var(--color-primary) 80%, var(--color-text-primary) 20%); /* Escurece levemente */
  text-decoration: underline; /* Opcional: adicionar sublinhado no hover/focus */
  outline: none; /* Remover outline padrão se estilizar o foco de outra forma */
}

ul, ol {
  list-style-position: inside;
  margin-bottom: var(--spacing-4);
  padding-left: var(--spacing-5); /* 20px - Adiciona espaço para marcadores */
  color: var(--color-text-secondary);
}

li {
  margin-bottom: var(--spacing-2); /* 8px */
}

strong, b {
  font-weight: var(--font-weight-bold);
  color: var(--color-text-primary);
}

em, i {
  font-style: italic;
}

/* ----- Outros Elementos Base ----- */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block; /* Previne espaço extra abaixo de imagens */
  max-width: 100%; /* Garante responsividade */
  height: auto;
}

svg {
  fill: currentColor; /* Permite que a cor do SVG seja definida pelo CSS (color) */
}

button,
input,
select,
textarea {
  font-family: inherit; /* Herda a fonte do body */
  font-size: inherit;
  line-height: inherit;
  color: inherit; /* Herda a cor do texto */
  border: var(--border-width) solid var(--color-border); /* Borda padrão sutil */
  background-color: var(--color-surface); /* Fundo padrão */
  border-radius: var(--border-radius-md); /* Raio padrão */
}

button {
  cursor: pointer;
  border: none; /* Remove borda padrão de botões */
  background-color: transparent; /* Botões sem fundo por padrão */
  padding: 0; /* Remove padding padrão */
}

textarea {
  resize: vertical; /* Permite apenas redimensionamento vertical */
  min-height: 80px; /* Altura mínima */
}

/* ----- Estilização da Scrollbar (Sutil e Moderna) ----- */
/* Funciona em navegadores baseados em WebKit (Chrome, Safari, Edge) */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: transparent; /* Fundo da trilha transparente */
}

::-webkit-scrollbar-thumb {
  background-color: color-mix(in srgb, var(--color-text-tertiary) 50%, transparent); /* Cor do polegar semi-transparente */
  border-radius: var(--border-radius-full);
  transition: background-color var(--transition-duration-fast) ease-in-out;
}

::-webkit-scrollbar-thumb:hover {
  background-color: var(--color-text-tertiary); /* Cor mais sólida no hover */
}

/* ----- Classe de Acessibilidade ----- */
/* Esconde visualmente, mas mantém acessível para leitores de tela */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

/* ===== FIM: BLOCO 4 ================================ */

/* ===== INÍCIO: BLOCO 5 ============================== */
/* ==== CSS LAYOUT PRINCIPAL (App Container, Sidebar, Main Content) ==== */

/* ----- Container Principal da Aplicação ----- */
.app-container {
  display: flex;
  height: 100vh; /* Ocupa toda a altura da viewport */
  overflow: hidden; /* Previne scroll no container principal */
  position: relative; /* Necessário para o overlay e sidebar mobile */
}

/* ----- Barra Lateral (Sidebar) ----- */
.sidebar {
  width: var(--sidebar-width);
  height: 100%;
  background-color: var(--color-surface-variant); /* Fundo ligeiramente diferente do conteúdo */
  border-right: var(--border-width) solid var(--color-border-light);
  display: flex;
  flex-direction: column;
  flex-shrink: 0; /* Não permite que a sidebar encolha */
  transition: width var(--transition-duration-normal) var(--transition-timing-function),
              transform var(--transition-duration-normal) var(--transition-timing-function);
  z-index: var(--z-index-sticky);
  position: relative; /* Para o botão de pin */
}

.sidebar-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--spacing-4); /* 16px */
  height: var(--header-height);
  border-bottom: var(--border-width) solid var(--color-border-light);
  flex-shrink: 0; /* Não encolher o header */
}

.app-logo {
  display: flex;
  align-items: center;
  gap: var(--spacing-2); /* 8px */
  text-decoration: none;
  color: var(--color-text-primary);
  overflow: hidden; /* Para esconder o texto quando recolhido */
}

.app-logo:hover,
.app-logo:focus {
  text-decoration: none; /* Remover sublinhado */
}

.logo-icon {
  width: 28px; /* Tamanho do ícone */
  height: 28px;
  flex-shrink: 0;
  color: var(--color-primary); /* Ícone com cor primária */
}

.app-title {
  font-size: var(--font-size-lg); /* 18px */
  font-weight: var(--font-weight-semibold);
  white-space: nowrap; /* Não quebrar linha */
  opacity: 1;
  transition: opacity var(--transition-duration-fast) ease-in-out;
}

.sidebar-nav {
  flex-grow: 1; /* Ocupa o espaço restante */
  overflow-y: auto; /* Scroll se necessário */
  overflow-x: hidden;
  padding: var(--spacing-4) 0; /* 16px vertical, 0 horizontal */
}

.nav-menu {
  list-style: none;
  padding: 0;
  margin: 0;
}

.nav-item {
  display: flex;
  align-items: center;
  padding: var(--spacing-3) var(--spacing-4); /* 12px vertical, 16px horizontal */
  margin: 0 var(--spacing-2); /* 8px horizontal */
  border-radius: var(--border-radius-md);
  cursor: pointer;
  color: var(--color-text-secondary);
  transition: background-color var(--transition-duration-fast) ease-in-out,
              color var(--transition-duration-fast) ease-in-out;
  white-space: nowrap;
  overflow: hidden; /* Garante que o texto não vaze */
}

.nav-item:hover {
  background-color: var(--color-surface-hover);
  color: var(--color-text-primary);
}

.nav-item.active {
  background-color: var(--color-primary);
  color: var(--color-text-on-primary);
  font-weight: var(--font-weight-medium);
}

.nav-item.active:hover {
  background-color: color-mix(in srgb, var(--color-primary) 90%, black 10%); /* Levemente mais escuro no hover ativo */
}

.nav-icon {
  width: 20px; /* Tamanho do ícone de navegação */
  height: 20px;
  margin-right: var(--spacing-3); /* 12px */
  text-align: center;
  flex-shrink: 0;
  font-size: var(--font-size-lg); /* Tamanho do ícone */
}

.nav-text {
  opacity: 1;
  transition: opacity var(--transition-duration-fast) ease-in-out;
}

.sidebar-footer {
  padding: var(--spacing-4);
  border-top: var(--border-width) solid var(--color-border-light);
  display: flex;
  align-items: center;
  justify-content: space-between; /* Distribui os botões */
  flex-shrink: 0; /* Não encolher o footer */
}

.sidebar-action-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border-radius: var(--border-radius-md);
  color: var(--color-text-secondary);
  background-color: transparent;
  border: none;
  cursor: pointer;
  transition: background-color var(--transition-duration-fast) ease-in-out,
              color var(--transition-duration-fast) ease-in-out;
}

.sidebar-action-btn:hover,
.sidebar-action-btn:focus {
  background-color: var(--color-surface-hover);
  color: var(--color-text-primary);
  outline: none;
}

.theme-toggle-btn .theme-icon-moon { display: block; }
.theme-toggle-btn .theme-icon-sun { display: none; }
[data-theme="dark"] .theme-toggle-btn .theme-icon-moon { display: none; }
[data-theme="dark"] .theme-toggle-btn .theme-icon-sun { display: block; }

.sidebar-user-profile {
  font-size: var(--font-size-xl); /* Tamanho do ícone de usuário */
  color: var(--color-text-tertiary);
  cursor: default; /* Mudar para pointer se for clicável */
}

/* ----- Estilos Sidebar Recolhida (será ativado via JS adicionando a classe 'collapsed') ----- */
.sidebar.collapsed {
  width: var(--sidebar-width-collapsed);
}

.sidebar.collapsed .app-title,
.sidebar.collapsed .nav-text {
  opacity: 0;
  width: 0;
  overflow: hidden;
}

.sidebar.collapsed .app-logo {
  justify-content: center; /* Centraliza o ícone */
}

.sidebar.collapsed .nav-item {
  justify-content: center; /* Centraliza o ícone */
  margin: var(--spacing-1) var(--spacing-2); /* Ajusta margem */
}

.sidebar.collapsed .nav-icon {
  margin-right: 0; /* Remove margem do ícone */
}

.sidebar.collapsed .sidebar-footer {
  justify-content: center; /* Centraliza botões */
  gap: var(--spacing-2);
}

.sidebar.collapsed .sidebar-toggle-pin {
   transform: rotate(90deg); /* Gira o ícone de pin */
}

/* ----- Conteúdo Principal ----- */
.main-content {
  flex-grow: 1; /* Ocupa o espaço restante */
  display: flex;
  flex-direction: column;
  height: 100vh; /* Garante altura total */
  overflow: hidden; /* Previne scroll no main-content */
  background-color: var(--color-background); /* Fundo do conteúdo */
}

.content-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: var(--header-height);
  padding: 0 var(--spacing-6); /* 24px horizontal */
  border-bottom: var(--border-width) solid var(--color-border-light);
  background-color: var(--color-surface); /* Header com fundo de superfície */
  flex-shrink: 0; /* Não encolher */
  gap: var(--spacing-4);
}

.header-left, .header-center, .header-right {
  display: flex;
  align-items: center;
  gap: var(--spacing-4); /* Espaço entre elementos dentro de cada seção */
}

.header-center {
  flex-grow: 1; /* Ocupa espaço central */
  justify-content: flex-start; /* Alinha filtros à esquerda no centro */
}

.header-action-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border-radius: var(--border-radius-md);
  color: var(--color-text-secondary);
  background-color: transparent;
  border: none;
  cursor: pointer;
  transition: background-color var(--transition-duration-fast) ease-in-out,
              color var(--transition-duration-fast) ease-in-out;
}
.header-action-btn:hover,
.header-action-btn:focus {
  background-color: var(--color-surface-hover);
  color: var(--color-text-primary);
  outline: none;
}

.sidebar-toggle-mobile {
  display: none; /* Escondido por padrão em desktop */
}

.module-title {
  font-size: var(--font-size-xl); /* 20px */
  font-weight: var(--font-weight-bold);
  margin: 0;
}

.filter-group {
  display: flex;
  align-items: center;
}

.filter-select {
  padding: var(--spacing-2) var(--spacing-3); /* 8px 12px */
  padding-right: var(--spacing-8); /* Espaço para a seta */
  min-width: 150px; /* Largura mínima */
  appearance: none; /* Remove aparência padrão */
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23AEAEB2' width='18px' height='18px'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right var(--spacing-3) center;
  background-size: 18px;
  cursor: pointer;
}
[data-theme="dark"] .filter-select {
   background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23EBEBF54D' width='18px' height='18px'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
}

.filter-select:focus {
   border-color: var(--color-border-focus);
   outline: none;
   box-shadow: 0 0 0 2px color-mix(in srgb, var(--color-primary) 15%, transparent);
}

.content-area {
  flex-grow: 1; /* Ocupa o espaço restante */
  overflow-y: auto; /* Habilita scroll vertical apenas na área de conteúdo */
  padding: var(--spacing-6); /* 24px */
  position: relative; /* Para o spinner de carregamento */
}

/* ----- Spinner de Carregamento ----- */
.loading-spinner-container {
  position: absolute;
  inset: 0; /* Cobre toda a content-area */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: color-mix(in srgb, var(--color-background) 80%, transparent); /* Fundo semi-transparente */
  z-index: var(--z-index-base);
  opacity: 0;
  visibility: hidden;
  transition: opacity var(--transition-duration-fast) ease-in-out,
              visibility var(--transition-duration-fast) ease-in-out;
}

.loading-spinner-container.active {
  opacity: 1;
  visibility: visible;
}

.loading-icon {
  font-size: var(--font-size-3xl); /* 30px */
  color: var(--color-primary);
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* ----- Overlay para Sidebar Mobile ----- */
.overlay {
  position: fixed;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.4);
  z-index: calc(var(--z-index-sticky) - 1); /* Abaixo da sidebar mobile */
  opacity: 0;
  visibility: hidden;
  transition: opacity var(--transition-duration-normal) ease-in-out,
              visibility var(--transition-duration-normal) ease-in-out;
}

.overlay.active {
  opacity: 1;
  visibility: visible;
}

/* ----- Responsividade (Mobile) ----- */
@media (max-width: 992px) { /* Ajuste breakpoint se necessário */
  .sidebar {
    position: fixed; /* Muda para fixo em telas menores */
    top: 0;
    left: 0;
    transform: translateX(-100%);
    z-index: var(--z-index-modal); /* Fica acima do overlay */
    box-shadow: var(--shadow-lg); /* Sombra mais pronunciada */
  }

  .sidebar.open {
    transform: translateX(0);
  }

  /* Esconde botão de pin em mobile */
  .sidebar-toggle-pin {
      display: none;
  }

  /* Mostra botão de abrir/fechar sidebar no header */
  .sidebar-toggle-mobile {
    display: flex;
  }

  .content-header {
    padding: 0 var(--spacing-4); /* Menor padding */
  }

   /* Ocultar filtros do header em mobile por padrão (podem ser movidos para dentro da área de conteúdo se necessário) */
  .header-center {
      display: none;
  }

  .content-area {
    padding: var(--spacing-4); /* Menor padding */
  }
}
/* ===== FIM: BLOCO 5 ================================ */

/* ===== INÍCIO: BLOCO 6 ============================== */
/* ==== CSS COMPONENTES (Botões, Formulários, Cards) ==== */

/* ============================================ */
/* ==========        BOTÕES        ========== */
/* ============================================ */

.btn {
  display: inline-flex; /* Alinha ícone e texto corretamente */
  align-items: center;
  justify-content: center;
  gap: var(--spacing-2); /* Espaço entre ícone e texto (8px) */
  padding: var(--spacing-2) var(--spacing-4); /* 8px vertical, 16px horizontal */
  font-family: inherit;
  font-size: var(--font-size-sm); /* 14px por padrão */
  font-weight: var(--font-weight-medium);
  text-align: center;
  white-space: nowrap; /* Previne quebra de linha */
  vertical-align: middle; /* Alinhamento vertical */
  cursor: pointer;
  border: none; /* Sem borda por padrão */
  border-radius: var(--border-radius-md);
  transition: var(--transition-fast); /* Transição rápida para interações */
  user-select: none; /* Previne seleção de texto */
  -webkit-user-select: none;
  touch-action: manipulation; /* Melhora resposta em touch */
}

.btn:focus-visible {
  outline: 2px solid color-mix(in srgb, var(--color-primary) 50%, transparent);
  outline-offset: 2px;
}

.btn:disabled,
.btn.disabled {
  opacity: 0.6;
  cursor: not-allowed;
  pointer-events: none; /* Desabilita eventos de clique */
}

/* ----- Variações de Botão ----- */

/* Botão Primário (Ação Principal) */
.btn-primary {
  background-color: var(--color-primary);
  color: var(--color-text-on-primary);
}
.btn-primary:hover {
  background-color: color-mix(in srgb, var(--color-primary) 85%, black 15%);
}
.btn-primary:active {
  background-color: color-mix(in srgb, var(--color-primary) 75%, black 25%);
  transform: scale(0.98); /* Efeito de pressionar sutil */
}

/* Botão Secundário (Ação Alternativa) */
.btn-secondary {
  background-color: var(--color-surface-hover); /* Fundo sutil */
  color: var(--color-text-primary);
  border: var(--border-width) solid var(--color-border); /* Borda para contraste */
}
.btn-secondary:hover {
  background-color: var(--color-border-light);
  border-color: var(--color-border);
}
.btn-secondary:active {
  background-color: var(--color-border);
  transform: scale(0.98);
}

/* Botão de Perigo */
.btn-danger {
  background-color: var(--color-danger);
  color: var(--color-text-on-danger);
}
.btn-danger:hover {
  background-color: color-mix(in srgb, var(--color-danger) 85%, black 15%);
}
.btn-danger:active {
  background-color: color-mix(in srgb, var(--color-danger) 75%, black 25%);
  transform: scale(0.98);
}

/* Botão de Sucesso */
.btn-success {
  background-color: var(--color-success);
  color: var(--color-text-on-primary); /* Assumindo texto branco */
}
.btn-success:hover {
  background-color: color-mix(in srgb, var(--color-success) 85%, black 15%);
}
.btn-success:active {
  background-color: color-mix(in srgb, var(--color-success) 75%, black 25%);
  transform: scale(0.98);
}

/* Botão de Texto/Link (Aparência de link, mas é um botão) */
.btn-link {
  background-color: transparent;
  color: var(--color-primary);
  padding: var(--spacing-2); /* Menor padding */
  text-decoration: none;
}
.btn-link:hover {
  color: color-mix(in srgb, var(--color-primary) 80%, var(--color-text-primary) 20%);
  text-decoration: underline;
}
.btn-link:active {
  transform: scale(0.98);
}

/* ----- Botão com Ícone ----- */
/* Estilo para botões que podem ou não ter texto */
.btn-with-icon i {
  font-size: 1.1em; /* Ícone ligeiramente maior que o texto */
  line-height: 0; /* Remove espaço extra da linha do ícone */
}
/* Caso o botão tenha SOMENTE ícone (e.g., botões de ação em tabelas) */
.btn-icon-only {
  padding: var(--spacing-2); /* Padding quadrado */
  width: 36px; /* Tamanho fixo */
  height: 36px;
  gap: 0; /* Sem espaço */
}
.btn-icon-only i {
  margin: 0; /* Remove margem do ícone */
  font-size: var(--font-size-lg); /* Tamanho do ícone */
}

/* ----- Tamanhos de Botão (Opcional) ----- */
.btn-sm {
  padding: var(--spacing-1) var(--spacing-3); /* 4px 12px */
  font-size: var(--font-size-xs); /* 12px */
  gap: var(--spacing-1);
}
.btn-lg {
  padding: var(--spacing-3) var(--spacing-5); /* 12px 20px */
  font-size: var(--font-size-md); /* 16px */
  gap: var(--spacing-2);
}


/* ============================================ */
/* ==========      FORMULÁRIOS     ========== */
/* ============================================ */

.form-group {
  margin-bottom: var(--spacing-4); /* 16px */
}

.form-row {
  display: flex;
  flex-wrap: wrap; /* Permite quebrar em telas menores */
  gap: var(--spacing-4); /* 16px */
  margin-bottom: var(--spacing-4);
}

.form-row > .form-group {
  flex: 1; /* Ocupa espaço igual por padrão */
  min-width: 150px; /* Largura mínima antes de quebrar */
  margin-bottom: 0; /* Remove margem inferior quando em linha */
}

.form-label {
  display: block;
  font-size: var(--font-size-sm); /* 14px */
  font-weight: var(--font-weight-medium);
  color: var(--color-text-secondary);
  margin-bottom: var(--spacing-2); /* 8px */
}

/* Estilo base para inputs, selects, textareas */
.form-input,
.form-select,
.form-textarea {
  display: block;
  width: 100%;
  padding: var(--spacing-3) var(--spacing-4); /* 12px 16px */
  font-size: var(--font-size-md); /* 16px */
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-normal);
  color: var(--color-text-primary);
  background-color: var(--color-surface);
  background-clip: padding-box;
  border: var(--border-width) solid var(--color-border);
  appearance: none; /* Remove aparência padrão */
  border-radius: var(--border-radius-md);
  transition: border-color var(--transition-duration-fast) ease-in-out,
              box-shadow var(--transition-duration-fast) ease-in-out;
}

.form-input::placeholder,
.form-textarea::placeholder {
  color: var(--color-text-placeholder);
  opacity: 1; /* Garantir visibilidade */
}

.form-input:focus,
.form-select:focus,
.form-textarea:focus {
  color: var(--color-text-primary);
  background-color: var(--color-surface);
  border-color: var(--color-border-focus);
  outline: 0;
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--color-primary) 15%, transparent); /* Glow sutil no foco */
}

/* Estilização específica para Select (seta) */
.form-select {
  padding-right: var(--spacing-10); /* Espaço maior para a seta */
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%236E6E73'%3E%3Cpath d='M8 11.5a.5.5 0 0 1-.354-.146l-4-4a.5.5 0 0 1 .708-.708L8 10.293l3.646-3.647a.5.5 0 0 1 .708.708l-4 4A.5.5 0 0 1 8 11.5z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right var(--spacing-4) center;
  background-size: 16px 16px;
}
[data-theme="dark"] .form-select {
   background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23EBEBF599'%3E%3Cpath d='M8 11.5a.5.5 0 0 1-.354-.146l-4-4a.5.5 0 0 1 .708-.708L8 10.293l3.646-3.647a.5.5 0 0 1 .708.708l-4 4A.5.5 0 0 1 8 11.5z'/%3E%3C/svg%3E");
}

.form-textarea {
  min-height: 120px;
  resize: vertical;
}

/* Input[type=color] (Manter simples por enquanto) */
.form-input-color {
  padding: var(--spacing-1); /* Padding mínimo */
  height: 44px; /* Altura consistente com outros inputs */
  cursor: pointer;
}

/* Checkbox e Radio (Estilização básica, customização avançada depois) */
.form-check {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-2);
}
.form-check-input {
  width: 1.25em; /* Tamanho do checkbox/radio */
  height: 1.25em;
  margin-right: var(--spacing-2);
  cursor: pointer;
  appearance: none; /* Remove aparência padrão para futura customização */
  border: var(--border-width) solid var(--color-border);
  background-color: var(--color-surface);
  vertical-align: middle; /* Alinha com o texto */
}
.form-check-input[type="checkbox"] {
  border-radius: var(--border-radius-sm);
}
.form-check-input[type="radio"] {
  border-radius: var(--border-radius-full);
}
.form-check-input:checked {
  background-color: var(--color-primary);
  border-color: var(--color-primary);
  /* Adicionar ícone de check/dot via background-image */
}
/* Ícone de check para Checkbox */
.form-check-input[type="checkbox"]:checked {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='white'%3e%3cpath d='M13.78 4.22a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06 0L2.22 9.78a.75.75 0 0 1 1.06-1.06L6 10.94l7.22-7.22a.75.75 0 0 1 1.06 0z'/%3e%3c/svg%3e");
    background-size: 70%;
    background-position: center;
    background-repeat: no-repeat;
}
/* Ícone de dot para Radio */
.form-check-input[type="radio"]:checked {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='white'/%3e%3c/svg%3e");
    background-size: 50%;
    background-position: center;
    background-repeat: no-repeat;
}
.form-check-input:focus {
  border-color: var(--color-border-focus);
  outline: 0;
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--color-primary) 15%, transparent);
}
.form-check-label {
  font-size: var(--font-size-md);
  color: var(--color-text-primary);
  cursor: pointer;
}

/* Ações do Formulário (geralmente no final de modais) */
.form-actions {
  display: flex;
  justify-content: flex-end; /* Alinha botões à direita */
  gap: var(--spacing-3); /* 12px */
  margin-top: var(--spacing-6); /* 24px */
  padding-top: var(--spacing-4); /* 16px */
  border-top: var(--border-width) solid var(--color-border-light); /* Linha separadora sutil */
}


/* ============================================ */
/* ==========         CARDS        ========== */
/* ============================================ */

.card {
  background-color: var(--color-surface);
  border-radius: var(--border-radius-lg);
  box-shadow: var(--shadow-md);
  margin-bottom: var(--spacing-6); /* 24px */
  overflow: hidden; /* Garante que o conteúdo não vaze com bordas arredondadas */
  transition: transform var(--transition-duration-fast) ease-in-out,
              box-shadow var(--transition-duration-fast) ease-in-out;
}

.card:hover {
  transform: translateY(-2px); /* Efeito sutil de elevação */
  box-shadow: var(--shadow-lg); /* Sombra um pouco mais pronunciada */
}

.card-header {
  padding: var(--spacing-4) var(--spacing-5); /* 16px 20px */
  border-bottom: var(--border-width) solid var(--color-border-light);
  display: flex;
  align-items: center;
  justify-content: space-between; /* Alinha título à esquerda, ações à direita */
}

.card-header h3,
.card-header h4 {
  margin-bottom: 0; /* Remove margem do título dentro do header */
  font-size: var(--font-size-lg); /* 18px */
}

.card-body {
  padding: var(--spacing-5); /* 20px */
}

.card-footer {
  padding: var(--spacing-3) var(--spacing-5); /* 12px 20px */
  border-top: var(--border-width) solid var(--color-border-light);
  background-color: var(--color-surface-variant); /* Fundo ligeiramente diferente */
  display: flex;
  align-items: center;
  justify-content: flex-end; /* Alinha conteúdo (botões, etc.) à direita */
  gap: var(--spacing-3);
}

/* ===== FIM: BLOCO 6 ================================ */

/* ===== INÍCIO: BLOCO 7 ============================== */
/* ==== CSS COMPONENTES ESPECÍFICOS (Modais, Toasts, Tabelas, etc.) ==== */

/* ============================================ */
/* ==========        MODAIS        ========== */
/* ============================================ */

/* Container para Modais (fora do fluxo principal) */
#modal-container {
    position: fixed;
    inset: 0;
    z-index: var(--z-index-modal-backdrop); /* Fica atrás dos modais */
    pointer-events: none; /* Não interfere com cliques por padrão */
}

/* Fundo do Modal (Overlay) */
.modal-backdrop {
    position: absolute;
    inset: 0;
    background-color: rgba(0, 0, 0, 0.5); /* Fundo escuro semi-transparente */
    backdrop-filter: blur(5px); /* Efeito de desfoque (moderno) */
    -webkit-backdrop-filter: blur(5px);
    opacity: 0;
    transition: opacity var(--transition-duration-normal) ease-in-out;
    z-index: 1; /* Dentro do container, mas abaixo do modal */
}

/* Modal Principal */
.modal {
    position: absolute; /* Posicionado dentro do #modal-container */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.95); /* Começa ligeiramente menor */
    width: 90%;
    max-width: 600px; /* Largura máxima padrão */
    max-height: 90vh; /* Altura máxima */
    background-color: var(--color-surface);
    border-radius: var(--border-radius-xl); /* Bordas mais arredondadas */
    box-shadow: var(--shadow-xl);
    display: flex; /* Usa flexbox para estrutura interna */
    flex-direction: column;
    overflow: hidden; /* Esconde conteúdo que vaza */
    opacity: 0;
    visibility: hidden;
    transition: opacity var(--transition-duration-fast) ease-in-out,
                transform var(--transition-duration-fast) ease-in-out,
                visibility var(--transition-duration-fast) ease-in-out;
    z-index: 2; /* Acima do backdrop */
    pointer-events: none; /* Não clicável quando escondido */
}

/* Variação de Tamanho (Opcional) */
.modal.modal-lg { max-width: 800px; }
.modal.modal-sm { max-width: 450px; }

/* Estado Ativo (Visível) */
#modal-container.active {
    pointer-events: auto; /* Container se torna clicável (para fechar) */
}
#modal-container.active .modal-backdrop {
    opacity: 1;
}
#modal-container.active .modal {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1); /* Anima para tamanho normal */
    pointer-events: auto; /* Modal se torna interativo */
}

/* Estrutura Interna do Modal */
.modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--spacing-4) var(--spacing-5); /* 16px 20px */
    border-bottom: var(--border-width) solid var(--color-border-light);
    flex-shrink: 0; /* Não encolher */
}

.modal-title {
    font-size: var(--font-size-lg); /* 18px */
    font-weight: var(--font-weight-semibold);
    margin: 0;
}

.modal-close-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    border-radius: var(--border-radius-full);
    background-color: var(--color-surface-hover);
    color: var(--color-text-tertiary);
    border: none;
    cursor: pointer;
    transition: background-color var(--transition-duration-fast) ease-in-out,
                color var(--transition-duration-fast) ease-in-out;
}
.modal-close-btn:hover {
    background-color: var(--color-border-light);
    color: var(--color-danger);
}
.modal-close-btn i {
    font-size: var(--font-size-md); /* 16px */
}

.modal-body {
    padding: var(--spacing-5); /* 20px */
    overflow-y: auto; /* Scroll se o conteúdo for maior */
    flex-grow: 1; /* Ocupa o espaço restante */
}

.modal-footer {
    padding: var(--spacing-4) var(--spacing-5); /* 16px 20px */
    border-top: var(--border-width) solid var(--color-border-light);
    background-color: var(--color-surface-variant);
    display: flex;
    justify-content: flex-end; /* Botões à direita por padrão */
    gap: var(--spacing-3); /* 12px */
    flex-shrink: 0; /* Não encolher */
}


/* ============================================ */
/* ===== TOASTS (Notificações Rápidas) ===== */
/* ============================================ */

.toast-container {
    position: fixed;
    bottom: var(--spacing-5); /* 20px */
    right: var(--spacing-5); /* 20px */
    z-index: var(--z-index-toast);
    display: flex;
    flex-direction: column;
    align-items: flex-end; /* Alinha toasts à direita */
    gap: var(--spacing-3); /* 12px entre toasts */
    pointer-events: none; /* Container não intercepta cliques */
}

.toast {
    min-width: 280px;
    max-width: 350px;
    background-color: var(--color-surface);
    color: var(--color-text-primary);
    border-radius: var(--border-radius-lg);
    box-shadow: var(--shadow-lg);
    display: flex;
    align-items: flex-start; /* Alinha ícone e texto no topo */
    padding: var(--spacing-3) var(--spacing-4); /* 12px 16px */
    overflow: hidden;
    position: relative; /* Para a barra de progresso */
    opacity: 0;
    transform: translateX(100%); /* Começa fora da tela */
    transition: opacity var(--transition-duration-normal) ease-in-out,
                transform var(--transition-duration-normal) ease-in-out;
    pointer-events: auto; /* Toast individual é clicável */
    border-left: 4px solid transparent; /* Borda colorida semântica */
}

.toast.show {
    opacity: 1;
    transform: translateX(0); /* Entra na tela */
}

.toast-icon {
    font-size: var(--font-size-xl); /* 20px */
    margin-right: var(--spacing-3); /* 12px */
    margin-top: 2px; /* Ajuste fino vertical */
    flex-shrink: 0;
}

.toast-content {
    flex-grow: 1;
}

.toast-title {
    font-weight: var(--font-weight-semibold);
    margin-bottom: var(--spacing-1); /* 4px */
    font-size: var(--font-size-sm); /* 14px */
}

.toast-message {
    font-size: var(--font-size-sm); /* 14px */
    color: var(--color-text-secondary);
    line-height: var(--line-height-tight);
}

.toast-close-btn {
    background: transparent;
    border: none;
    color: var(--color-text-tertiary);
    font-size: var(--font-size-lg); /* 18px */
    padding: 0;
    margin-left: var(--spacing-3); /* 12px */
    cursor: pointer;
    opacity: 0.7;
    transition: opacity var(--transition-duration-fast) ease-in-out;
}
.toast-close-btn:hover {
    opacity: 1;
    color: var(--color-text-primary);
}

/* Barra de Progresso (Opcional) */
.toast-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 3px;
    background-color: var(--color-primary); /* Cor padrão */
    width: 100%;
    transform-origin: left;
    animation: toast-progress-bar 5s linear forwards; /* Duração padrão 5s */
}

@keyframes toast-progress-bar {
    from { transform: scaleX(1); }
    to { transform: scaleX(0); }
}

/* Variações Semânticas de Toast */
.toast.toast-success { border-left-color: var(--color-success); }
.toast.toast-success .toast-icon { color: var(--color-success); }
.toast.toast-success .toast-progress { background-color: var(--color-success); }

.toast.toast-danger { border-left-color: var(--color-danger); }
.toast.toast-danger .toast-icon { color: var(--color-danger); }
.toast.toast-danger .toast-progress { background-color: var(--color-danger); }

.toast.toast-warning { border-left-color: var(--color-warning); }
.toast.toast-warning .toast-icon { color: var(--color-warning); }
.toast.toast-warning .toast-progress { background-color: var(--color-warning); }

.toast.toast-info { border-left-color: var(--color-info); }
.toast.toast-info .toast-icon { color: var(--color-info); }
.toast.toast-info .toast-progress { background-color: var(--color-info); }


/* ============================================ */
/* ==========       TABELAS        ========== */
/* ============================================ */

.table-container {
  width: 100%;
  overflow-x: auto; /* Scroll horizontal se necessário */
  border: var(--border-width) solid var(--color-border-light);
  border-radius: var(--border-radius-lg);
  background-color: var(--color-surface);
  margin-bottom: var(--spacing-6); /* 24px */
  box-shadow: var(--shadow-sm); /* Sombra bem sutil */
}

.table {
  width: 100%;
  min-width: 600px; /* Largura mínima antes do scroll aparecer */
  border-collapse: collapse; /* Remove espaços entre células */
  font-size: var(--font-size-sm); /* 14px */
}

.table th,
.table td {
  padding: var(--spacing-3) var(--spacing-4); /* 12px 16px */
  text-align: left;
  vertical-align: middle; /* Alinha conteúdo verticalmente */
  border-bottom: var(--border-width) solid var(--color-border-light);
  white-space: nowrap; /* Evita quebra de linha por padrão */
}

/* Permitir quebra de linha em colunas específicas se necessário */
.table th.wrap,
.table td.wrap {
  white-space: normal;
}

.table thead th {
  background-color: var(--color-surface-variant);
  color: var(--color-text-secondary);
  font-weight: var(--font-weight-medium);
  position: sticky; /* Cabeçalho fixo no scroll vertical */
  top: 0;
  z-index: var(--z-index-base);
  border-bottom-width: var(--border-width-lg); /* Linha mais grossa abaixo do header */
  border-bottom-color: var(--color-border);
}

.table tbody tr {
  transition: background-color var(--transition-duration-fast) ease-in-out;
}

.table tbody tr:hover {
  background-color: var(--color-surface-hover);
}

.table tbody tr:last-child td {
  border-bottom: none; /* Remove borda da última linha */
}

.table .action-cell {
  text-align: right; /* Alinha ações à direita */
  white-space: nowrap;
}

.table .action-buttons {
  display: inline-flex; /* Garante alinhamento */
  gap: var(--spacing-1); /* 4px */
}

/* Mensagem para tabela vazia */
.table-empty-row td {
    text-align: center;
    color: var(--color-text-tertiary);
    padding: var(--spacing-8) var(--spacing-4); /* Espaçamento maior */
    font-style: italic;
    border-bottom: none;
}

/* Estilos financeiros na tabela */
.table .currency { text-align: right; font-variant-numeric: tabular-nums; } /* Alinha números */
.table .positive-value { color: var(--color-finance-positive); font-weight: var(--font-weight-medium); }
.table .negative-value { color: var(--color-finance-negative); font-weight: var(--font-weight-medium); }
.table .neutral-value { color: var(--color-finance-neutral); }


/* ============================================ */
/* ==========       GRÁFICOS       ========== */
/* ============================================ */

.chart-container {
  background-color: var(--color-surface);
  border-radius: var(--border-radius-lg);
  padding: var(--spacing-5); /* 20px */
  box-shadow: var(--shadow-md);
  margin-bottom: var(--spacing-6); /* 24px */
  position: relative; /* Para tooltip e overlays */
  min-height: 300px; /* Altura mínima */
}

.chart-title {
    font-size: var(--font-size-md);
    font-weight: var(--font-weight-medium);
    color: var(--color-text-secondary);
    margin-bottom: var(--spacing-4);
    text-align: center;
}

.chart-canvas {
    max-width: 100%;
    max-height: 400px; /* Limitar altura máxima do canvas */
}

/* Mensagem para gráfico vazio */
.chart-empty-message {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--color-text-tertiary);
    font-style: italic;
    padding: var(--spacing-4);
    text-align: center;
}


/* ============================================ */
/* ==========  AVATARES (Simples)  ========== */
/* ============================================ */
/* Estilo básico para avatares, pode ser expandido */

.avatar {
  display: inline-flex; /* Comportamento inline-block */
  align-items: center;
  justify-content: center;
  border-radius: var(--border-radius-full);
  overflow: hidden; /* Para imagens */
  background-color: var(--color-border-light); /* Cor de fundo padrão */
  color: var(--color-text-secondary); /* Cor para ícones ou iniciais */
  font-weight: var(--font-weight-medium);
  user-select: none;
}

.avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover; /* Garante que a imagem cubra o avatar */
}

/* Tamanhos (Exemplos) */
.avatar-sm { width: 24px; height: 24px; font-size: var(--font-size-xs); }
.avatar-md { width: 36px; height: 36px; font-size: var(--font-size-sm); } /* Padrão */
.avatar-lg { width: 48px; height: 48px; font-size: var(--font-size-md); }
.avatar-xl { width: 64px; height: 64px; font-size: var(--font-size-lg); }

/* Estilo para avatares com iniciais (Se não houver imagem) */
.avatar-initials::before {
    content: attr(data-initials); /* Pega as iniciais do atributo data-initials */
    display: block;
}

/* Cores de Fundo de Avatar (Exemplo - pode ser dinâmico) */
/* Você pode criar classes como .avatar-bg-blue, .avatar-bg-green etc. */
.avatar-bg-1 { background-color: #0A84FF; color: white; }
.avatar-bg-2 { background-color: #30D158; color: white; }
.avatar-bg-3 { background-color: #FF453A; color: white; }
.avatar-bg-4 { background-color: #FF9F0A; color: white; }
.avatar-bg-5 { background-color: #5E5CE6; color: white; }
.avatar-bg-6 { background-color: #BF5AF2; color: white; }
.avatar-bg-7 { background-color: #64D2FF; color: white; }
.avatar-bg-8 { background-color: #FF375F; color: white; }


/* ============================================ */
/* ==========      BADGES/TAGS     ========== */
/* ============================================ */

.badge {
    display: inline-flex;
    align-items: center;
    padding: var(--spacing-1) var(--spacing-2); /* 4px 8px */
    font-size: var(--font-size-xs); /* 12px */
    font-weight: var(--font-weight-medium);
    border-radius: var(--border-radius-sm);
    white-space: nowrap;
    line-height: 1; /* Evita altura extra */
}

/* Variações de cor (Exemplo) */
.badge-primary { background-color: color-mix(in srgb, var(--color-primary) 15%, transparent); color: var(--color-primary); }
.badge-success { background-color: color-mix(in srgb, var(--color-success) 15%, transparent); color: var(--color-success); }
.badge-danger { background-color: color-mix(in srgb, var(--color-danger) 15%, transparent); color: var(--color-danger); }
.badge-warning { background-color: color-mix(in srgb, var(--color-warning) 15%, transparent); color: var(--color-warning); }
.badge-info { background-color: color-mix(in srgb, var(--color-info) 15%, transparent); color: var(--color-info); }
.badge-neutral { background-color: var(--color-surface-hover); color: var(--color-text-secondary); }

/* ===== FIM: BLOCO 7 ================================ */

<!-- ===== INÍCIO: BLOCO 8 ============================== -->
<!-- ==== ESTRUTURA HTML - MÓDULO DASHBOARD ==== -->
<!-- Este conteúdo será inserido dinamicamente na div #content-area -->

<div class="dashboard-module">

    <!-- Seção de Alertas Importantes (Opcional) -->
    <section class="dashboard-section alerts-section" id="dashboard-alerts" aria-label="Alertas importantes">
        <!-- Alertas serão inseridos aqui via JS, se houver -->
        <!-- Exemplo:
        <div class="alert alert-warning">
            <i class="fas fa-exclamation-triangle alert-icon" aria-hidden="true"></i>
            <span class="alert-message">Fatura do Cartão XPTO vence em 3 dias.</span>
        </div>
        <div class="alert alert-danger">
            <i class="fas fa-exclamation-circle alert-icon" aria-hidden="true"></i>
            <span class="alert-message">Risco de saldo negativo detectado para o próximo mês.</span>
        </div>
        -->
    </section>

    <!-- Seção de KPIs Principais -->
    <section class="dashboard-section kpi-section" aria-labelledby="kpi-section-title">
        <h3 class="section-title" id="kpi-section-title">Resumo Financeiro Atual</h3>
        <div class="kpi-grid" id="kpi-grid-main">
            <!-- Cards de KPI serão inseridos aqui via JS -->
            <!-- Exemplo de Card KPI (será gerado dinamicamente):
            <div class="kpi-card">
                <div class="kpi-header">
                    <span class="kpi-title">Saldo Atual</span>
                    <i class="fas fa-wallet kpi-icon"></i>
                </div>
                <div class="kpi-value positive-value">R$ 1.234,56</div>
                <div class="kpi-footer">
                    <span class="kpi-trend positive-value"><i class="fas fa-arrow-up"></i> 5.2%</span>
                    <span class="kpi-period">últimos 30 dias</span>
                </div>
            </div>
             -->
             <!-- Placeholder para indicar carregamento -->
             <div class="kpi-card placeholder"></div>
             <div class="kpi-card placeholder"></div>
             <div class="kpi-card placeholder"></div>
             <div class="kpi-card placeholder"></div>
        </div>
    </section>

    <!-- Seção de Gráficos -->
    <section class="dashboard-section charts-section" aria-labelledby="charts-section-title">
        <h3 class="section-title" id="charts-section-title">Análise Visual</h3>
        <div class="charts-grid" id="charts-grid-main">
            <!-- Gráfico 1: Despesas por Categoria -->
            <div class="chart-container" id="category-expense-chart-container">
                <h4 class="chart-title">Despesas por Categoria (Mês Atual)</h4>
                <canvas id="category-expense-chart" class="chart-canvas" role="img" aria-label="Gráfico de pizza mostrando distribuição de despesas por categoria"></canvas>
                <div class="chart-empty-message" style="display: none;">Sem dados de despesas para exibir.</div>
            </div>

            <!-- Gráfico 2: Receitas vs Despesas -->
            <div class="chart-container" id="income-expense-chart-container">
                <h4 class="chart-title">Receitas vs. Despesas (Últimos 6 Meses)</h4>
                <canvas id="income-expense-chart" class="chart-canvas" role="img" aria-label="Gráfico de barras comparando receitas e despesas mensais"></canvas>
                 <div class="chart-empty-message" style="display: none;">Sem dados suficientes para exibir o gráfico.</div>
            </div>

            <!-- Outros gráficos podem ser adicionados aqui -->

        </div>
    </section>

    <!-- Seção de Transações Recentes -->
    <section class="dashboard-section transactions-section" aria-labelledby="transactions-section-title">
        <h3 class="section-title" id="transactions-section-title">Transações Recentes</h3>
        <div class="table-container" id="recent-transactions-table-container">
            <!-- Tabela de transações será inserida aqui via JS -->
            <div class="table-loading-placeholder">
                <p>Carregando transações...</p> <!-- Mensagem enquanto a tabela carrega -->
            </div>
             <!-- Exemplo de Tabela (será gerada dinamicamente):
            <table class="table" id="recent-transactions-table">
                <thead>
                    <tr>
                        <th>Data</th>
                        <th>Descrição</th>
                        <th>Categoria</th>
                        <th class="currency">Valor</th>
                        <th>Ações</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>dd/mm/aaaa</td>
                        <td>Compra no Supermercado</td>
                        <td><span class="badge badge-neutral">Alimentação</span></td>
                        <td class="currency negative-value">R$ 150,00</td>
                        <td class="action-cell">
                           <div class="action-buttons">
                               <button class="btn btn-icon-only btn-link btn-sm" title="Editar"><i class="fas fa-edit"></i></button>
                               <button class="btn btn-icon-only btn-link btn-sm btn-danger" title="Excluir"><i class="fas fa-trash-alt"></i></button>
                           </div>
                        </td>
                    </tr>
                </tbody>
            </table>
            <div class="table-empty-row" style="display: none;">
                <td colspan="5">Nenhuma transação recente encontrada.</td>
            </div>
             -->
        </div>
         <div class="section-footer">
             <button class="btn btn-secondary btn-sm" id="view-all-transactions-btn">Ver Todas as Transações</button>
         </div>
    </section>

</div> <!-- Fim .dashboard-module -->
<!-- ===== FIM: BLOCO 8 ================================ -->

/* ===== INÍCIO: BLOCO 9 ============================== */
/* ==== CSS MÓDULO DASHBOARD ==== */

/* Container principal do módulo */
.dashboard-module {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-8); /* Espaço maior entre seções principais (32px) */
}

/* Estilo geral para títulos de seção */
.section-title {
    font-size: var(--font-size-lg); /* 18px */
    font-weight: var(--font-weight-semibold);
    color: var(--color-text-secondary);
    margin-bottom: var(--spacing-4); /* 16px */
    padding-bottom: var(--spacing-2); /* 8px */
    border-bottom: var(--border-width) solid var(--color-border-light);
}

/* ----- Seção de Alertas ----- */
.alerts-section {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-3); /* 12px entre alertas */
}

.alert {
    display: flex;
    align-items: flex-start; /* Alinha ícone com a primeira linha de texto */
    padding: var(--spacing-3) var(--spacing-4); /* 12px 16px */
    border-radius: var(--border-radius-md);
    font-size: var(--font-size-sm); /* 14px */
    border-left-width: 4px;
    border-left-style: solid;
}

.alert-icon {
    margin-right: var(--spacing-3); /* 12px */
    font-size: var(--font-size-lg); /* 18px */
    line-height: 1.4; /* Ajuste para alinhar melhor com o texto */
    flex-shrink: 0;
}

/* Variações semânticas de Alerta (herdando cores de :root) */
.alert-success { background-color: color-mix(in srgb, var(--color-success) 10%, transparent); border-left-color: var(--color-success); color: var(--color-success); }
.alert-danger  { background-color: color-mix(in srgb, var(--color-danger) 10%, transparent);  border-left-color: var(--color-danger);  color: var(--color-danger); }
.alert-warning { background-color: color-mix(in srgb, var(--color-warning) 10%, transparent); border-left-color: var(--color-warning); color: var(--color-warning); }
.alert-info    { background-color: color-mix(in srgb, var(--color-info) 10%, transparent);    border-left-color: var(--color-info);    color: var(--color-info); }

/* No tema escuro, usar cor de texto mais clara para contraste */
[data-theme="dark"] .alert-success { color: color-mix(in srgb, var(--color-success) 80%, white 20%); }
[data-theme="dark"] .alert-danger  { color: color-mix(in srgb, var(--color-danger) 80%, white 20%); }
[data-theme="dark"] .alert-warning { color: color-mix(in srgb, var(--color-warning) 80%, white 20%); }
[data-theme="dark"] .alert-info    { color: color-mix(in srgb, var(--color-info) 80%, white 20%); }

/* ----- Seção de KPIs ----- */
.kpi-grid {
    display: grid;
    /* Cria colunas responsivas: tenta encaixar o máximo de colunas com 250px,
       mas cada coluna pode crescer para preencher o espaço (1fr) */
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: var(--spacing-5); /* 20px */
}

.kpi-card {
    background-color: var(--color-surface);
    border-radius: var(--border-radius-lg);
    padding: var(--spacing-4); /* 16px */
    box-shadow: var(--shadow-md);
    display: flex;
    flex-direction: column;
    transition: var(--transition-base); /* Usa transição base */
    position: relative; /* Para elementos internos posicionados */
    min-height: 130px; /* Altura mínima para consistência */
}
.kpi-card:hover {
    transform: translateY(-3px);
    box-shadow: var(--shadow-lg);
}

.kpi-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start; /* Ícone no topo */
    margin-bottom: var(--spacing-2); /* 8px */
}

.kpi-title {
    font-size: var(--font-size-sm); /* 14px */
    color: var(--color-text-secondary);
    font-weight: var(--font-weight-medium);
}

.kpi-icon {
    font-size: var(--font-size-lg); /* 18px */
    color: var(--color-text-tertiary);
    opacity: 0.7;
}

.kpi-value {
    font-size: var(--font-size-2xl); /* 24px */
    font-weight: var(--font-weight-bold);
    color: var(--color-text-primary);
    margin-bottom: auto; /* Empurra o footer para baixo */
    padding-bottom: var(--spacing-2); /* Espaço antes do footer */
    line-height: 1.2;
}

.kpi-value.positive-value { color: var(--color-finance-positive); }
.kpi-value.negative-value { color: var(--color-finance-negative); }

.kpi-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: var(--font-size-xs); /* 12px */
    color: var(--color-text-tertiary);
    margin-top: var(--spacing-2); /* 8px */
}

.kpi-trend {
    display: inline-flex;
    align-items: center;
    gap: var(--spacing-1); /* 4px */
    font-weight: var(--font-weight-medium);
}
.kpi-trend.positive-value { color: var(--color-finance-positive); }
.kpi-trend.negative-value { color: var(--color-finance-negative); }

/* Placeholder para loading de KPI */
.kpi-card.placeholder {
    background-color: var(--color-surface-hover);
    box-shadow: none;
    min-height: 130px; /* Mesma altura mínima */
    animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: .5; }
}


/* ----- Seção de Gráficos ----- */
.charts-grid {
    display: grid;
    /* Duas colunas por padrão, quebrando para uma em telas menores */
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: var(--spacing-6); /* 24px */
}

/* ----- Seção de Transações Recentes ----- */
.table-loading-placeholder {
    text-align: center;
    padding: var(--spacing-8);
    color: var(--color-text-tertiary);
    font-style: italic;
}

.section-footer {
    margin-top: var(--spacing-4); /* Espaço acima do botão */
    text-align: center; /* Centraliza o botão */
}

/* Ajuste fino para botões de ação em tabelas no dashboard */
.dashboard-module .table .action-buttons .btn-sm {
    width: 30px; /* Deixar um pouco menor */
    height: 30px;
}
.dashboard-module .table .action-buttons .btn-sm i {
    font-size: var(--font-size-sm); /* Ícone menor */
}

/* ===== FIM: BLOCO 9 ================================ */

<!-- ===== INÍCIO: BLOCO 10 ============================== -->
<!-- ==== ESTRUTURA HTML - MÓDULO ANÁLISE MENSAL ==== -->
<!-- Este conteúdo será inserido dinamicamente na div #content-area -->

<div class="monthly-analysis-module">

    <!-- Seção de Filtros Avançados -->
    <section class="filters-section card" aria-labelledby="filters-section-title">
        <div class="card-header">
            <h3 class="section-title no-border" id="filters-section-title">Filtros Avançados</h3>
             <button class="btn btn-sm btn-link" id="reset-filters-btn">Limpar Filtros</button>
        </div>
        <div class="card-body">
            <form class="filters-form" id="monthly-analysis-filters-form">
                <div class="form-row">
                    <!-- Filtro por Categoria -->
                    <div class="form-group filter-group">
                        <label for="ma-category-filter" class="form-label">Categoria</label>
                        <select id="ma-category-filter" class="form-select filter-select">
                            <option value="all">Todas as Categorias</option>
                            <!-- Opções preenchidas via JS -->
                        </select>
                    </div>

                    <!-- Filtro por Forma de Pagamento -->
                    <div class="form-group filter-group">
                        <label for="ma-payment-filter" class="form-label">Forma de Pagamento</label>
                        <select id="ma-payment-filter" class="form-select filter-select">
                           <option value="all">Todas as Formas</option>
                           <option value="cash">Dinheiro</option>
                           <option value="debit">Débito</option>
                           <option value="credit">Cartão de Crédito</option>
                           <option value="pix">PIX</option>
                           <option value="transfer">Transferência</option>
                        </select>
                    </div>
                </div>
                 <div class="form-row">
                    <!-- Filtro por Tipo (Receita/Despesa) -->
                    <div class="form-group filter-group">
                        <label for="ma-type-filter" class="form-label">Tipo</label>
                        <select id="ma-type-filter" class="form-select filter-select">
                            <option value="all">Todos os Tipos</option>
                            <option value="income">Receita</option>
                            <option value="expense">Despesa</option>
                        </select>
                    </div>

                     <!-- Opções de Ordenação -->
                    <div class="form-group filter-group">
                        <label for="ma-sort-filter" class="form-label">Ordenar Por</label>
                        <select id="ma-sort-filter" class="form-select filter-select">
                            <option value="date-desc">Data (Mais Recente)</option>
                            <option value="date-asc">Data (Mais Antiga)</option>
                            <option value="amount-desc">Valor (Maior)</option>
                            <option value="amount-asc">Valor (Menor)</option>
                            <option value="description-asc">Descrição (A-Z)</option>
                        </select>
                    </div>
                </div>
                 <!-- Botão Aplicar não é estritamente necessário se a atualização for automática no change,
                      mas pode ser útil para performance com muitos dados. Adicionado por enquanto. -->
                 <div class="form-actions no-border">
                      <button type="button" class="btn btn-primary" id="apply-ma-filters-btn">Aplicar Filtros</button>
                 </div>
            </form>
        </div>
    </section>

    <!-- Seção de Resumo do Mês -->
    <section class="summary-section" aria-labelledby="summary-section-title">
        <h3 class="section-title" id="summary-section-title">Resumo do Mês Selecionado</h3>
        <div class="summary-grid" id="monthly-summary-grid">
            <!-- Cards de Resumo (Receita, Despesa, Saldo) serão inseridos aqui via JS -->
            <!-- Exemplo de Card de Resumo:
            <div class="summary-card summary-income">
                <div class="summary-icon"><i class="fas fa-arrow-up"></i></div>
                <div class="summary-content">
                    <span class="summary-title">Receitas</span>
                    <span class="summary-value positive-value">R$ 3.500,00</span>
                </div>
            </div>
            -->
            <!-- Placeholders -->
            <div class="summary-card placeholder"></div>
            <div class="summary-card placeholder"></div>
            <div class="summary-card placeholder"></div>
        </div>
    </section>

    <!-- Seção da Tabela de Transações -->
    <section class="transactions-section" aria-labelledby="ma-transactions-section-title">
         <h3 class="section-title" id="ma-transactions-section-title">Detalhes das Transações</h3>
        <div class="table-container" id="monthly-transactions-table-container">
             <!-- Tabela de transações detalhadas será inserida aqui via JS -->
             <div class="table-loading-placeholder active"> <!-- Começa visível -->
                <p>Carregando transações do mês...</p>
            </div>
            <!-- Exemplo de Tabela (será gerada dinamicamente):
            <table class="table" id="monthly-transactions-table">
                <thead>
                    <tr>
                        <th>Data</th>
                        <th>Descrição</th>
                        <th>Categoria</th>
                        <th>Pessoa</th>
                        <th>Pagamento</th>
                        <th class="currency">Valor</th>
                        <th>Ações</th>
                    </tr>
                </thead>
                <tbody> -->
                    <!-- Linhas preenchidas via JS -->
                <!-- </tbody>
                 <tfoot> -->
                    <!-- Linha de Totais (Opcional) -->
                 <!-- </tfoot>
            </table>
             <div class="table-empty-row" style="display: none;">
                <td colspan="7">Nenhuma transação encontrada para os filtros selecionados.</td>
            </div>
            -->
        </div>
    </section>

</div> <!-- Fim .monthly-analysis-module -->
<!-- ===== FIM: BLOCO 10 ============================== -->

/* ===== INÍCIO: BLOCO 11 ============================== */
/* ==== CSS MÓDULO ANÁLISE MENSAL ==== */

.monthly-analysis-module {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-8); /* 32px entre seções principais */
}

/* ----- Seção de Filtros Avançados ----- */
.filters-section.card {
    margin-bottom: 0; /* Remover margem padrão do card quando usado aqui */
}

.filters-section .card-header {
    padding-bottom: var(--spacing-3); /* Menor padding inferior no header */
}

/* Título da seção de filtros sem a borda inferior padrão */
.section-title.no-border {
    border-bottom: none;
    padding-bottom: 0;
    margin-bottom: 0; /* Remover margem se não tiver borda */
}

.filters-section .filters-form {
    display: flex;
    flex-direction: column; /* Filtros um abaixo do outro */
    gap: var(--spacing-4); /* 16px entre linhas de filtros */
}

/* Linha de ações do formulário sem borda superior e margem */
.filters-section .form-actions.no-border {
    border-top: none;
    padding-top: 0;
    margin-top: var(--spacing-2); /* Pequeno espaço acima do botão */
    justify-content: flex-end;
}


/* ----- Seção de Resumo do Mês ----- */
.summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: var(--spacing-5); /* 20px */
}

.summary-card {
    background-color: var(--color-surface);
    border-radius: var(--border-radius-lg);
    padding: var(--spacing-4); /* 16px */
    box-shadow: var(--shadow-md);
    display: flex;
    align-items: center;
    gap: var(--spacing-4); /* 16px entre ícone e conteúdo */
    min-height: 90px; /* Altura mínima */
    position: relative;
    overflow: hidden; /* Para placeholders */
}

.summary-card.placeholder {
    background-color: var(--color-surface-hover);
    box-shadow: none;
    min-height: 90px;
    animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.summary-icon {
    width: 40px;
    height: 40px;
    border-radius: var(--border-radius-full);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    color: white; /* Ícone branco */
}

.summary-card.summary-income .summary-icon { background-color: var(--color-success); }
.summary-card.summary-expense .summary-icon { background-color: var(--color-danger); }
.summary-card.summary-balance .summary-icon { background-color: var(--color-primary); }
.summary-card.summary-balance.negative .summary-icon { background-color: var(--color-danger); } /* Cor do ícone de saldo se negativo */

.summary-content {
    display: flex;
    flex-direction: column;
}

.summary-title {
    font-size: var(--font-size-sm); /* 14px */
    color: var(--color-text-secondary);
    margin-bottom: var(--spacing-1); /* 4px */
}

.summary-value {
    font-size: var(--font-size-xl); /* 20px */
    font-weight: var(--font-weight-bold);
    color: var(--color-text-primary);
    line-height: 1.2;
}

.summary-value.positive-value { color: var(--color-finance-positive); }
.summary-value.negative-value { color: var(--color-finance-negative); }

/* ----- Seção da Tabela de Transações ----- */
.monthly-analysis-module .table-container {
    margin-bottom: 0; /* Remover margem inferior no contexto deste módulo */
}

/* Ajuste fino para coluna de categoria com badge */
.monthly-analysis-module .table td .badge {
    font-size: 0.9em; /* Badge um pouco menor dentro da tabela */
    padding: 2px 6px;
}

/* Linha de totais no rodapé da tabela (se implementada) */
.monthly-analysis-module .table tfoot tr {
    background-color: var(--color-surface-variant);
    font-weight: var(--font-weight-semibold);
}

.monthly-analysis-module .table tfoot td {
    border-top: var(--border-width-lg) solid var(--color-border); /* Linha mais grossa acima dos totais */
    border-bottom: none;
}

/* ===== FIM: BLOCO 11 ============================== */

<!-- ===== INÍCIO: BLOCO 12 ============================== -->
<!-- ==== ESTRUTURA HTML - MÓDULO PROJEÇÃO DE CAIXA ==== -->
<!-- Este conteúdo será inserido dinamicamente na div #content-area -->

<div class="cash-projection-module">

    <!-- Seção de Controles e Filtros -->
    <section class="projection-controls card" aria-labelledby="projection-controls-title">
        <div class="card-header">
            <h3 class="section-title no-border" id="projection-controls-title">Configurar Projeção</h3>
            <!-- Poderia ter um botão para 'Atualizar Projeção' se a lógica não for automática -->
        </div>
        <div class="card-body">
            <form class="filters-form" id="projection-filters-form">
                 <div class="form-row">
                    <!-- Filtro de Período -->
                    <div class="form-group filter-group">
                        <label for="projection-period-filter" class="form-label">Período da Projeção</label>
                        <select id="projection-period-filter" class="form-select filter-select">
                            <option value="3">Próximos 3 Meses</option>
                            <option value="6" selected>Próximos 6 Meses</option>
                            <option value="12">Próximos 12 Meses</option>
                            <option value="custom">Período Personalizado</option>
                        </select>
                    </div>
                    <!-- Filtro de Data Inicial/Final (para período personalizado) -->
                    <div class="form-group filter-group date-range-filter" id="custom-date-range-container" style="display: none;">
                         <div class="date-inputs">
                             <div class="date-input-group">
                                 <label for="projection-start-date" class="form-label">Data Inicial</label>
                                 <input type="date" id="projection-start-date" class="form-input">
                             </div>
                            <div class="date-input-group">
                                 <label for="projection-end-date" class="form-label">Data Final</label>
                                 <input type="date" id="projection-end-date" class="form-input">
                            </div>
                        </div>
                    </div>
                 </div>
                 <div class="form-row">
                    <!-- Checkbox para incluir/excluir tipos de transação (opcional) -->
                     <div class="form-group filter-group">
                        <label class="form-label">Incluir na Projeção</label>
                        <div class="checkbox-group">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" value="recurring" id="include-recurring" checked>
                                <label class="form-check-label" for="include-recurring">
                                    Transações Recorrentes
                                </label>
                            </div>
                             <div class="form-check">
                                <input class="form-check-input" type="checkbox" value="installments" id="include-installments" checked>
                                <label class="form-check-label" for="include-installments">
                                    Parcelamentos Futuros
                                </label>
                            </div>
                             <div class="form-check">
                                <input class="form-check-input" type="checkbox" value="goals" id="include-goals">
                                <label class="form-check-label" for="include-goals">
                                    Aportes Previstos em Metas (Futuro)
                                </label>
                            </div>
                        </div>
                     </div>
                </div>
            </form>
        </div>
    </section>

     <!-- Seção de Resumo da Projeção -->
    <section class="summary-section" aria-labelledby="projection-summary-title">
        <h3 class="section-title" id="projection-summary-title">Resumo Projetado</h3>
        <div class="summary-grid" id="projection-summary-grid">
            <!-- Cards de Resumo (Saldo Atual, Entradas, Saídas, Saldo Final) -->
             <!-- Placeholders -->
            <div class="summary-card placeholder"></div>
            <div class="summary-card placeholder"></div>
            <div class="summary-card placeholder"></div>
            <div class="summary-card placeholder"></div>
        </div>
    </section>

    <!-- Seção do Gráfico de Evolução do Saldo -->
    <section class="chart-section" aria-labelledby="projection-chart-title">
         <h3 class="section-title" id="projection-chart-title">Evolução do Saldo Projetado</h3>
        <div class="chart-container" id="projection-chart-container">
            <canvas id="projection-chart" class="chart-canvas" role="img" aria-label="Gráfico de linha mostrando a evolução estimada do saldo ao longo do tempo"></canvas>
            <div class="chart-empty-message" style="display: none;">Não há dados suficientes para gerar a projeção.</div>
        </div>
    </section>

    <!-- Seção da Tabela Detalhada da Projeção (Opcional) -->
    <section class="details-table-section" aria-labelledby="projection-details-title">
        <h3 class="section-title" id="projection-details-title">Detalhamento por Período</h3>
        <div class="table-container" id="projection-details-table-container">
             <!-- Tabela detalhada (Mês a Mês, por ex.) será inserida aqui via JS -->
             <div class="table-loading-placeholder active">
                <p>Calculando projeção detalhada...</p>
            </div>
            <!-- Exemplo de Tabela:
            <table class="table" id="projection-details-table">
                <thead>
                    <tr>
                        <th>Período</th>
                        <th class="currency">Entradas</th>
                        <th class="currency">Saídas</th>
                        <th class="currency">Saldo do Período</th>
                        <th class="currency">Saldo Acumulado</th>
                    </tr>
                </thead>
                <tbody> -->
                    <!-- Linhas preenchidas via JS -->
                <!--</tbody>
            </table>
             <div class="table-empty-row" style="display: none;">
                <td colspan="5">Não foi possível gerar o detalhamento da projeção.</td>
            </div>
            -->
        </div>
    </section>

</div> <!-- Fim .cash-projection-module -->
<!-- ===== FIM: BLOCO 12 ============================== -->

/* ===== INÍCIO: BLOCO 13 ============================== */
/* ==== CSS MÓDULO PROJEÇÃO DE CAIXA ==== */

.cash-projection-module {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-8); /* 32px entre seções */
}

/* ----- Seção de Controles ----- */
.projection-controls.card {
    margin-bottom: 0; /* Remover margem padrão do card */
}

.projection-controls .filters-form {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-5); /* 20px entre linhas de controle */
}

/* Container para filtros de data personalizados */
.date-range-filter .date-inputs {
    display: flex;
    gap: var(--spacing-4); /* 16px entre inputs de data */
    flex-wrap: wrap; /* Quebra em telas menores */
}
.date-range-filter .date-input-group {
    flex: 1;
    min-width: 180px; /* Largura mínima para inputs de data */
}
.date-range-filter .date-input-group .form-label {
    margin-bottom: var(--spacing-1); /* Menor margem abaixo do label */
}

/* Grupo de checkboxes */
.checkbox-group {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-4); /* 16px entre checkboxes */
    padding-top: var(--spacing-1); /* Pequeno espaço acima */
}
.checkbox-group .form-check {
    margin-bottom: 0; /* Remover margem padrão do form-check */
}


/* ----- Seção de Resumo da Projeção ----- */
/* Reutiliza os estilos de .summary-grid e .summary-card definidos anteriormente,
   mas podemos adicionar ajustes se necessário */
.cash-projection-module .summary-grid {
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); /* Colunas um pouco mais largas */
}


/* ----- Seção do Gráfico ----- */
/* Reutiliza .chart-container, .chart-title, .chart-canvas */
.cash-projection-module .chart-container {
    min-height: 350px; /* Gráfico de projeção pode ser maior */
}


/* ----- Seção da Tabela Detalhada ----- */
.cash-projection-module .details-table-section .table-container {
    margin-bottom: 0;
}

/* Estilo para a linha do saldo acumulado */
.cash-projection-module #projection-details-table td:last-child {
    font-weight: var(--font-weight-semibold); /* Destaca o saldo acumulado */
}

/* ===== FIM: BLOCO 13 ============================== */

<!-- ===== INÍCIO: BLOCO 14 ============================== */
<!-- ==== ESTRUTURA HTML - MÓDULO METAS FINANCEIRAS ==== -->
<!-- Este conteúdo será inserido dinamicamente na div #content-area -->

<div class="financial-goals-module">

    <!-- Cabeçalho do Módulo com Ação Principal -->
    <section class="module-header-section">
        <div class="header-content">
            <h3 class="section-title no-border">Minhas Metas Financeiras</h3>
            <p class="section-subtitle">Acompanhe o progresso dos seus objetivos.</p>
        </div>
        <div class="header-actions">
             <button class="btn btn-primary btn-with-icon" id="add-new-goal-btn">
                <i class="fas fa-plus" aria-hidden="true"></i>
                <span class="btn-text">Nova Meta</span>
            </button>
        </div>
    </section>

    <!-- Seção de Metas Ativas -->
    <section class="goals-section active-goals-section" aria-labelledby="active-goals-title">
        <h4 class="subsection-title" id="active-goals-title">Metas em Andamento</h4>
        <div class="goals-grid" id="active-goals-grid">
            <!-- Cards de Metas Ativas serão inseridos aqui via JS -->
            <!-- Exemplo de Card de Meta (Ativa):
            <div class="goal-card" data-goal-id="xyz">
                <div class="goal-card-header" style="border-left-color: #FF9F0A;">
                    <div class="goal-icon" style="background-color: #FF9F0A;"><i class="fas fa-car"></i></div>
                    <div class="goal-info">
                        <h5 class="goal-name">Comprar Carro Novo</h5>
                        <span class="goal-details">Para: Família | Prazo: 31/12/2025</span>
                    </div>
                    <div class="goal-actions">
                        <button class="btn btn-icon-only btn-link btn-sm btn-add-contribution" title="Adicionar Aporte"><i class="fas fa-plus-circle"></i></button>
                        <button class="btn btn-icon-only btn-link btn-sm btn-edit-goal" title="Editar Meta"><i class="fas fa-edit"></i></button>
                        <button class="btn btn-icon-only btn-link btn-sm btn-delete-goal" title="Excluir Meta"><i class="fas fa-trash-alt"></i></button>
                    </div>
                </div>
                <div class="goal-card-body">
                    <div class="goal-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 60%; background-color: #FF9F0A;"></div>
                        </div>
                        <div class="progress-text">
                            <span>60%</span>
                            <span>R$ 30.000 / R$ 50.000</span>
                        </div>
                    </div>
                    <div class="goal-summary">
                        <span>Restante: <strong class="negative-value">R$ 20.000</strong></span>
                        <span>Aporte Mensal Ideal: <strong>R$ 833,33</strong></span>
                    </div>
                </div>
                <div class="goal-card-footer">
                     <span class="footer-text">Último aporte: R$ 1.000 (dd/mm/aaaa)</span>
                     <button class="btn btn-link btn-sm btn-view-contributions">Ver Aportes</button>
                </div>
            </div>
            -->
            <!-- Placeholder -->
             <div class="goal-card placeholder"></div>
             <div class="goal-card placeholder"></div>
        </div>
         <div class="empty-section-message" id="no-active-goals-message" style="display: none;">
            <i class="fas fa-flag-checkered empty-icon"></i>
            <p>Você ainda não possui metas em andamento.</p>
            <button class="btn btn-secondary btn-sm" onclick="document.getElementById('add-new-goal-btn').click()">Crie sua primeira meta!</button>
        </div>
    </section>

    <!-- Seção de Metas Concluídas -->
    <section class="goals-section completed-goals-section" aria-labelledby="completed-goals-title">
         <h4 class="subsection-title" id="completed-goals-title">Metas Concluídas</h4>
         <div class="goals-grid" id="completed-goals-grid">
            <!-- Cards de Metas Concluídas serão inseridos aqui via JS -->
            <!-- Exemplo de Card de Meta (Concluída): similar ao ativo, mas com 100% e talvez estilo diferente -->
             <!-- Placeholder -->
             <!-- <div class="goal-card placeholder"></div> -->
         </div>
         <div class="empty-section-message" id="no-completed-goals-message" style="display: none;">
            <i class="fas fa-history empty-icon"></i>
            <p>Nenhuma meta concluída ainda.</p>
        </div>
    </section>

    <!-- Modais específicos para Metas (Adicionar Aporte, Criar/Editar Meta) serão definidos depois -->

</div> <!-- Fim .financial-goals-module -->
<!-- ===== FIM: BLOCO 14 ============================== -->

/* ===== INÍCIO: BLOCO 15 ============================== */
/* ==== CSS MÓDULO METAS FINANCEIRAS ==== */

.financial-goals-module {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-8); /* 32px entre seções */
}

/* ----- Cabeçalho do Módulo ----- */
.module-header-section {
    display: flex;
    justify-content: space-between;
    align-items: flex-start; /* Alinha início do texto e botão */
    gap: var(--spacing-5); /* 20px */
    padding-bottom: var(--spacing-4); /* 16px */
    border-bottom: var(--border-width) solid var(--color-border-light);
    flex-wrap: wrap; /* Permite quebrar em telas menores */
}
.module-header-section .header-content {
    flex-grow: 1;
}
.module-header-section .section-title {
    border-bottom: none;
    padding-bottom: 0;
    margin-bottom: var(--spacing-1); /* 4px */
}
.section-subtitle {
    font-size: var(--font-size-md); /* 16px */
    color: var(--color-text-secondary);
    margin: 0;
}
.module-header-section .header-actions {
    flex-shrink: 0; /* Não deixa o botão encolher */
}

/* ----- Seções de Metas (Ativas e Concluídas) ----- */
.goals-section {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-4); /* 16px entre título e grid */
}

.subsection-title {
    font-size: var(--font-size-lg); /* 18px */
    font-weight: var(--font-weight-semibold);
    color: var(--color-text-secondary);
    margin: 0;
}

.goals-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); /* Colunas responsivas */
    gap: var(--spacing-6); /* 24px */
}

/* ----- Card de Meta ----- */
.goal-card {
    background-color: var(--color-surface);
    border-radius: var(--border-radius-lg);
    box-shadow: var(--shadow-md);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    transition: var(--transition-base);
    position: relative; /* Para placeholders */
}
.goal-card:hover {
    transform: translateY(-3px);
    box-shadow: var(--shadow-lg);
}

.goal-card-header {
    display: flex;
    align-items: center;
    gap: var(--spacing-3); /* 12px */
    padding: var(--spacing-4); /* 16px */
    /* Borda colorida dinâmica */
    border-left: 5px solid var(--color-primary); /* Cor padrão, será sobrescrita inline */
}

.goal-icon {
    width: 44px;
    height: 44px;
    border-radius: var(--border-radius-full);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    /* Cor de fundo dinâmica */
    background-color: var(--color-primary); /* Cor padrão */
    color: white;
}
.goal-icon i {
    font-size: var(--font-size-xl); /* 20px */
}

.goal-info {
    flex-grow: 1;
    min-width: 0; /* Previne que o texto empurre as ações */
}

.goal-name {
    font-size: var(--font-size-md); /* 16px */
    font-weight: var(--font-weight-semibold);
    color: var(--color-text-primary);
    margin: 0 0 var(--spacing-1) 0; /* 4px */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.goal-details {
    font-size: var(--font-size-xs); /* 12px */
    color: var(--color-text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.goal-actions {
    display: flex;
    align-items: center;
    gap: var(--spacing-1); /* 4px */
    margin-left: auto; /* Empurra para a direita */
    flex-shrink: 0;
}

/* Ajuste nos botões de ação do card */
.goal-actions .btn-sm {
    width: 30px;
    height: 30px;
    color: var(--color-text-tertiary); /* Mais sutis */
}
.goal-actions .btn-sm:hover {
    background-color: var(--color-surface-hover);
    color: var(--color-text-primary);
}
.goal-actions .btn-delete-goal:hover {
    color: var(--color-danger); /* Cor específica no hover de excluir */
}

.goal-card-body {
    padding: var(--spacing-4); /* 16px */
    display: flex;
    flex-direction: column;
    gap: var(--spacing-3); /* 12px */
    border-top: var(--border-width) solid var(--color-border-light);
}

.goal-progress {
    width: 100%;
}

.progress-bar {
    height: 8px; /* Barra mais fina */
    background-color: var(--color-border-light);
    border-radius: var(--border-radius-full);
    overflow: hidden;
    margin-bottom: var(--spacing-1); /* 4px */
}

.progress-fill {
    height: 100%;
    border-radius: var(--border-radius-full);
    /* Cor de fundo dinâmica */
    background-color: var(--color-primary); /* Cor padrão */
    transition: width var(--transition-duration-slow) ease-in-out; /* Animação mais lenta */
}

.progress-text {
    display: flex;
    justify-content: space-between;
    font-size: var(--font-size-xs); /* 12px */
    color: var(--color-text-secondary);
}
.progress-text span:first-child { font-weight: var(--font-weight-medium); } /* Percentual em negrito */

.goal-summary {
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap; /* Quebra em telas menores */
    gap: var(--spacing-3); /* 12px */
    font-size: var(--font-size-sm); /* 14px */
    color: var(--color-text-secondary);
}
.goal-summary strong {
    color: var(--color-text-primary);
    font-weight: var(--font-weight-semibold);
}

.goal-card-footer {
    padding: var(--spacing-2) var(--spacing-4); /* 8px 16px */
    border-top: var(--border-width) solid var(--color-border-light);
    background-color: var(--color-surface-variant);
    font-size: var(--font-size-xs); /* 12px */
    color: var(--color-text-tertiary);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--spacing-2);
}
.goal-card-footer .btn-link {
    padding: 0; /* Remover padding extra do botão link */
    font-size: var(--font-size-xs);
}

/* Placeholder para Card de Meta */
.goal-card.placeholder {
    background-color: var(--color-surface-hover);
    box-shadow: none;
    min-height: 220px; /* Altura aproximada de um card */
    animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Mensagem de Seção Vazia */
.empty-section-message {
    text-align: center;
    padding: var(--spacing-8) var(--spacing-4); /* 32px 16px */
    background-color: var(--color-surface-variant);
    border-radius: var(--border-radius-lg);
    color: var(--color-text-tertiary);
}
.empty-icon {
    font-size: var(--font-size-3xl); /* 30px */
    margin-bottom: var(--spacing-3); /* 12px */
    opacity: 0.5;
    display: block; /* Para centralizar */
    margin-left: auto;
    margin-right: auto;
}
.empty-section-message p {
    font-size: var(--font-size-md); /* 16px */
    color: var(--color-text-secondary);
    margin-bottom: var(--spacing-4); /* 16px */
}

/* Estilo para meta concluída (Opcional) */
.completed-goals-section .goal-card {
    opacity: 0.8; /* Levemente esmaecido */
}
.completed-goals-section .progress-fill {
    background-color: var(--color-success) !important; /* Verde de sucesso */
}
.completed-goals-section .goal-actions .btn-add-contribution {
    display: none; /* Esconde botão de adicionar aporte */
}

/* ===== FIM: BLOCO 15 ============================== */

<!-- ===== INÍCIO: BLOCO 16 ============================== */
<!-- ==== ESTRUTURA HTML - MÓDULO AJUSTES ==== -->
<!-- Este conteúdo será inserido dinamicamente na div #content-area -->

<div class="settings-module">

    <!-- Cabeçalho do Módulo -->
    <section class="module-header-section">
        <div class="header-content">
            <h3 class="section-title no-border">Ajustes Gerais</h3>
            <p class="section-subtitle">Gerencie categorias, pessoas, cartões e outras configurações.</p>
        </div>
        <!-- Ações do header podem ser adicionadas aqui se necessário -->
    </section>

    <!-- Container das Abas -->
    <div class="tabs-container settings-tabs">

        <!-- Navegação das Abas -->
        <nav class="tabs-nav" aria-label="Seções de Ajustes">
            <ul class="tabs-list" role="tablist">
                <li class="tab active" id="tab-categories" role="tab" aria-selected="true" aria-controls="tabpanel-categories">
                    <i class="fas fa-tags tab-icon" aria-hidden="true"></i>
                    <span class="tab-text">Categorias</span>
                </li>
                <li class="tab" id="tab-persons" role="tab" aria-selected="false" aria-controls="tabpanel-persons">
                    <i class="fas fa-users tab-icon" aria-hidden="true"></i>
                    <span class="tab-text">Pessoas</span>
                </li>
                <li class="tab" id="tab-cards" role="tab" aria-selected="false" aria-controls="tabpanel-cards">
                    <i class="fas fa-credit-card tab-icon" aria-hidden="true"></i>
                    <span class="tab-text">Cartões</span>
                </li>
                <li class="tab" id="tab-recurring" role="tab" aria-selected="false" aria-controls="tabpanel-recurring">
                     <i class="fas fa-sync-alt tab-icon" aria-hidden="true"></i>
                    <span class="tab-text">Recorrências</span>
                </li>
                <!-- Outras abas podem ser adicionadas aqui (e.g., Conta, Aparência) -->
            </ul>
        </nav>

        <!-- Conteúdo das Abas -->
        <div class="tabs-content">

            <!-- Painel: Categorias -->
            <div class="tab-panel active" id="tabpanel-categories" role="tabpanel" aria-labelledby="tab-categories">
                <div class="tab-panel-header">
                    <h4 class="subsection-title">Gerenciar Categorias</h4>
                    <button class="btn btn-primary btn-sm btn-with-icon" id="add-new-category-btn">
                        <i class="fas fa-plus" aria-hidden="true"></i>
                        <span class="btn-text">Nova Categoria</span>
                    </button>
                </div>
                <div class="table-container" id="categories-table-container">
                    <!-- Tabela de Categorias será inserida aqui via JS -->
                     <div class="table-loading-placeholder active"><p>Carregando categorias...</p></div>
                     <!-- Exemplo Tabela aqui -->
                </div>
            </div>

            <!-- Painel: Pessoas -->
            <div class="tab-panel" id="tabpanel-persons" role="tabpanel" aria-labelledby="tab-persons" hidden>
                 <div class="tab-panel-header">
                    <h4 class="subsection-title">Gerenciar Pessoas</h4>
                    <button class="btn btn-primary btn-sm btn-with-icon" id="add-new-person-btn">
                        <i class="fas fa-plus" aria-hidden="true"></i>
                        <span class="btn-text">Nova Pessoa</span>
                    </button>
                </div>
                <div class="settings-grid" id="persons-grid-container">
                    <!-- Cards/Lista de Pessoas será inserida aqui via JS -->
                     <div class="table-loading-placeholder active"><p>Carregando pessoas...</p></div>
                      <!-- Exemplo Card aqui -->
                </div>
            </div>

            <!-- Painel: Cartões -->
            <div class="tab-panel" id="tabpanel-cards" role="tabpanel" aria-labelledby="tab-cards" hidden>
                 <div class="tab-panel-header">
                    <h4 class="subsection-title">Gerenciar Cartões de Crédito</h4>
                    <button class="btn btn-primary btn-sm btn-with-icon" id="add-new-card-btn">
                        <i class="fas fa-plus" aria-hidden="true"></i>
                        <span class="btn-text">Novo Cartão</span>
                    </button>
                </div>
                 <div class="table-container" id="cards-table-container">
                    <!-- Tabela de Cartões será inserida aqui via JS -->
                     <div class="table-loading-placeholder active"><p>Carregando cartões...</p></div>
                      <!-- Exemplo Tabela aqui -->
                </div>
            </div>

            <!-- Painel: Recorrências -->
            <div class="tab-panel" id="tabpanel-recurring" role="tabpanel" aria-labelledby="tab-recurring" hidden>
                 <div class="tab-panel-header">
                    <h4 class="subsection-title">Gerenciar Transações Recorrentes</h4>
                     <!-- Botão Adicionar pode não fazer sentido aqui, gerenciado na transação original -->
                </div>
                 <div class="table-container" id="recurring-table-container">
                    <!-- Tabela de Recorrências será inserida aqui via JS -->
                     <div class="table-loading-placeholder active"><p>Carregando recorrências...</p></div>
                      <!-- Exemplo Tabela aqui -->
                </div>
            </div>

        </div> <!-- Fim .tabs-content -->

    </div> <!-- Fim .tabs-container -->

     <!-- Modais específicos para Ajustes (Criar/Editar Categoria, Pessoa, Cartão) serão definidos depois -->

</div> <!-- Fim .settings-module -->
<!-- ===== FIM: BLOCO 16 ============================== -->

/* ===== INÍCIO: BLOCO 17 ============================== */
/* ==== CSS MÓDULO AJUSTES & COMPONENTE TABS ==== */

.settings-module {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-6); /* 24px entre header e tabs */
}

/* Ajuste no header do módulo, se necessário */
.settings-module .module-header-section {
    /* Estilos específicos se houver */
}

/* ============================================ */
/* ==========   COMPONENTE TABS    ========== */
/* ============================================ */

.tabs-container {
    display: flex;
    flex-direction: column;
    /* Pode adicionar um card style se quiser que as tabs fiquem dentro de um card */
    /* background-color: var(--color-surface); */
    /* border-radius: var(--border-radius-lg); */
    /* box-shadow: var(--shadow-md); */
    /* overflow: hidden; */
}

.tabs-nav {
    border-bottom: var(--border-width-lg) solid var(--color-border-light); /* Linha divisória abaixo das abas */
    margin-bottom: var(--spacing-6); /* 24px de espaço abaixo das abas */
    overflow-x: auto; /* Permite scroll horizontal se as abas não couberem */
    scrollbar-width: thin; /* Scrollbar fina no Firefox */
    scrollbar-color: var(--color-text-tertiary) transparent; /* Cor da scrollbar no Firefox */
}
/* Esconder scrollbar padrão no webkit, mantendo funcionalidade */
.tabs-nav::-webkit-scrollbar {
    height: 4px; /* Altura da scrollbar horizontal */
}
.tabs-nav::-webkit-scrollbar-thumb {
    background-color: color-mix(in srgb, var(--color-text-tertiary) 50%, transparent);
    border-radius: var(--border-radius-full);
}
.tabs-nav::-webkit-scrollbar-thumb:hover {
    background-color: var(--color-text-tertiary);
}


.tabs-list {
    display: flex;
    list-style: none;
    padding: 0;
    margin: 0;
    width: max-content; /* Garante que a lista não quebre linha internamente */
}

.tab {
    display: inline-flex;
    align-items: center;
    gap: var(--spacing-2); /* 8px */
    padding: var(--spacing-3) var(--spacing-5); /* 12px 20px */
    font-size: var(--font-size-sm); /* 14px */
    font-weight: var(--font-weight-medium);
    color: var(--color-text-secondary);
    border-bottom: 2px solid transparent; /* Borda para indicar seleção */
    margin-bottom: -2px; /* Compensa a altura da borda inferior */
    cursor: pointer;
    white-space: nowrap;
    transition: color var(--transition-duration-fast) ease-in-out,
                border-color var(--transition-duration-fast) ease-in-out;
    position: relative; /* Para possíveis indicadores */
}
.tab:hover {
    color: var(--color-text-primary);
    background-color: var(--color-surface-hover); /* Fundo sutil no hover */
}
.tab.active {
    color: var(--color-primary);
    border-bottom-color: var(--color-primary);
    font-weight: var(--font-weight-semibold);
}
.tab:focus-visible {
    outline: 2px solid color-mix(in srgb, var(--color-primary) 50%, transparent);
    outline-offset: -2px; /* Outline interno */
    border-radius: var(--border-radius-sm); /* Raio no outline */
}

.tab-icon {
    font-size: var(--font-size-md); /* 16px */
}

/* ----- Conteúdo das Abas ----- */
.tabs-content {
    /* Sem estilos específicos por padrão, o conteúdo é controlado pelo .tab-panel */
}

.tab-panel {
    /* display: none; é controlado pelo atributo [hidden] e JS */
    animation: fadeIn 0.3s ease-in-out; /* Animação suave ao trocar de aba */
}
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(5px); }
    to { opacity: 1; transform: translateY(0); }
}

.tab-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-5); /* 20px */
    flex-wrap: wrap;
    gap: var(--spacing-3);
}
.tab-panel-header .subsection-title {
    margin: 0; /* Remove margem padrão do título aqui */
}

/* ----- Estilos Específicos dos Painéis de Ajustes ----- */

/* Usar grid para exibir Pessoas em cards (se desejado) */
.settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: var(--spacing-5); /* 20px */
}

/* Card de Pessoa (Exemplo de como poderia ser) */
.person-card {
    background-color: var(--color-surface);
    border-radius: var(--border-radius-lg);
    box-shadow: var(--shadow-md);
    padding: var(--spacing-4);
    display: flex;
    align-items: center;
    gap: var(--spacing-4);
    transition: var(--transition-base);
}
.person-card:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
}
.person-card .avatar { /* Usar classe .avatar definida antes */
    flex-shrink: 0;
}
.person-info {
    flex-grow: 1;
    min-width: 0;
}
.person-name {
    font-weight: var(--font-weight-medium);
    color: var(--color-text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: var(--spacing-1);
}
.person-details { /* Para adicionar email ou outra info futuramente */
    font-size: var(--font-size-sm);
    color: var(--color-text-secondary);
}
.person-actions {
    display: flex;
    gap: var(--spacing-1);
}

/* Ajuste nas tabelas dentro das abas */
.settings-module .table-container {
    margin-bottom: 0; /* Remover margem se for o último elemento */
}

/* Placeholder dentro das tabs */
.settings-module .table-loading-placeholder {
     background-color: transparent; /* Sem fundo extra */
     padding: var(--spacing-8) 0;
}

/* ===== FIM: BLOCO 17 ============================== */

<!-- ===== INÍCIO: BLOCO 18 ============================== -->
<!-- ==== ESTRUTURA HTML - MODAIS PRINCIPAIS ==== -->
<!-- Este conteúdo vai DENTRO da div#modal-container -->

<!-- 1. Modal de Nova/Editar Transação -->
<div class="modal" id="transaction-modal" role="dialog" aria-modal="true" aria-labelledby="transaction-modal-title" hidden>
    <div class="modal-content">
        <form id="transaction-form" novalidate>
            <div class="modal-header">
                <h4 class="modal-title" id="transaction-modal-title">Nova Transação</h4>
                <button type="button" class="modal-close-btn" data-dismiss="modal" aria-label="Fechar modal">
                    <i class="fas fa-times" aria-hidden="true"></i>
                </button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="transaction-id"> <!-- Para edição -->

                <div class="form-group">
                    <label for="transaction-description" class="form-label">Descrição</label>
                    <input type="text" id="transaction-description" class="form-input" placeholder="Ex: Compra no supermercado" required>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="transaction-amount" class="form-label">Valor (R$)</label>
                        <input type="number" id="transaction-amount" class="form-input" placeholder="0,00" step="0.01" min="0.01" required inputmode="decimal">
                    </div>
                    <div class="form-group">
                        <label for="transaction-date" class="form-label">Data</label>
                        <input type="date" id="transaction-date" class="form-input" required>
                    </div>
                </div>

                <div class="form-row">
                     <div class="form-group">
                        <label for="transaction-type" class="form-label">Tipo</label>
                        <select id="transaction-type" class="form-select" required>
                            <option value="expense" selected>Despesa</option>
                            <option value="income">Receita</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="transaction-category" class="form-label">Categoria</label>
                        <select id="transaction-category" class="form-select" required>
                            <option value="" disabled selected>Selecione...</option>
                            <!-- Opções preenchidas via JS -->
                        </select>
                    </div>
                </div>

                 <div class="form-row">
                    <div class="form-group">
                        <label for="transaction-payment-method" class="form-label">Forma de Pagamento</label>
                        <select id="transaction-payment-method" class="form-select" required>
                             <option value="" disabled selected>Selecione...</option>
                             <option value="cash">Dinheiro</option>
                             <option value="debit">Débito</option>
                             <option value="credit">Cartão de Crédito</option>
                             <option value="pix">PIX</option>
                             <option value="transfer">Transferência</option>
                             <option value="other">Outro</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="transaction-person" class="form-label">Pessoa</label>
                        <select id="transaction-person" class="form-select" required>
                             <option value="" disabled selected>Selecione...</option>
                             <!-- Opções preenchidas via JS -->
                        </select>
                    </div>
                </div>

                 <!-- Detalhes Condicionais: Cartão de Crédito -->
                 <div class="form-row conditional-fields" id="credit-card-details" style="display: none;">
                     <div class="form-group">
                        <label for="transaction-card" class="form-label">Cartão</label>
                        <select id="transaction-card" class="form-select">
                             <option value="" disabled selected>Selecione o cartão...</option>
                             <!-- Opções preenchidas via JS -->
                        </select>
                    </div>
                      <div class="form-group">
                        <label for="transaction-installments" class="form-label">Parcelas</label>
                        <select id="transaction-installments" class="form-select">
                             <option value="1">À vista (1x)</option>
                             <!-- Opções de 2x a 12x geradas via JS -->
                        </select>
                    </div>
                 </div>

                 <div class="form-group">
                    <label for="transaction-notes" class="form-label">Observações (Opcional)</label>
                    <textarea id="transaction-notes" class="form-textarea" placeholder="Detalhes adicionais, local da compra, etc."></textarea>
                </div>

                <!-- Opções Avançadas (Recorrência, Prioridade - podem ficar ocultas inicialmente) -->
                <details class="advanced-options">
                    <summary class="advanced-options-summary">Opções Avançadas</summary>
                    <div class="advanced-options-content">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="transaction-recurrent">
                            <label class="form-check-label" for="transaction-recurrent">
                                É uma transação recorrente?
                            </label>
                        </div>
                         <!-- Detalhes Condicionais: Recorrência -->
                         <div class="form-group conditional-fields" id="recurrent-details" style="display: none;">
                             <label for="recurrent-frequency" class="form-label">Frequência</label>
                             <select id="recurrent-frequency" class="form-select">
                                 <option value="monthly">Mensal</option>
                                 <option value="bimonthly">Bimestral</option>
                                 <option value="quarterly">Trimestral</option>
                                 <option value="semiannual">Semestral</option>
                                 <option value="annual">Anual</option>
                             </select>
                         </div>
                         <!-- Outras opções avançadas como Prioridade podem vir aqui -->
                         <div class="form-group">
                             <label for="transaction-priority" class="form-label">Prioridade (Opcional)</label>
                             <select id="transaction-priority" class="form-select">
                                 <option value="medium" selected>Normal</option>
                                 <option value="high">Alta</option>
                                 <option value="low">Baixa</option>
                                 <option value="essential">Essencial (Fixa)</option>
                             </select>
                         </div>
                    </div>
                </details>

            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>
                <button type="submit" class="btn btn-primary">Salvar Transação</button>
            </div>
        </form>
    </div>
</div>

<!-- 2. Modal de Nova/Editar Categoria -->
<div class="modal modal-sm" id="category-modal" role="dialog" aria-modal="true" aria-labelledby="category-modal-title" hidden>
    <div class="modal-content">
         <form id="category-form" novalidate>
            <div class="modal-header">
                <h4 class="modal-title" id="category-modal-title">Nova Categoria</h4>
                <button type="button" class="modal-close-btn" data-dismiss="modal" aria-label="Fechar modal">
                    <i class="fas fa-times" aria-hidden="true"></i>
                </button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="category-id"> <!-- Para edição -->
                <div class="form-group">
                    <label for="category-name" class="form-label">Nome da Categoria</label>
                    <input type="text" id="category-name" class="form-input" placeholder="Ex: Alimentação, Transporte" required>
                </div>
                 <div class="form-group">
                    <label for="category-icon" class="form-label">Ícone</label>
                    <!-- Componente seletor de ícone (HTML básico, JS fará a mágica) -->
                    <div class="icon-selector-container">
                        <button type="button" class="btn btn-secondary icon-selector-button" id="category-icon-button" aria-haspopup="true" aria-expanded="false">
                             <span id="category-selected-icon-display"><i class="fas fa-tag"></i></span> <!-- Ícone padrão -->
                             <span id="category-selected-icon-value" class="sr-only">fa-tag</span>
                        </button>
                        <div class="icon-selector-dropdown" id="category-icon-dropdown" role="listbox" hidden>
                            <!-- Ícones serão carregados aqui via JS -->
                        </div>
                         <input type="hidden" id="category-icon" value="fa-tag">
                    </div>
                </div>
                 <div class="form-group">
                    <label for="category-color" class="form-label">Cor</label>
                    <input type="color" id="category-color" class="form-input form-input-color" value="#0A84FF"> <!-- Cor primária como padrão -->
                </div>
            </div>
             <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>
                <button type="submit" class="btn btn-primary">Salvar Categoria</button>
            </div>
         </form>
    </div>
</div>

<!-- 3. Modal de Nova/Editar Pessoa -->
<div class="modal modal-sm" id="person-modal" role="dialog" aria-modal="true" aria-labelledby="person-modal-title" hidden>
     <div class="modal-content">
         <form id="person-form" novalidate>
             <div class="modal-header">
                <h4 class="modal-title" id="person-modal-title">Nova Pessoa</h4>
                <button type="button" class="modal-close-btn" data-dismiss="modal" aria-label="Fechar modal">
                    <i class="fas fa-times" aria-hidden="true"></i>
                </button>
            </div>
            <div class="modal-body">
                 <input type="hidden" id="person-id"> <!-- Para edição -->
                 <div class="form-group">
                    <label for="person-name" class="form-label">Nome da Pessoa</label>
                    <input type="text" id="person-name" class="form-input" placeholder="Ex: João Silva, Família" required>
                </div>
                 <div class="form-group">
                    <label class="form-label">Avatar</label>
                    <!-- Componente seletor de avatar -->
                     <div class="avatar-selector-container">
                         <div class="selected-avatar-display" id="person-selected-avatar-display">
                             <div class="avatar avatar-lg avatar-bg-1" data-initials="?" aria-hidden="true"></div> <!-- Avatar padrão -->
                         </div>
                         <div class="avatar-grid" id="person-avatar-grid">
                              <!-- Avatares pré-definidos carregados via JS -->
                         </div>
                         <input type="hidden" id="person-avatar-color" value="avatar-bg-1"> <!-- Armazena a classe da cor -->
                         <input type="hidden" id="person-avatar-initials" value=""> <!-- Futuro: para iniciais customizadas -->
                     </div>
                 </div>
                 <!-- Outros campos como email, etc., podem ser adicionados aqui -->
            </div>
             <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>
                <button type="submit" class="btn btn-primary">Salvar Pessoa</button>
            </div>
         </form>
     </div>
</div>

<!-- 4. Modal de Nova/Editar Cartão -->
<div class="modal" id="card-modal" role="dialog" aria-modal="true" aria-labelledby="card-modal-title" hidden>
     <div class="modal-content">
         <form id="card-form" novalidate>
             <div class="modal-header">
                <h4 class="modal-title" id="card-modal-title">Novo Cartão de Crédito</h4>
                <button type="button" class="modal-close-btn" data-dismiss="modal" aria-label="Fechar modal">
                    <i class="fas fa-times" aria-hidden="true"></i>
                </button>
            </div>
            <div class="modal-body">
                 <input type="hidden" id="card-id"> <!-- Para edição -->
                 <div class="form-group">
                    <label for="card-name" class="form-label">Nome do Cartão</label>
                    <input type="text" id="card-name" class="form-input" placeholder="Ex: Nubank, Inter Gold" required>
                </div>
                 <div class="form-row">
                    <div class="form-group">
                        <label for="card-limit" class="form-label">Limite (R$) (Opcional)</label>
                        <input type="number" id="card-limit" class="form-input" placeholder="0,00" step="0.01" min="0" inputmode="decimal">
                    </div>
                     <div class="form-group">
                        <label for="card-color" class="form-label">Cor de Identificação</label>
                        <input type="color" id="card-color" class="form-input form-input-color" value="#FF453A"> <!-- Vermelho padrão -->
                    </div>
                 </div>
                 <div class="form-row">
                     <div class="form-group">
                        <label for="card-closing-day" class="form-label">Dia de Fechamento da Fatura</label>
                        <input type="number" id="card-closing-day" class="form-input" placeholder="Ex: 25" min="1" max="31" inputmode="numeric">
                    </div>
                    <div class="form-group">
                        <label for="card-due-day" class="form-label">Dia de Vencimento da Fatura</label>
                        <input type="number" id="card-due-day" class="form-input" placeholder="Ex: 05" min="1" max="31" inputmode="numeric">
                    </div>
                 </div>
            </div>
             <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>
                <button type="submit" class="btn btn-primary">Salvar Cartão</button>
            </div>
         </form>
     </div>
</div>

<!-- 5. Modal de Nova/Editar Meta -->
<div class="modal" id="goal-modal" role="dialog" aria-modal="true" aria-labelledby="goal-modal-title" hidden>
     <div class="modal-content">
         <form id="goal-form" novalidate>
            <div class="modal-header">
                <h4 class="modal-title" id="goal-modal-title">Nova Meta Financeira</h4>
                 <button type="button" class="modal-close-btn" data-dismiss="modal" aria-label="Fechar modal">
                    <i class="fas fa-times" aria-hidden="true"></i>
                </button>
            </div>
            <div class="modal-body">
                 <input type="hidden" id="goal-id"> <!-- Para edição -->
                 <div class="form-group">
                    <label for="goal-name" class="form-label">Nome da Meta</label>
                    <input type="text" id="goal-name" class="form-input" placeholder="Ex: Viagem para a praia, Reserva de emergência" required>
                 </div>
                 <div class="form-row">
                     <div class="form-group">
                        <label for="goal-target" class="form-label">Valor Alvo (R$)</label>
                        <input type="number" id="goal-target" class="form-input" placeholder="0,00" step="0.01" min="0.01" required inputmode="decimal">
                    </div>
                     <div class="form-group">
                        <label for="goal-deadline" class="form-label">Prazo Final</label>
                        <input type="date" id="goal-deadline" class="form-input" required>
                    </div>
                 </div>
                 <div class="form-row">
                     <div class="form-group">
                        <label for="goal-person" class="form-label">Destinatário (Opcional)</label>
                        <select id="goal-person" class="form-select">
                             <option value="">Para todos</option>
                             <!-- Opções preenchidas via JS -->
                        </select>
                    </div>
                     <div class="form-group">
                        <label for="goal-icon" class="form-label">Ícone</label>
                         <div class="icon-selector-container">
                            <button type="button" class="btn btn-secondary icon-selector-button" id="goal-icon-button" aria-haspopup="true" aria-expanded="false">
                                 <span id="goal-selected-icon-display"><i class="fas fa-bullseye"></i></span> <!-- Ícone padrão -->
                                 <span id="goal-selected-icon-value" class="sr-only">fa-bullseye</span>
                            </button>
                            <div class="icon-selector-dropdown" id="goal-icon-dropdown" role="listbox" hidden>
                                <!-- Ícones serão carregados aqui via JS -->
                            </div>
                             <input type="hidden" id="goal-icon" value="fa-bullseye">
                         </div>
                     </div>
                     <div class="form-group">
                        <label for="goal-color" class="form-label">Cor</label>
                        <input type="color" id="goal-color" class="form-input form-input-color" value="#FF9F0A"> <!-- Laranja padrão -->
                    </div>
                 </div>
                 <div class="form-group">
                    <label for="goal-purpose" class="form-label">Propósito (Opcional)</label>
                    <textarea id="goal-purpose" class="form-textarea" placeholder="Descreva o motivo desta meta..."></textarea>
                 </div>
            </div>
             <div class="modal-footer">
                 <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>
                <button type="submit" class="btn btn-primary">Salvar Meta</button>
            </div>
         </form>
     </div>
</div>

<!-- 6. Modal de Adicionar Aporte à Meta -->
<div class="modal modal-sm" id="contribution-modal" role="dialog" aria-modal="true" aria-labelledby="contribution-modal-title" hidden>
     <div class="modal-content">
         <form id="contribution-form" novalidate>
            <div class="modal-header">
                 <h4 class="modal-title" id="contribution-modal-title">Adicionar Aporte</h4>
                 <button type="button" class="modal-close-btn" data-dismiss="modal" aria-label="Fechar modal">
                    <i class="fas fa-times" aria-hidden="true"></i>
                </button>
            </div>
             <div class="modal-body">
                 <input type="hidden" id="contribution-goal-id"> <!-- ID da meta vinculada -->
                 <input type="hidden" id="contribution-id"> <!-- Para edição (se necessário) -->

                 <div class="form-group">
                     <label class="form-label">Meta:</label>
                     <p id="contribution-goal-name-display" class="goal-name-display"></p> <!-- Nome da meta preenchido via JS -->
                 </div>

                 <div class="form-row">
                     <div class="form-group">
                        <label for="contribution-amount" class="form-label">Valor do Aporte (R$)</label>
                        <input type="number" id="contribution-amount" class="form-input" placeholder="0,00" step="0.01" min="0.01" required inputmode="decimal">
                    </div>
                     <div class="form-group">
                        <label for="contribution-date" class="form-label">Data do Aporte</label>
                        <input type="date" id="contribution-date" class="form-input" required>
                    </div>
                 </div>
                 <div class="form-group">
                    <label for="contribution-notes" class="form-label">Observações (Opcional)</label>
                    <textarea id="contribution-notes" class="form-textarea" placeholder="Origem do valor, etc."></textarea>
                 </div>
            </div>
             <div class="modal-footer">
                 <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>
                <button type="submit" class="btn btn-primary">Salvar Aporte</button>
            </div>
         </form>
     </div>
</div>

<!-- 7. Modal de Confirmação Genérico -->
<div class="modal modal-sm" id="confirm-dialog" role="alertdialog" aria-modal="true" aria-labelledby="confirm-dialog-title" aria-describedby="confirm-dialog-message" hidden>
     <div class="modal-content">
         <div class="modal-header">
             <h4 class="modal-title" id="confirm-dialog-title">Confirmar Ação</h4>
             <!-- Sem botão de fechar padrão, ação deve ser explícita -->
         </div>
         <div class="modal-body">
             <p id="confirm-dialog-message">Tem certeza que deseja realizar esta ação?</p>
             <!-- Pode adicionar um ícone de alerta aqui -->
         </div>
         <div class="modal-footer">
             <button type="button" class="btn btn-secondary" id="confirm-dialog-cancel-btn">Cancelar</button>
             <button type="button" class="btn btn-danger" id="confirm-dialog-confirm-btn">Confirmar</button> <!-- Botão de confirmação geralmente é perigoso -->
         </div>
     </div>
</div>

<!-- Outros modais específicos podem ser adicionados aqui -->

<!-- ===== FIM: BLOCO 18 ============================== -->


/* ===== INÍCIO: BLOCO 19 ============================== */
/* ==== CSS MODAIS & COMPONENTES ADICIONAIS ==== */

/* ============================================ */
/* === AJUSTES E MELHORIAS EM MODAIS === */
/* ============================================ */

/* Garante scroll no body do modal e não no modal inteiro */
.modal-content {
    display: flex; /* Já definido, mas reforça */
    flex-direction: column;
    max-height: inherit; /* Herda max-height do .modal */
}

.modal-body {
    overflow-y: auto; /* Scroll apenas no corpo */
    flex-grow: 1; /* Ocupa espaço */
    /* Estilização da scrollbar dentro do modal */
    scrollbar-width: thin;
    scrollbar-color: var(--color-text-tertiary) transparent;
}
.modal-body::-webkit-scrollbar { width: 6px; height: 6px; }
.modal-body::-webkit-scrollbar-thumb { background-color: color-mix(in srgb, var(--color-text-tertiary) 50%, transparent); border-radius: var(--border-radius-full); }
.modal-body::-webkit-scrollbar-thumb:hover { background-color: var(--color-text-tertiary); }

/* Detalhes Condicionais (Cartão, Recorrência) */
.conditional-fields {
    background-color: color-mix(in srgb, var(--color-surface-hover) 50%, transparent); /* Fundo sutil */
    padding: var(--spacing-3) var(--spacing-4); /* 12px 16px */
    margin: var(--spacing-4) calc(-1 * var(--spacing-4)); /* Ocupa largura, compensa padding */
    border-radius: var(--border-radius-md);
    border: var(--border-width) dashed var(--color-border-light); /* Borda tracejada */
    /* Animação suave ao aparecer/desaparecer (controlada via JS) */
    max-height: 0;
    overflow: hidden;
    opacity: 0;
    transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, padding 0.3s ease-in-out, margin-top 0.3s ease-in-out;
}
.conditional-fields.visible {
    max-height: 500px; /* Altura suficiente para o conteúdo */
    opacity: 1;
    margin-top: var(--spacing-4);
    padding: var(--spacing-3) var(--spacing-4);
}

/* Elemento <details> para Opções Avançadas */
.advanced-options {
    margin-top: var(--spacing-5); /* 20px */
    border: var(--border-width) solid var(--color-border-light);
    border-radius: var(--border-radius-md);
}
.advanced-options-summary {
    padding: var(--spacing-3) var(--spacing-4); /* 12px 16px */
    cursor: pointer;
    font-weight: var(--font-weight-medium);
    color: var(--color-text-secondary);
    list-style: none; /* Remove marcador padrão */
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background-color var(--transition-duration-fast) ease-in-out;
}
.advanced-options-summary:hover {
    background-color: var(--color-surface-hover);
}
.advanced-options-summary::after { /* Indicador de abrir/fechar */
    content: '\f078'; /* Font Awesome chevron-down */
    font-family: 'Font Awesome 6 Free';
    font-weight: 900;
    transition: transform var(--transition-duration-fast) ease-in-out;
    font-size: 0.8em;
    color: var(--color-text-tertiary);
}
.advanced-options[open] > .advanced-options-summary::after {
    transform: rotate(180deg);
}
.advanced-options-content {
    padding: var(--spacing-4); /* 16px */
    border-top: var(--border-width) solid var(--color-border-light);
    display: flex;
    flex-direction: column;
    gap: var(--spacing-4); /* 16px */
}

/* Display do nome da meta no modal de aporte */
.goal-name-display {
    font-weight: var(--font-weight-semibold);
    font-size: var(--font-size-lg);
    color: var(--color-text-primary);
    padding: var(--spacing-2) 0;
    border-bottom: 1px dashed var(--color-border-light);
    margin-bottom: var(--spacing-3);
}


/* ============================================ */
/* === COMPONENTES SELETORES (Ícone/Avatar) === */
/* ============================================ */

.icon-selector-container,
.avatar-selector-container {
    position: relative; /* Para posicionar o dropdown */
}

.icon-selector-button {
    display: flex;
    align-items: center;
    gap: var(--spacing-2); /* 8px */
    min-width: 80px; /* Largura mínima */
    justify-content: center; /* Centraliza ícone */
    padding: var(--spacing-2) var(--spacing-3); /* 8px 12px */
}
.icon-selector-button span:first-child i { /* O ícone visível */
    font-size: var(--font-size-lg); /* 18px */
    color: var(--color-text-secondary);
}
.icon-selector-button:hover span:first-child i,
.icon-selector-button:focus span:first-child i {
     color: var(--color-text-primary);
}


.icon-selector-dropdown {
    position: absolute;
    top: calc(100% + var(--spacing-1)); /* Abaixo do botão */
    left: 0;
    background-color: var(--color-surface);
    border: var(--border-width) solid var(--color-border);
    border-radius: var(--border-radius-md);
    box-shadow: var(--shadow-lg);
    z-index: var(--z-index-dropdown);
    padding: var(--spacing-2); /* 8px */
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); /* Grid responsiva */
    gap: var(--spacing-2); /* 8px */
    max-height: 250px; /* Altura máxima com scroll */
    overflow-y: auto;
    width: 280px; /* Largura fixa ou max-width */
    opacity: 0;
    visibility: hidden;
    transform: translateY(-10px);
    transition: opacity var(--transition-duration-fast) ease-in-out,
                transform var(--transition-duration-fast) ease-in-out,
                visibility var(--transition-duration-fast) ease-in-out;
}
.icon-selector-dropdown.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}
/* Scrollbar no dropdown */
.icon-selector-dropdown::-webkit-scrollbar { width: 5px; }
.icon-selector-dropdown::-webkit-scrollbar-thumb { background-color: color-mix(in srgb, var(--color-text-tertiary) 50%, transparent); border-radius: var(--border-radius-full); }

.icon-selector-dropdown .icon-option {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    border-radius: var(--border-radius-md);
    cursor: pointer;
    transition: background-color var(--transition-duration-fast) ease-in-out;
    font-size: var(--font-size-lg); /* 18px */
    color: var(--color-text-secondary);
}
.icon-selector-dropdown .icon-option:hover,
.icon-selector-dropdown .icon-option.selected {
    background-color: var(--color-surface-hover);
    color: var(--color-text-primary);
}
.icon-selector-dropdown .icon-option.selected {
     outline: 2px solid var(--color-primary);
     outline-offset: -2px;
}


/* Seletor de Avatar */
.selected-avatar-display {
    display: inline-block; /* Para não ocupar largura total */
    margin-bottom: var(--spacing-2); /* Espaço antes da grid */
    cursor: pointer;
}
.selected-avatar-display .avatar {
    border: 2px solid var(--color-border); /* Borda para indicar seleção */
}

.avatar-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(44px, 1fr));
    gap: var(--spacing-3); /* 12px */
    padding: var(--spacing-3); /* 12px */
    background-color: var(--color-surface-variant);
    border-radius: var(--border-radius-md);
    max-width: 300px; /* Limitar largura */
}
.avatar-grid .avatar-option {
    width: 44px;
    height: 44px;
    border-radius: var(--border-radius-full);
    cursor: pointer;
    transition: transform var(--transition-duration-fast) ease-in-out,
                box-shadow var(--transition-duration-fast) ease-in-out;
    position: relative;
}
.avatar-grid .avatar-option:hover {
    transform: scale(1.1);
    box-shadow: 0 0 0 2px var(--color-surface), 0 0 0 4px var(--color-primary); /* Destaque duplo */
}
.avatar-grid .avatar-option.selected::after { /* Indicador de seleção */
    content: '\f00c'; /* check */
    font-family: 'Font Awesome 6 Free';
    font-weight: 900;
    position: absolute;
    bottom: -2px;
    right: -2px;
    width: 18px;
    height: 18px;
    background-color: var(--color-primary);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    border: 1px solid var(--color-surface);
}


/* ============================================ */
/* ==========     AJUSTES FINAIS    ========= */
/* ============================================ */

/* Ajuste para garantir que o foco seja visível em todos os temas */
*:focus-visible {
    outline: 2px solid var(--color-primary);
    outline-offset: 2px;
    border-radius: var(--border-radius-sm); /* Raio sutil no outline */
}
/* Remover outline padrão se já estamos tratando o :focus-visible */
*:focus {
    outline: none;
}

/* ===== FIM: BLOCO 19 ============================== */

// ===== INÍCIO: BLOCO 20 ==============================
// ==== JAVASCRIPT - CONFIGURAÇÃO FIREBASE ====

// Certifique-se de que as variáveis de configuração do Firebase estão corretas
// ATENÇÃO: É altamente recomendável usar variáveis de ambiente ou um
//          serviço de configuração para armazenar estas chaves em produção,
//          em vez de colocá-las diretamente no código fonte.
//          Para o GitHub Pages (sem backend), esta é uma limitação,
//          mas esteja ciente dos riscos se o projeto crescer.
//          Configure as Regras de Segurança do Firestore corretamente!

const firebaseConfig = {
  apiKey: "AIzaSyDvL_nYWhy_8rPouejiWbDZtDCKHYOQyEY", // Sua Chave de API Web
  authDomain: "calculadora-da-familia.firebaseapp.com", // Seu Domínio de Autenticação
  projectId: "calculadora-da-familia", // Seu ID do Projeto
  storageBucket: "calculadora-da-familia.appspot.com", // Seu Storage Bucket
  messagingSenderId: "69721783786", // Seu ID do Remetente de Mensagens
  appId: "1:69721783786:web:c4703b5c182e3681e8c693", // Seu ID do Aplicativo Web
  measurementId: "G-YM5TR661S6" // Seu ID de Medição (Google Analytics, opcional)
};

// --- Inicialização do Firebase ---
let db; // Variável global para a instância do Firestore
let firebaseApp; // Variável global para a instância do App Firebase

try {
  // Verifica se o Firebase já foi inicializado para evitar erros de reinicialização
  if (!firebase.apps.length) {
    firebaseApp = firebase.initializeApp(firebaseConfig);
    console.log("Firebase App inicializado com sucesso.");
  } else {
    firebaseApp = firebase.app(); // Pega a instância existente
    console.log("Firebase App já estava inicializado.");
  }

  // Inicializa o Firestore usando a versão compat (v9 compat)
  db = firebase.firestore();
  console.log("Firestore inicializado com sucesso.");

  // Opcional: Habilitar persistência offline (melhora experiência offline)
  // db.enablePersistence()
  //   .then(() => console.log("Persistência offline do Firestore habilitada."))
  //   .catch((err) => {
  //     if (err.code == 'failed-precondition') {
  //       console.warn("Persistência offline: Múltiplas abas abertas, só pode ser habilitada em uma.");
  //     } else if (err.code == 'unimplemented') {
  //       console.warn("Persistência offline: Navegador não suportado.");
  //     } else {
  //       console.error("Erro ao habilitar persistência offline:", err);
  //     }
  //   });

} catch (error) {
  console.error("Erro Crítico - Falha ao inicializar o Firebase:", error);
  // Adicionar aqui uma mensagem visual para o usuário seria ideal
  alert("Erro crítico: Não foi possível conectar ao banco de dados. Verifique sua conexão e tente recarregar a página.");
  // Poderia desabilitar a interface ou mostrar uma mensagem de erro permanente
}

// --- Definição das Coleções Principais ---
// Define as referências às coleções para fácil acesso em outras partes do código.
// Usar 'const' garante que a referência não seja reatribuída acidentalmente.
// Adicionamos uma verificação para evitar erros se 'db' não for inicializado.

const collections = {
    transactions: db ? db.collection('transactions') : null,
    categories:   db ? db.collection('categories')   : null,
    persons:      db ? db.collection('persons')      : null,
    cards:        db ? db.collection('cards')        : null,
    goals:        db ? db.collection('goals')        : null,
    contributions:db ? db.collection('contributions'): null,
    // Adicione outras coleções aqui conforme necessário (ex: recurring_templates, users)
};

// Verifica se todas as coleções essenciais foram carregadas
if (!collections.transactions || !collections.categories || !collections.persons || !collections.cards || !collections.goals || !collections.contributions) {
    if (db) { // Se db existe mas alguma coleção falhou (pouco provável)
      console.error("Erro: Não foi possível obter referência para uma ou mais coleções do Firestore.");
    } else {
      console.error("Erro: Instância do Firestore (db) não está disponível. As coleções não podem ser acessadas.");
    }
    // Adicionar tratamento de erro adicional se necessário
} else {
    console.log("Referências das coleções do Firestore obtidas.");
}


// ===== FIM: BLOCO 20 ==============================

// ===== INÍCIO: BLOCO 21 ==============================
// ==== JAVASCRIPT - FUNÇÕES UTILITÁRIAS (utils.js) ====

const Utils = {

    // --- Formatação ---

    /**
     * Formata um número como moeda brasileira (BRL).
     * @param {number | string} value O valor a ser formatado.
     * @param {boolean} showSymbol Exibir ou não o símbolo 'R$'. Padrão: true.
     * @returns {string} O valor formatado como moeda.
     */
    formatCurrency(value, showSymbol = true) {
        const numericValue = parseFloat(value) || 0;
        const options = {
            style: 'currency',
            currency: 'BRL',
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
        };
        if (!showSymbol) {
            options.currencyDisplay = 'code'; // Exibe 'BRL' em vez de 'R$'
            return numericValue.toLocaleString('pt-BR', options).replace('BRL', '').trim();
        }
        return numericValue.toLocaleString('pt-BR', options);
    },

    /**
     * Formata uma data (objeto Date, Timestamp do Firebase ou string) para exibição (dd/mm/aaaa).
     * @param {Date | firebase.firestore.Timestamp | string | null | undefined} dateInput A data a ser formatada.
     * @returns {string} A data formatada ou '' se a entrada for inválida.
     */
    formatDate(dateInput) {
        if (!dateInput) return '';
        let date;
        try {
            if (dateInput instanceof firebase.firestore.Timestamp) {
                date = dateInput.toDate();
            } else if (typeof dateInput === 'string' && dateInput.includes('-')) {
                // Tenta tratar string 'aaaa-mm-dd' ou 'aaaa-mm-ddThh:mm:ss...'
                 date = new Date(dateInput.split('T')[0] + 'T00:00:00'); // Força UTC para evitar problemas de fuso
                 if(isNaN(date)) throw new Error('Invalid date string');
            } else if (!(dateInput instanceof Date)) {
                 date = new Date(dateInput); // Tenta converter outros tipos
            } else {
                 date = dateInput;
            }

            if (isNaN(date.getTime())) { // Verifica se a data é válida
                 console.warn("Utils.formatDate: Data inválida recebida:", dateInput);
                 return '';
            }

            // Formata a data garantindo que dia e mês tenham 2 dígitos
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0'); // Mês é base 0
            const year = date.getFullYear();
            return `${day}/${month}/${year}`;

        } catch (error) {
             console.error("Erro ao formatar data:", error, "Input:", dateInput);
             return '';
        }
    },

    /**
     * Formata uma data (objeto Date, Timestamp ou string dd/mm/aaaa) para o formato 'aaaa-mm-dd' (input[type=date]).
     * @param {Date | firebase.firestore.Timestamp | string | null | undefined} dateInput A data a ser formatada.
     * @returns {string} A data formatada como 'aaaa-mm-dd' ou '' se inválida.
     */
    formatDateForInput(dateInput) {
        if (!dateInput) return '';
         let date;
         try {
            if (dateInput instanceof firebase.firestore.Timestamp) {
                date = dateInput.toDate();
            } else if (typeof dateInput === 'string' && dateInput.includes('/')) {
                // Converte dd/mm/aaaa para aaaa-mm-dd
                const parts = dateInput.split('/');
                if (parts.length === 3) {
                     date = new Date(`${parts[2]}-${parts[1]}-${parts[0]}T00:00:00`);
                     if(isNaN(date)) throw new Error('Invalid dd/mm/aaaa string');
                } else {
                     throw new Error('Invalid dd/mm/aaaa format');
                }
            } else if (!(dateInput instanceof Date)) {
                 date = new Date(dateInput); // Tenta converter outros tipos (incluindo aaaa-mm-dd)
            } else {
                 date = dateInput;
            }

             if (isNaN(date.getTime())) {
                 console.warn("Utils.formatDateForInput: Data inválida recebida:", dateInput);
                 return '';
             }

             const year = date.getFullYear();
             const month = String(date.getMonth() + 1).padStart(2, '0');
             const day = String(date.getDate()).padStart(2, '0');
             return `${year}-${month}-${day}`;

         } catch (error) {
             console.error("Erro ao formatar data para input:", error, "Input:", dateInput);
             return '';
         }
    },

    /**
     * Obtém a data atual no formato 'aaaa-mm-dd'.
     * @returns {string} Data atual formatada.
     */
    getCurrentDateForInput() {
        return this.formatDateForInput(new Date());
    },

    /**
     * Obtém o mês e ano atual no formato 'aaaa-mm'.
     * @returns {string} Mês/ano atual formatado.
     */
    getCurrentMonthYear() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        return `${year}-${month}`;
    },

     /**
     * Formata um valor 'aaaa-mm' para exibição (ex: "Maio 2024").
     * @param {string} yearMonthString String no formato 'aaaa-mm'.
     * @returns {string} Mês por extenso e ano, ou a string original se inválida.
     */
     formatMonthYear(yearMonthString) {
        if (!yearMonthString || !/^\d{4}-\d{2}$/.test(yearMonthString)) {
            return yearMonthString || ''; // Retorna original ou vazio
        }
        const [year, month] = yearMonthString.split('-');
        const monthIndex = parseInt(month, 10) - 1;
        const monthNames = [
            'Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho',
            'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'
        ];
        if (monthIndex >= 0 && monthIndex < 12) {
            return `${monthNames[monthIndex]} ${year}`;
        }
        return yearMonthString; // Retorna original em caso de mês inválido
    },


    // --- Manipulação de Datas ---

    /**
     * Obtém o primeiro dia do mês para uma dada data.
     * @param {Date} date A data de referência.
     * @returns {Date} O primeiro dia do mês.
     */
    getFirstDayOfMonth(date) {
        return new Date(date.getFullYear(), date.getMonth(), 1);
    },

    /**
     * Obtém o último dia do mês para uma dada data.
     * @param {Date} date A data de referência.
     * @returns {Date} O último dia do mês.
     */
    getLastDayOfMonth(date) {
        return new Date(date.getFullYear(), date.getMonth() + 1, 0);
    },

     /**
     * Verifica se uma data (objeto Date ou Timestamp) pertence a um determinado mês/ano.
     * @param {Date | firebase.firestore.Timestamp} dateInput A data a ser verificada.
     * @param {string} yearMonth String no formato 'aaaa-mm'.
     * @returns {boolean} True se a data pertence ao mês/ano, false caso contrário.
     */
     isDateInMonth(dateInput, yearMonth) {
        if (!dateInput || !yearMonth || !/^\d{4}-\d{2}$/.test(yearMonth)) return false;

        let date;
        try {
             if (dateInput instanceof firebase.firestore.Timestamp) {
                date = dateInput.toDate();
            } else if (dateInput instanceof Date && !isNaN(dateInput)) {
                date = dateInput;
            } else {
                 return false; // Se não for um tipo válido, retorna falso
            }

             const [targetYear, targetMonth] = yearMonth.split('-').map(Number);
             return date.getFullYear() === targetYear && (date.getMonth() + 1) === targetMonth;

        } catch (error) {
             console.error("Erro em isDateInMonth:", error, "Input Date:", dateInput, "YearMonth:", yearMonth);
             return false;
        }
    },

    /**
     * Gera opções de mês/ano para um select dropdown.
     * @param {number} monthsBack Quantos meses para trás incluir. Padrão 12.
     * @param {number} monthsForward Quantos meses para frente incluir. Padrão 12.
     * @returns {Array<{value: string, label: string}>} Array de objetos com value ('aaaa-mm') e label ('Mês Ano').
     */
    generateMonthYearOptions(monthsBack = 12, monthsForward = 12) {
        const options = [];
        const now = new Date();
        const currentYear = now.getFullYear();
        const currentMonth = now.getMonth(); // 0-11

        for (let i = monthsForward; i >= -monthsBack; i--) {
            const date = new Date(currentYear, currentMonth - i, 1);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const monthName = date.toLocaleString('pt-BR', { month: 'long' });

            options.push({
                value: `${year}-${month}`,
                label: `${monthName.charAt(0).toUpperCase() + monthName.slice(1)} ${year}`
            });
        }
        return options;
    },


    // --- Manipulação do DOM ---

    /**
     * Atalho para document.getElementById.
     * @param {string} id O ID do elemento.
     * @returns {HTMLElement | null} O elemento encontrado ou null.
     */
    $: (id) => document.getElementById(id),

    /**
     * Atalho para document.querySelector.
     * @param {string} selector O seletor CSS.
     * @returns {Element | null} O primeiro elemento encontrado ou null.
     */
    qs: (selector) => document.querySelector(selector),

    /**
     * Atalho para document.querySelectorAll.
     * @param {string} selector O seletor CSS.
     * @returns {NodeListOf<Element>} Uma lista de nós (pode estar vazia).
     */
    qsa: (selector) => document.querySelectorAll(selector),

    /**
     * Adiciona uma classe a um elemento.
     * @param {Element | null} element O elemento.
     * @param {string} className A classe a ser adicionada.
     */
    addClass: (element, className) => element?.classList.add(className),

    /**
     * Remove uma classe de um elemento.
     * @param {Element | null} element O elemento.
     * @param {string} className A classe a ser removida.
     */
    removeClass: (element, className) => element?.classList.remove(className),

    /**
     * Alterna (adiciona/remove) uma classe de um elemento.
     * @param {Element | null} element O elemento.
     * @param {string} className A classe a ser alternada.
     * @param {boolean} [force] Se true, adiciona a classe; se false, remove.
     */
    toggleClass: (element, className, force) => element?.classList.toggle(className, force),

    /**
     * Define um atributo em um elemento.
     * @param {Element | null} element O elemento.
     * @param {string} attrName O nome do atributo.
     * @param {string} attrValue O valor do atributo.
     */
    setAttr: (element, attrName, attrValue) => element?.setAttribute(attrName, attrValue),

    /**
     * Remove um atributo de um elemento.
     * @param {Element | null} element O elemento.
     * @param {string} attrName O nome do atributo.
     */
    removeAttr: (element, attrName) => element?.removeAttribute(attrName),


    // --- Outras Utilidades ---

    /**
     * Gera um ID único simples (não criptograficamente seguro).
     * Útil para IDs temporários no front-end se necessário.
     * @returns {string} Um ID pseudo-aleatório.
     */
    generateSimpleId() {
        return `id_${Math.random().toString(36).substring(2, 9)}`;
    },

     /**
      * Copia um texto para a área de transferência.
      * @param {string} text Texto a ser copiado.
      * @returns {Promise<boolean>} True se sucesso, False se falha.
      */
     async copyToClipboard(text) {
        if (!navigator.clipboard) {
          console.warn("Clipboard API não suportada.");
          // Fallback (pode não funcionar em todos os contextos)
          try {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed"; // Fora da tela
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            return true;
          } catch (err) {
            console.error("Falha no fallback de cópia:", err);
            return false;
          }
        }
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch (err) {
          console.error("Falha ao copiar para a área de transferência:", err);
          return false;
        }
      },

      /**
       * "Debounce": Atrasa a execução de uma função até que um certo tempo
       * tenha passado sem que ela seja chamada novamente. Útil para eventos
       * como 'resize' ou 'input' para evitar execuções excessivas.
       * @param {Function} func Função a ser executada.
       * @param {number} delay Tempo de espera em milissegundos.
       * @returns {Function} Função "debounced".
       */
      debounce(func, delay) {
        let timeoutId;
        return function(...args) {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => {
            func.apply(this, args);
          }, delay);
        };
      },

};

// ===== FIM: BLOCO 21 ==============================

// ===== INÍCIO: BLOCO 22 ==============================
// ==== JAVASCRIPT - SERVIÇO FIREBASE (firebaseService.js) ====
// Depende de: config.js (para 'collections') e utils.js (para datas, etc.)

const FirebaseService = {

    /**
     * Obtém a referência a uma coleção específica.
     * Centraliza o acesso e verifica se a coleção está disponível.
     * @param {string} collectionName Nome da coleção (e.g., 'transactions').
     * @returns {firebase.firestore.CollectionReference | null} A referência da coleção ou null se houver erro.
     */
    getCollection(collectionName) {
        const collectionRef = collections[collectionName];
        if (!collectionRef) {
            console.error(`FirebaseService: Coleção '${collectionName}' não encontrada ou DB não inicializado.`);
            // Poderia lançar um erro ou retornar null dependendo da estratégia de erro
            return null;
        }
        return collectionRef;
    },

    // ============================================
    // === OPERAÇÕES CRUD - TRANSACTIONS =======
    // ============================================
    transactions: {

        /**
         * Adiciona uma nova transação ao Firestore.
         * Converte data string para Timestamp, adiciona createdAt.
         * @param {object} transactionData Objeto com os dados da transação.
         * @returns {Promise<string | null>} O ID do documento criado ou null em caso de erro.
         */
        async add(transactionData) {
            const collectionRef = FirebaseService.getCollection('transactions');
            if (!collectionRef) return null;

            try {
                const dataToSave = { ...transactionData };

                // Converter string de data para Timestamp do Firestore
                if (dataToSave.date && typeof dataToSave.date === 'string') {
                    // Cria objeto Date garantindo que seja interpretado como início do dia UTC
                    const dateObj = new Date(dataToSave.date + 'T00:00:00Z');
                    if (!isNaN(dateObj)) {
                        dataToSave.date = firebase.firestore.Timestamp.fromDate(dateObj);
                    } else {
                        console.warn("Data inválida fornecida para transação, usando data atual:", transactionData.date);
                        dataToSave.date = firebase.firestore.Timestamp.now(); // Fallback
                    }
                } else if (!(dataToSave.date instanceof firebase.firestore.Timestamp)) {
                     // Se não for string nem timestamp, assume que é Date ou inválido
                     dataToSave.date = dataToSave.date instanceof Date && !isNaN(dataToSave.date)
                        ? firebase.firestore.Timestamp.fromDate(dataToSave.date)
                        : firebase.firestore.Timestamp.now(); // Fallback
                }


                // Garantir que amount seja número
                if (dataToSave.amount) {
                    dataToSave.amount = parseFloat(dataToSave.amount) || 0;
                } else {
                    dataToSave.amount = 0;
                }

                // Adiciona timestamp de criação
                dataToSave.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                dataToSave.updatedAt = firebase.firestore.FieldValue.serverTimestamp(); // Inicialmente igual

                const docRef = await collectionRef.add(dataToSave);
                console.log("Transação adicionada com ID:", docRef.id);
                // TODO: Lógica para parcelamentos e recorrências seria chamada aqui
                return docRef.id;

            } catch (error) {
                console.error("Erro ao adicionar transação:", error, "Dados:", transactionData);
                // TODO: Mostrar erro para o usuário via Toast (será feito no uiComponents ou app.js)
                return null;
            }
        },

        /**
         * Atualiza uma transação existente no Firestore.
         * @param {string} id O ID do documento da transação.
         * @param {object} transactionUpdateData Objeto com os campos a serem atualizados.
         * @returns {Promise<boolean>} True se sucesso, false se erro.
         */
        async update(id, transactionUpdateData) {
            const collectionRef = FirebaseService.getCollection('transactions');
            if (!collectionRef || !id) return false;

            try {
                const dataToUpdate = { ...transactionUpdateData };

                // Converter string de data para Timestamp, se presente
                if (dataToUpdate.date && typeof dataToUpdate.date === 'string') {
                     const dateObj = new Date(dataToUpdate.date + 'T00:00:00Z');
                     if (!isNaN(dateObj)) {
                        dataToUpdate.date = firebase.firestore.Timestamp.fromDate(dateObj);
                    } else {
                         console.warn("Data inválida fornecida para atualização, campo 'date' ignorado:", transactionUpdateData.date);
                         delete dataToUpdate.date; // Não atualiza a data se inválida
                    }
                } else if (dataToUpdate.date && !(dataToUpdate.date instanceof firebase.firestore.Timestamp)) {
                     // Se for Date, converte, senão ignora
                     if (dataToUpdate.date instanceof Date && !isNaN(dataToUpdate.date)) {
                         dataToUpdate.date = firebase.firestore.Timestamp.fromDate(dataToUpdate.date);
                     } else {
                         delete dataToUpdate.date;
                     }
                }

                 // Garantir que amount seja número, se presente
                if (dataToUpdate.amount !== undefined) {
                    dataToUpdate.amount = parseFloat(dataToUpdate.amount) || 0;
                }

                // Adiciona timestamp de atualização
                dataToUpdate.updatedAt = firebase.firestore.FieldValue.serverTimestamp();

                // Remove o ID do objeto de atualização, se ele existir acidentalmente
                delete dataToUpdate.id;
                delete dataToUpdate.createdAt; // Não se deve atualizar createdAt

                await collectionRef.doc(id).update(dataToUpdate);
                console.log("Transação atualizada com ID:", id);
                return true;

            } catch (error) {
                console.error("Erro ao atualizar transação:", error, "ID:", id, "Dados:", transactionUpdateData);
                return false;
            }
        },

        /**
         * Remove uma transação do Firestore.
         * @param {string} id O ID do documento da transação.
         * @returns {Promise<boolean>} True se sucesso, false se erro.
         */
        async remove(id) {
            const collectionRef = FirebaseService.getCollection('transactions');
            if (!collectionRef || !id) return false;

            try {
                // TODO: Adicionar lógica de confirmação inteligente se necessário
                //       (e.g., verificar se é parte de recorrência/parcelamento antes de excluir)
                await collectionRef.doc(id).delete();
                console.log("Transação removida com ID:", id);
                return true;
            } catch (error) {
                console.error("Erro ao remover transação:", error, "ID:", id);
                return false;
            }
        },

        /**
         * Obtém uma única transação pelo ID.
         * @param {string} id O ID do documento.
         * @returns {Promise<object | null>} O objeto da transação (com id) ou null se não encontrada/erro.
         */
        async getById(id) {
            const collectionRef = FirebaseService.getCollection('transactions');
            if (!collectionRef || !id) return null;

            try {
                const docSnap = await collectionRef.doc(id).get();
                if (docSnap.exists) {
                    return { id: docSnap.id, ...docSnap.data() };
                } else {
                    console.warn("Transação não encontrada com ID:", id);
                    return null;
                }
            } catch (error) {
                console.error("Erro ao obter transação por ID:", error, "ID:", id);
                return null;
            }
        },

        /**
         * Obtém todas as transações (cuidado com performance em grandes datasets).
         * Pode ser útil para cálculos iniciais, mas prefira queries filtradas.
         * @returns {Promise<Array<object>>} Array de objetos de transação (com id).
         */
        async getAll() {
            const collectionRef = FirebaseService.getCollection('transactions');
            if (!collectionRef) return [];

            try {
                // Ordenar por data descendente como padrão pode ser útil
                const querySnapshot = await collectionRef.orderBy("date", "desc").get();
                const transactions = [];
                querySnapshot.forEach((doc) => {
                    transactions.push({ id: doc.id, ...doc.data() });
                });
                console.log(`Obtidas ${transactions.length} transações (getAll).`);
                return transactions;
            } catch (error) {
                console.error("Erro ao obter todas as transações:", error);
                return [];
            }
        },

        /**
         * Obtém transações dentro de um intervalo de datas.
         * @param {Date | firebase.firestore.Timestamp} startDate Data inicial.
         * @param {Date | firebase.firestore.Timestamp} endDate Data final.
         * @returns {Promise<Array<object>>} Array de objetos de transação.
         */
        async getByDateRange(startDate, endDate) {
            const collectionRef = FirebaseService.getCollection('transactions');
            if (!collectionRef || !startDate || !endDate) return [];

            try {
                // Garante que as datas sejam Timestamps do Firebase
                const startTimestamp = (startDate instanceof firebase.firestore.Timestamp)
                    ? startDate : firebase.firestore.Timestamp.fromDate(startDate);
                const endTimestamp = (endDate instanceof firebase.firestore.Timestamp)
                    ? endDate : firebase.firestore.Timestamp.fromDate(endDate);

                const querySnapshot = await collectionRef
                    .where('date', '>=', startTimestamp)
                    .where('date', '<=', endTimestamp)
                    .orderBy('date', 'desc') // Ordenar dentro do intervalo
                    .get();

                const transactions = [];
                querySnapshot.forEach((doc) => {
                    transactions.push({ id: doc.id, ...doc.data() });
                });
                console.log(`Obtidas ${transactions.length} transações no intervalo.`);
                return transactions;

            } catch (error) {
                console.error("Erro ao obter transações por intervalo de data:", error, "Datas:", startDate, endDate);
                return [];
            }
        },

         /**
         * Obtém transações de um mês/ano específico.
         * @param {string} yearMonth String no formato 'aaaa-mm'.
         * @returns {Promise<Array<object>>} Array de objetos de transação.
         */
         async getByMonth(yearMonth) {
            if (!yearMonth || !/^\d{4}-\d{2}$/.test(yearMonth)) {
                 console.error("Formato de mês/ano inválido:", yearMonth);
                 return [];
            }
            const [year, month] = yearMonth.split('-').map(Number);
            // Cria data inicial e final do mês em UTC para evitar problemas de fuso
            const startDate = new Date(Date.UTC(year, month - 1, 1));
            const endDate = new Date(Date.UTC(year, month, 0, 23, 59, 59, 999)); // Último milissegundo do mês

            // Converte para Timestamps do Firebase
            const startTimestamp = firebase.firestore.Timestamp.fromDate(startDate);
            const endTimestamp = firebase.firestore.Timestamp.fromDate(endDate);

            console.log(`Buscando transações para ${yearMonth} (UTC: ${startDate.toISOString()} a ${endDate.toISOString()})`);
            return this.getByDateRange(startTimestamp, endTimestamp);
         },

         // TODO: Adicionar mais funções de query conforme necessário
         // (e.g., getByCategory, getByPerson, getByCard, etc.)
         // TODO: Implementar lógica para criar/gerenciar parcelamentos e recorrências
         //       ao adicionar/editar transações.

    },

    // =================================================
    // === OPERAÇÕES CRUD - CATEGORIES (Exemplo) ======
    // =================================================
    // Adicione aqui as funções para categories, persons, cards, goals, contributions
    // seguindo um padrão similar ao de transactions (add, update, remove, getById, getAll, etc.)
    // Exemplo para getAll categories:
    categories: {
         async getAll() {
             const collectionRef = FirebaseService.getCollection('categories');
             if (!collectionRef) return [];
             try {
                 const querySnapshot = await collectionRef.orderBy("name", "asc").get();
                 const categories = [];
                 querySnapshot.forEach((doc) => {
                     categories.push({ id: doc.id, ...doc.data() });
                 });
                 return categories;
             } catch (error) {
                 console.error("Erro ao obter categorias:", error);
                 return [];
             }
         },
         // Adicionar add, update, remove, getById...
    },

     persons: {
         async getAll() {
             const collectionRef = FirebaseService.getCollection('persons');
             if (!collectionRef) return [];
             try {
                 const querySnapshot = await collectionRef.orderBy("name", "asc").get();
                 const persons = [];
                 querySnapshot.forEach((doc) => {
                     persons.push({ id: doc.id, ...doc.data() });
                 });
                 return persons;
             } catch (error) {
                 console.error("Erro ao obter pessoas:", error);
                 return [];
             }
         },
          // Adicionar add, update, remove, getById...
     },

     cards: {
          async getAll() {
              const collectionRef = FirebaseService.getCollection('cards');
              if (!collectionRef) return [];
              try {
                  const querySnapshot = await collectionRef.orderBy("name", "asc").get();
                  const cards = [];
                  querySnapshot.forEach((doc) => {
                      cards.push({ id: doc.id, ...doc.data() });
                  });
                  return cards;
              } catch (error) {
                  console.error("Erro ao obter cartões:", error);
                  return [];
              }
          },
           // Adicionar add, update, remove, getById...
      },

      goals: {
          async getAll() {
              const collectionRef = FirebaseService.getCollection('goals');
              if (!collectionRef) return [];
              try {
                  // Ordenar talvez por prazo?
                  const querySnapshot = await collectionRef.orderBy("deadline", "asc").get();
                  const goals = [];
                  querySnapshot.forEach((doc) => {
                      goals.push({ id: doc.id, ...doc.data() });
                  });
                  return goals;
              } catch (error) {
                  console.error("Erro ao obter metas:", error);
                  return [];
              }
          },
           // Adicionar add, update, remove, getById...
           // Adicionar getContributionsByGoalId
      },

      contributions: {
            // Adicionar add, update, remove...
            async getByGoalId(goalId) {
                const collectionRef = FirebaseService.getCollection('contributions');
                 if (!collectionRef || !goalId) return [];
                 try {
                     const querySnapshot = await collectionRef
                        .where('goalId', '==', goalId)
                        .orderBy('date', 'desc')
                        .get();
                     const contributions = [];
                     querySnapshot.forEach((doc) => {
                        contributions.push({ id: doc.id, ...doc.data() });
                     });
                     return contributions;
                 } catch (error) {
                     console.error("Erro ao obter aportes por meta:", error, "Goal ID:", goalId);
                     return [];
                 }
            }
      }

};

// ===== FIM: BLOCO 22 ==============================

// ===== INÍCIO: BLOCO 23 ==============================
// ==== JAVASCRIPT - COMPONENTES UI (uiComponents.js) - Parte 1 ====
// Depende de: utils.js

const UIComponents = {

    // --- Seletores de Elementos Comuns ---
    // Armazena referências a elementos frequentemente usados para evitar buscas repetidas no DOM.
    elements: {
        sidebar: Utils.$('sidebar'),
        sidebarToggleMobile: Utils.$('sidebar-toggle-mobile'),
        sidebarPinToggle: Utils.$('sidebar-pin-toggle'),
        mainContent: Utils.$('main-content'),
        contentArea: Utils.$('content-area'),
        currentModuleTitle: Utils.$('current-module-title'),
        themeToggleBtn: Utils.$('theme-toggle'),
        themeIconMoon: Utils.qs('.theme-icon-moon'),
        themeIconSun: Utils.qs('.theme-icon-sun'),
        overlay: Utils.$('overlay'),
        modalContainer: Utils.$('modal-container'),
        toastContainer: Utils.$('toast-container'),
        loadingSpinner: Utils.$('loading-spinner'),
        navItems: Utils.qsa('.nav-item'),
        globalMonthYearFilter: Utils.$('global-month-year-filter'),
        globalPersonFilter: Utils.$('global-person-filter'),
        headerFiltersContainer: Utils.$('header-filters-container'),
        newTransactionBtn: Utils.$('new-transaction-btn'),
        // Adicionar outros seletores comuns aqui conforme necessário
    },

    // --- Estado da UI ---
    state: {
        isSidebarPinned: localStorage.getItem('sidebarPinned') === 'true',
        isSidebarOpenMobile: false,
        currentTheme: localStorage.getItem('theme') || 'light', // Padrão 'light'
        activeModal: null, // Mantém referência ao modal ativo
    },

    // --- Inicialização da UI ---
    /**
     * Inicializa os componentes e listeners da UI principal.
     */
    init() {
        console.log("UIComponents: Inicializando...");
        this.setupTheme();
        this.setupSidebar();
        this.setupGlobalFilters();
        this.setupModalSystem();
        this.setupNavMenu();
        this.setupActionButtons();
        console.log("UIComponents: Inicialização concluída.");
    },

    // --- Gerenciamento de Tema (Claro/Escuro) ---
    /**
     * Aplica o tema salvo e configura o botão de toggle.
     */
    setupTheme() {
        document.body.dataset.theme = this.state.currentTheme;
        this.updateThemeIcon();

        this.elements.themeToggleBtn?.addEventListener('click', () => {
            this.state.currentTheme = (this.state.currentTheme === 'light') ? 'dark' : 'light';
            document.body.dataset.theme = this.state.currentTheme;
            localStorage.setItem('theme', this.state.currentTheme);
            this.updateThemeIcon();
            // Disparar evento customizado se outros componentes precisarem saber da mudança
            // document.dispatchEvent(new CustomEvent('themeChanged', { detail: { theme: this.state.currentTheme } }));
        });
    },

    /**
     * Atualiza o ícone do botão de tema (lua/sol).
     */
    updateThemeIcon() {
        if (this.elements.themeIconMoon && this.elements.themeIconSun) {
            this.elements.themeIconMoon.style.display = (this.state.currentTheme === 'light') ? 'block' : 'none';
            this.elements.themeIconSun.style.display = (this.state.currentTheme === 'dark') ? 'block' : 'none';
        }
    },

    // --- Gerenciamento da Sidebar ---
    /**
     * Configura os botões de toggle da sidebar (mobile e pin) e estado inicial.
     */
    setupSidebar() {
        // Estado inicial do pin
        if (this.state.isSidebarPinned && window.innerWidth > 992) { // Só aplica pin em desktop
            Utils.addClass(this.elements.sidebar, 'pinned');
             Utils.removeClass(this.elements.sidebar, 'collapsed'); // Garante que não esteja collapsed
        } else {
            Utils.addClass(this.elements.sidebar, 'collapsed'); // Começa recolhida por padrão em desktop
             Utils.removeClass(this.elements.sidebar, 'pinned');
        }
        this.updateSidebarToggleButtonState();


        // Toggle Mobile
        this.elements.sidebarToggleMobile?.addEventListener('click', () => {
            this.state.isSidebarOpenMobile = !this.state.isSidebarOpenMobile;
            Utils.toggleClass(this.elements.sidebar, 'open', this.state.isSidebarOpenMobile);
            Utils.toggleClass(this.elements.overlay, 'active', this.state.isSidebarOpenMobile);
        });

        // Fechar sidebar mobile ao clicar no overlay
        this.elements.overlay?.addEventListener('click', () => {
            if (this.state.isSidebarOpenMobile) {
                this.state.isSidebarOpenMobile = false;
                Utils.removeClass(this.elements.sidebar, 'open');
                Utils.removeClass(this.elements.overlay, 'active');
            }
        });

        // Pin/Unpin (Desktop)
        this.elements.sidebarPinToggle?.addEventListener('click', () => {
            if (window.innerWidth <= 992) return; // Não funciona em mobile

            this.state.isSidebarPinned = !this.state.isSidebarPinned;
            localStorage.setItem('sidebarPinned', this.state.isSidebarPinned);
            Utils.toggleClass(this.elements.sidebar, 'pinned', this.state.isSidebarPinned);
            Utils.toggleClass(this.elements.sidebar, 'collapsed', !this.state.isSidebarPinned);
             this.updateSidebarToggleButtonState();
        });

         // Fechar/Abrir sidebar no hover (se não estiver pinned)
         this.elements.sidebar?.addEventListener('mouseenter', () => {
             if (!this.state.isSidebarPinned && window.innerWidth > 992) {
                 Utils.removeClass(this.elements.sidebar, 'collapsed');
             }
         });
         this.elements.sidebar?.addEventListener('mouseleave', () => {
             if (!this.state.isSidebarPinned && window.innerWidth > 992) {
                 Utils.addClass(this.elements.sidebar, 'collapsed');
             }
         });
    },

    /**
     * Atualiza o estado visual (ativo/inativo) do botão de pin da sidebar.
     */
    updateSidebarToggleButtonState() {
         if(this.elements.sidebarPinToggle) {
             Utils.toggleClass(this.elements.sidebarPinToggle, 'active', this.state.isSidebarPinned);
             this.elements.sidebarPinToggle.setAttribute('aria-pressed', this.state.isSidebarPinned);
         }
     },


    // --- Gerenciamento de Modais ---
    /**
     * Configura listeners para abrir/fechar modais.
     */
    setupModalSystem() {
        // Listener para fechar modal clicando no botão [data-dismiss="modal"]
        this.elements.modalContainer?.addEventListener('click', (event) => {
            if (event.target.closest('[data-dismiss="modal"]')) {
                this.closeModal();
            }
        });

        // Listener para fechar modal clicando no backdrop (overlay)
         this.elements.modalContainer?.addEventListener('click', (event) => {
             // Verifica se o clique foi diretamente no container (que age como overlay aqui)
             if (event.target === this.elements.modalContainer) {
                 this.closeModal();
             }
         });


        // Listener para fechar modal com a tecla ESC
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && this.state.activeModal) {
                this.closeModal();
            }
        });
    },

    /**
     * Abre um modal específico pelo seu ID.
     * @param {string} modalId O ID do elemento modal.
     */
    openModal(modalId) {
        const modalElement = Utils.$(modalId);
        if (!modalElement || !this.elements.modalContainer) return;

        // Fecha qualquer modal que já esteja aberto
        if (this.state.activeModal) {
            this.closeModal(this.state.activeModal); // Fecha o modal anterior sem esperar
        }

        this.state.activeModal = modalElement;
        Utils.addClass(this.elements.modalContainer, 'active'); // Mostra o backdrop/container

        // Força reflow para garantir que a transição ocorra
        // void modalElement.offsetWidth; // Comentado - a classe 'active' no container já dispara a animação

        // Adiciona 'active' ao modal específico (a animação é controlada pelo CSS)
        // Utils.addClass(modalElement, 'active'); // Não é mais necessário, CSS usa #modal-container.active .modal

        modalElement.hidden = false; // Torna o modal visível para acessibilidade
        modalElement.setAttribute('aria-hidden', 'false');

        // Foca no primeiro elemento focável dentro do modal
        const focusableElements = modalElement.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        focusableElements[0]?.focus();

        console.log(`Modal aberto: #${modalId}`);
    },

    /**
     * Fecha o modal ativo no momento.
     */
    closeModal() {
        if (!this.state.activeModal || !this.elements.modalContainer) return;

        const modalToClose = this.state.activeModal;
        const modalId = modalToClose.id;

        Utils.removeClass(this.elements.modalContainer, 'active'); // Esconde o backdrop/container

        modalToClose.hidden = true; // Esconde para acessibilidade
        modalToClose.setAttribute('aria-hidden', 'true');

        this.state.activeModal = null;
        console.log(`Modal fechado: #${modalId}`);

        // Opcional: Retornar o foco para o elemento que abriu o modal (requer salvar a referência)
    },


    // --- Gerenciamento de Toasts (Notificações) ---
    /**
     * Exibe uma notificação toast.
     * @param {string} message A mensagem principal.
     * @param {object} options Opções: type ('success', 'danger', 'warning', 'info' - padrão 'info'),
     *                         title (título opcional), duration (ms - padrão 5000).
     */
    showToast(message, options = {}) {
        if (!this.elements.toastContainer) return;

        const { type = 'info', title = null, duration = 5000 } = options;

        const toastId = `toast-${Utils.generateSimpleId()}`;
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.id = toastId;
        toast.setAttribute('role', 'alert');
        toast.setAttribute('aria-live', 'assertive');

        const iconClass = {
            success: 'fa-check-circle',
            danger: 'fa-times-circle',
            warning: 'fa-exclamation-triangle',
            info: 'fa-info-circle'
        }[type];

        let toastHTML = `
            <div class="toast-icon-wrapper">
                <i class="fas ${iconClass} toast-icon" aria-hidden="true"></i>
            </div>
            <div class="toast-content">
                ${title ? `<div class="toast-title">${title}</div>` : ''}
                <div class="toast-message">${message}</div>
            </div>
            <button type="button" class="toast-close-btn" aria-label="Fechar notificação">
                <i class="fas fa-times" aria-hidden="true"></i>
            </button>
            ${duration > 0 ? `<div class="toast-progress" style="animation-duration: ${duration}ms"></div>` : ''}
        `;

        toast.innerHTML = toastHTML;

        // Adiciona evento para fechar o toast ao clicar no botão
        toast.querySelector('.toast-close-btn')?.addEventListener('click', () => {
            this.closeToast(toast);
        });

        // Adiciona o toast ao container
        this.elements.toastContainer.appendChild(toast);

        // Força reflow para iniciar a animação de entrada
        void toast.offsetWidth;
        Utils.addClass(toast, 'show');

        // Configura timer para fechar automaticamente (se duration > 0)
        if (duration > 0) {
            setTimeout(() => {
                this.closeToast(toast);
            }, duration);
        }
    },

    /**
     * Fecha um toast específico.
     * @param {HTMLElement} toastElement O elemento toast a ser fechado.
     */
    closeToast(toastElement) {
        if (!toastElement || !toastElement.classList.contains('toast')) return;

        Utils.removeClass(toastElement, 'show');
        // Espera a animação de saída terminar antes de remover o elemento
        setTimeout(() => {
            toastElement.remove();
        }, 400); // Duração da animação CSS + pequena margem
    },


    // --- Funções a serem adicionadas na Parte 2 ---
    // setupNavMenu
    // setupGlobalFilters
    // setupActionButtons
    // updateModuleTitle
    // showLoading / hideLoading
    // renderContent
    // setupForm (para validação, etc.)
    // ... e manipuladores específicos de componentes (selectores de ícone/avatar)

};

// --- Inicialização da UI quando o DOM estiver pronto ---
// document.addEventListener('DOMContentLoaded', () => UIComponents.init());
// A inicialização será chamada pelo app.js principal

// ===== FIM: BLOCO 23 ==============================

// ===== INÍCIO: BLOCO 24 ==============================
// ==== JAVASCRIPT - COMPONENTES UI (uiComponents.js) - Parte 2 ====
// Continuação do objeto UIComponents...

const UIComponents = {
    // ... (código do Bloco 23 - elements, state, init, setupTheme, setupSidebar, setupModalSystem, openModal, closeModal, showToast, closeToast) ...

    // --- Gerenciamento da Navegação Principal ---
    /**
     * Configura os listeners para os itens do menu de navegação.
     */
    setupNavMenu() {
        this.elements.navItems.forEach(item => {
            item.addEventListener('click', (event) => {
                event.preventDefault(); // Previne comportamento padrão se for link <a>

                // Não faz nada se já for o item ativo
                if (item.classList.contains('active')) {
                    // Se estiver em mobile, fecha a sidebar ao clicar no item ativo
                    if (this.state.isSidebarOpenMobile) {
                         this.closeMobileSidebar();
                    }
                    return;
                }


                // Obtém o ID do módulo a ser carregado
                const moduleName = item.dataset.module; // e.g., 'dashboard', 'settings'
                if (!moduleName) {
                    console.error("Item de navegação sem 'data-module' definido:", item);
                    return;
                }

                 // Atualiza o item ativo no menu
                 this.setActiveNavItem(moduleName);

                // Fecha a sidebar se estiver em modo mobile
                 this.closeMobileSidebar();

                // Chama a função para carregar o módulo correspondente (será definida no app.js)
                // Dispara um evento customizado para o app.js tratar
                document.dispatchEvent(new CustomEvent('navigateToModule', {
                    detail: { moduleName: moduleName }
                }));
            });
        });
    },

     /**
     * Fecha a sidebar se estiver aberta em modo mobile.
     */
     closeMobileSidebar() {
        if (this.state.isSidebarOpenMobile) {
            this.state.isSidebarOpenMobile = false;
            Utils.removeClass(this.elements.sidebar, 'open');
            Utils.removeClass(this.elements.overlay, 'active');
        }
    },

    /**
     * Marca um item do menu como ativo e desmarca os outros.
     * @param {string} moduleName O nome do módulo ('data-module') a ser ativado.
     */
    setActiveNavItem(moduleName) {
         this.elements.navItems.forEach(navItem => {
            Utils.toggleClass(navItem, 'active', navItem.dataset.module === moduleName);
         });
    },

    // --- Atualização do Título do Módulo ---
    /**
     * Atualiza o título exibido no header do conteúdo principal.
     * @param {string} title O novo título a ser exibido.
     */
    updateModuleTitle(title) {
        if (this.elements.currentModuleTitle) {
            this.elements.currentModuleTitle.textContent = title;
        }
    },

    // --- Gerenciamento de Filtros Globais ---
    /**
     * Popula e configura os listeners para os filtros globais no header.
     */
    setupGlobalFilters() {
        // 1. Popular Filtro Mês/Ano
        const monthYearOptions = Utils.generateMonthYearOptions(12, 3); // 12 meses passados, 3 futuros
        const monthSelect = this.elements.globalMonthYearFilter;
        if (monthSelect) {
            monthSelect.innerHTML = ''; // Limpa opções antigas
            monthYearOptions.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.label;
                monthSelect.appendChild(option);
            });
            // Define o mês/ano atual como padrão
            monthSelect.value = Utils.getCurrentMonthYear();

            // Adiciona listener para mudança
             monthSelect.addEventListener('change', () => {
                 // Dispara evento para o módulo ativo reagir à mudança
                 document.dispatchEvent(new CustomEvent('globalFilterChanged', {
                    detail: { filterType: 'monthYear', value: monthSelect.value }
                 }));
            });
        }

         // 2. Popular Filtro de Pessoas (inicialmente com "Todas")
         // A função para popular com dados do Firebase será chamada pelo app.js após carregar os dados
         const personSelect = this.elements.globalPersonFilter;
         if(personSelect) {
             personSelect.addEventListener('change', () => {
                 // Dispara evento para o módulo ativo reagir à mudança
                 document.dispatchEvent(new CustomEvent('globalFilterChanged', {
                    detail: { filterType: 'person', value: personSelect.value }
                 }));
            });
         }

        // 3. Mostrar/Esconder container de filtros (pode ser mais complexo depois)
         // Por enquanto, sempre visível em desktop
         if (this.elements.headerFiltersContainer) {
            // Lógica futura para esconder/mostrar filtros dependendo do módulo pode ir aqui
         }
    },

     /**
      * Popula o select global de pessoas com dados vindos do Firebase.
      * @param {Array<object>} persons Array de objetos de pessoa (com id e name).
      */
     populateGlobalPersonFilter(persons) {
        const select = this.elements.globalPersonFilter;
        if (!select) return;

        // Guarda o valor selecionado atualmente
        const currentSelectedValue = select.value;

        // Limpa opções existentes (exceto a primeira "Todas as Pessoas")
        while (select.options.length > 1) {
            select.remove(1);
        }

        // Adiciona pessoas como opções
        persons.forEach(person => {
            const option = document.createElement('option');
            option.value = person.id;
            option.textContent = person.name;
            select.appendChild(option);
        });

        // Restaura o valor selecionado se ainda existir, senão volta para 'all'
        if (select.querySelector(`option[value="${currentSelectedValue}"]`)) {
             select.value = currentSelectedValue;
        } else {
             select.value = 'all'; // Volta para o padrão se a pessoa selecionada foi removida
        }
     },


    // --- Gerenciamento de Botões de Ação Globais ---
    /**
     * Configura listeners para botões de ação principais (ex: Nova Transação).
     */
    setupActionButtons() {
        this.elements.newTransactionBtn?.addEventListener('click', () => {
            // Limpa o formulário antes de abrir (a lógica detalhada ficará no app.js ou módulo)
             App.prepareTransactionModal(); // Chama função do app principal
             this.openModal('transaction-modal');
        });

        // Configurar outros botões globais aqui, se houver
    },


    // --- Controle de Carregamento ---
    /**
     * Exibe o spinner de carregamento principal na área de conteúdo.
     */
    showLoading() {
        if (this.elements.loadingSpinner) {
            Utils.addClass(this.elements.loadingSpinner, 'active');
        }
    },

    /**
     * Esconde o spinner de carregamento principal.
     */
    hideLoading() {
         if (this.elements.loadingSpinner) {
            Utils.removeClass(this.elements.loadingSpinner, 'active');
        }
    },

    // --- Renderização de Conteúdo ---
    /**
     * Limpa a área de conteúdo e insere novo HTML.
     * @param {string | Node} content O HTML ou nó DOM a ser inserido.
     */
    renderContent(content) {
        if (!this.elements.contentArea) return;

        // Limpa conteúdo anterior
        this.elements.contentArea.innerHTML = '';

        // Insere novo conteúdo
        if (typeof content === 'string') {
            this.elements.contentArea.innerHTML = content;
        } else if (content instanceof Node) {
            this.elements.contentArea.appendChild(content);
        }

        // Garante que o scroll volte ao topo ao carregar novo conteúdo
        this.elements.contentArea.scrollTop = 0;
    },

     /**
     * Renderiza uma mensagem de erro na área de conteúdo.
     * @param {string} message Mensagem de erro a ser exibida.
     * @param {string} [details=''] Detalhes adicionais (opcional).
     */
     renderError(message, details = '') {
        const errorHTML = `
            <div class="error-message-container card">
                 <div class="card-body">
                    <h4 class="error-title"><i class="fas fa-exclamation-triangle"></i> Erro ao Carregar Conteúdo</h4>
                    <p class="error-text">${message}</p>
                    ${details ? `<pre class="error-details">${details}</pre>` : ''}
                    <button class="btn btn-secondary btn-sm" onclick="location.reload()">Recarregar Página</button>
                 </div>
            </div>
        `;
        this.renderContent(errorHTML);
     },

      // --- Funções a serem adicionadas na Parte 3 ---
      // setupFormValidation
      // setupIconPicker
      // setupAvatarPicker
      // ...

}; // Fim do objeto UIComponents (Importante!)

// ===== FIM: BLOCO 24 ==============================

// ===== INÍCIO: BLOCO 25 ==============================
// ==== JAVASCRIPT - COMPONENTES UI (uiComponents.js) - Parte 3 ====
// Continuação do objeto UIComponents...

const UIComponents = {
    // ... (código dos Blocos 23 e 24) ...

    // --- Gerenciamento de Seletores (Ícone / Avatar) ---

    /**
     * Inicializa um seletor de ícones genérico.
     * @param {string} containerId ID do container do seletor (e.g., 'category-icon-selector').
     * @param {string} buttonId ID do botão que abre o dropdown.
     * @param {string} dropdownId ID do dropdown que contém os ícones.
     * @param {string} inputId ID do input hidden que armazena o valor selecionado.
     * @param {string} displayId ID do span que exibe o ícone selecionado no botão.
     * @param {Array<string>} iconList Array com as classes Font Awesome dos ícones (e.g., ['fa-tag', 'fa-home']).
     */
    setupIconPicker(buttonId, dropdownId, inputId, displayId, iconList) {
        const button = Utils.$(buttonId);
        const dropdown = Utils.$(dropdownId);
        const input = Utils.$(inputId);
        const display = Utils.$(displayId);

        if (!button || !dropdown || !input || !display || !iconList) {
            console.warn("setupIconPicker: Elementos não encontrados ou lista de ícones vazia para:", buttonId);
            return;
        }

        // 1. Popular Dropdown
        dropdown.innerHTML = ''; // Limpa antes de popular
        iconList.forEach(iconClass => {
            const option = document.createElement('div');
            option.className = 'icon-option';
            option.setAttribute('role', 'option');
            option.dataset.icon = iconClass;
            option.innerHTML = `<i class="fas ${iconClass}" aria-hidden="true"></i>`;
            option.setAttribute('aria-label', iconClass.replace('fa-', '')); // Nome simples para acessibilidade
            option.tabIndex = 0; // Torna focável

            // Marca como selecionado se for o valor atual do input
            if (input.value === iconClass) {
                 option.classList.add('selected');
                 option.setAttribute('aria-selected', 'true');
            } else {
                 option.setAttribute('aria-selected', 'false');
            }


            // Evento de clique na opção
            option.addEventListener('click', () => {
                this.selectIcon(option, input, display, dropdown);
            });
             // Evento de teclado (Enter/Space)
            option.addEventListener('keydown', (event) => {
                 if (event.key === 'Enter' || event.key === ' ') {
                     event.preventDefault();
                     this.selectIcon(option, input, display, dropdown);
                 }
            });

            dropdown.appendChild(option);
        });

        // 2. Abrir/Fechar Dropdown com Botão
        button.addEventListener('click', (event) => {
            event.stopPropagation(); // Previne que o clique feche imediatamente
            const isVisible = dropdown.classList.toggle('visible');
            button.setAttribute('aria-expanded', isVisible);
            dropdown.hidden = !isVisible;
            if(isVisible) {
                 // Foca na opção selecionada ou na primeira opção
                 const selectedOption = dropdown.querySelector('.icon-option.selected') || dropdown.querySelector('.icon-option');
                 selectedOption?.focus();
            }
        });

        // 3. Fechar Dropdown ao Clicar Fora
        document.addEventListener('click', (event) => {
            if (!button.contains(event.target) && !dropdown.contains(event.target) && dropdown.classList.contains('visible')) {
                dropdown.classList.remove('visible');
                button.setAttribute('aria-expanded', 'false');
                 dropdown.hidden = true;
            }
        });
         // 4. Fechar Dropdown com ESC
         dropdown.addEventListener('keydown', (event) => {
             if (event.key === 'Escape') {
                 dropdown.classList.remove('visible');
                 button.setAttribute('aria-expanded', 'false');
                 dropdown.hidden = true;
                 button.focus(); // Devolve o foco ao botão
             }
         });
    },

    /**
     * Função auxiliar para selecionar um ícone.
     * @param {HTMLElement} selectedOption O elemento da opção clicada/selecionada.
     * @param {HTMLInputElement} input O input hidden para guardar o valor.
     * @param {HTMLElement} display O span para exibir o ícone no botão.
     * @param {HTMLElement} dropdown O elemento dropdown.
     */
    selectIcon(selectedOption, input, display, dropdown) {
        const selectedIconClass = selectedOption.dataset.icon;

        // Atualiza o input hidden
        input.value = selectedIconClass;

        // Atualiza o display no botão
        display.innerHTML = `<i class="fas ${selectedIconClass}" aria-hidden="true"></i>`;

        // Atualiza visualmente a seleção no dropdown
        dropdown.querySelectorAll('.icon-option').forEach(opt => {
            Utils.toggleClass(opt, 'selected', opt === selectedOption);
             opt.setAttribute('aria-selected', opt === selectedOption);
        });

        // Fecha o dropdown
        dropdown.classList.remove('visible');
         dropdown.parentElement.querySelector('.icon-selector-button').setAttribute('aria-expanded', 'false'); // Acha o botão relativo
         dropdown.hidden = true;
         dropdown.parentElement.querySelector('.icon-selector-button').focus(); // Foca no botão
    },


     /**
     * Inicializa um seletor de avatar genérico.
     * @param {string} gridId ID da div que contém as opções de avatar.
     * @param {string} displayId ID do elemento que mostra o avatar selecionado.
     * @param {string} inputColorId ID do input hidden para a classe de cor do avatar.
     * @param {Array<string>} avatarColorClasses Array com as classes de cor (e.g., ['avatar-bg-1', 'avatar-bg-2']).
     */
     setupAvatarPicker(gridId, displayId, inputColorId, avatarColorClasses) {
        const grid = Utils.$(gridId);
        const display = Utils.$(displayId);
        const inputColor = Utils.$(inputColorId);

        if (!grid || !display || !inputColor || !avatarColorClasses) {
            console.warn("setupAvatarPicker: Elementos não encontrados ou lista de classes vazia para:", gridId);
            return;
        }

        // 1. Popular Grid
        grid.innerHTML = ''; // Limpa antes
        avatarColorClasses.forEach(colorClass => {
            const option = document.createElement('div');
            option.className = `avatar avatar-md avatar-option ${colorClass}`; // Usa tamanho md por padrão
            option.dataset.colorClass = colorClass;
            option.setAttribute('role', 'radio'); // Comportamento de seleção única
            option.tabIndex = 0; // Focável

            // Marca como selecionado se for o valor atual
            if (inputColor.value === colorClass) {
                option.classList.add('selected');
                option.setAttribute('aria-checked', 'true');
            } else {
                 option.setAttribute('aria-checked', 'false');
            }

            // Evento de clique
            option.addEventListener('click', () => {
                this.selectAvatar(option, inputColor, display, grid);
            });
             // Evento de teclado (Enter/Space)
             option.addEventListener('keydown', (event) => {
                 if (event.key === 'Enter' || event.key === ' ') {
                     event.preventDefault();
                     this.selectAvatar(option, inputColor, display, grid);
                 }
            });

            grid.appendChild(option);
        });

        // 2. Atualizar display inicial (caso já haja um valor no input)
         const initialColor = inputColor.value || avatarColorClasses[0]; // Pega o primeiro como fallback
         display.innerHTML = `<div class="avatar avatar-lg ${initialColor}" data-initials="?" aria-hidden="true"></div>`;
         // Marcar a opção inicial na grid também
         const initialOption = grid.querySelector(`.avatar-option[data-color-class="${initialColor}"]`);
         if(initialOption && !initialOption.classList.contains('selected')) {
            initialOption.classList.add('selected');
            initialOption.setAttribute('aria-checked', 'true');
         }
    },

     /**
     * Função auxiliar para selecionar um avatar.
     * @param {HTMLElement} selectedOption O elemento da opção de avatar clicada.
     * @param {HTMLInputElement} inputColor Input hidden para a classe de cor.
     * @param {HTMLElement} display Elemento para exibir o avatar selecionado.
     * @param {HTMLElement} grid O container da grid de avatares.
     */
     selectAvatar(selectedOption, inputColor, display, grid) {
         const selectedColorClass = selectedOption.dataset.colorClass;

         // Atualiza input
         inputColor.value = selectedColorClass;

         // Atualiza display (mantendo o tamanho grande)
         display.innerHTML = `<div class="avatar avatar-lg ${selectedColorClass}" data-initials="?" aria-hidden="true"></div>`;

          // Atualiza visualmente a seleção na grid
         grid.querySelectorAll('.avatar-option').forEach(opt => {
             Utils.toggleClass(opt, 'selected', opt === selectedOption);
             opt.setAttribute('aria-checked', opt === selectedOption);
         });
     },


    // --- Manipulação de Formulários ---

    /**
     * Limpa os campos de um formulário e reseta validações (se houver).
     * @param {string | HTMLFormElement} formElementOuId O elemento do formulário ou seu ID.
     */
    resetForm(formElementOuId) {
        const form = (typeof formElementOuId === 'string') ? Utils.$(formElementOuId) : formElementOuId;
        if (form && form.tagName === 'FORM') {
            form.reset(); // Reseta valores para o padrão HTML

            // Limpa manualmente campos que o reset pode não pegar (hidden, custom components)
            form.querySelectorAll('input[type="hidden"]').forEach(input => input.value = '');
            // Resetar seletores customizados (ex: ícone, avatar) para o padrão, se necessário
             const iconInput = form.querySelector('.icon-selector-container input[type="hidden"]');
             const iconDisplay = form.querySelector('.icon-selector-container [id$="-selected-icon-display"]');
             const defaultIcon = 'fa-tag'; // Ou pegar de um data-attribute
             if(iconInput && iconDisplay) {
                 iconInput.value = defaultIcon;
                 iconDisplay.innerHTML = `<i class="fas ${defaultIcon}"></i>`;
             }
             // Resetar avatar (similar ao ícone)

            // TODO: Limpar classes/mensagens de erro de validação
            form.querySelectorAll('.is-invalid').forEach(el => Utils.removeClass(el, 'is-invalid'));
            form.querySelectorAll('.error-message').forEach(el => el.remove());

            console.log(`Formulário '${form.id || 'sem ID'}' resetado.`);
        } else {
            console.warn("resetForm: Elemento não encontrado ou não é um formulário:", formElementOuId);
        }
    },

    /**
     * Preenche um formulário com dados de um objeto.
     * Associa chaves do objeto com 'name' ou 'id' dos campos do formulário.
     * @param {string | HTMLFormElement} formElementOuId O formulário ou seu ID.
     * @param {object} data Objeto com os dados (chave: valor).
     */
    fillForm(formElementOuId, data) {
        const form = (typeof formElementOuId === 'string') ? Utils.$(formElementOuId) : formElementOuId;
        if (!form || form.tagName !== 'FORM' || !data) return;

        console.log("Preenchendo formulário:", form.id || 'sem ID', "com dados:", data);

        for (const key in data) {
            if (Object.hasOwnProperty.call(data, key)) {
                const value = data[key];
                // Tenta encontrar pelo 'name' primeiro, depois pelo 'id'
                const field = form.elements[key] || Utils.$(key);

                if (field) {
                     // Trata diferentes tipos de campo
                    switch (field.type) {
                        case 'checkbox':
                            field.checked = !!value; // Converte para booleano
                            break;
                        case 'radio':
                            // Para radios, encontra o que tem o valor correspondente e marca
                            const radio = form.querySelector(`input[name="${key}"][value="${value}"]`);
                            if (radio) radio.checked = true;
                            break;
                        case 'date':
                            // Garante que a data esteja no formato aaaa-mm-dd
                            field.value = Utils.formatDateForInput(value) || '';
                            break;
                        case 'color':
                             field.value = value || '#000000'; // Padrão preto se vazio
                             break;
                        case 'number':
                             field.value = parseFloat(value) || ''; // Garante número ou vazio
                             break;
                         case 'select-multiple':
                             // Lógica para selecionar múltiplas opções (se necessário)
                             if (Array.isArray(value)) {
                                 Array.from(field.options).forEach(option => {
                                     option.selected = value.includes(option.value);
                                 });
                             }
                             break;
                        case 'hidden':
                         case 'text':
                         case 'textarea':
                         case 'select-one':
                         default:
                             field.value = value !== null && value !== undefined ? value : ''; // Define como string vazia se for null/undefined
                             break;
                     }

                    // Dispara evento change manualmente para selects e inputs que precisam reagir
                    if (field.type === 'select-one' || field.type === 'checkbox' || field.type === 'radio' || field.type === 'date' || field.type === 'color') {
                         field.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                     // Tratar inputs hidden para seletores customizados
                     if(field.type === 'hidden') {
                         if (field.id.includes('-icon')) { // Seletor de ícone
                             const display = form.querySelector(`[id$="-selected-icon-display"]`); // Acha o display associado
                             if(display) display.innerHTML = `<i class="fas ${value || 'fa-tag'}"></i>`;
                         } else if (field.id.includes('-avatar-color')) { // Seletor de avatar
                             const displayContainer = form.querySelector(`[id$="-selected-avatar-display"]`);
                             if(displayContainer) displayContainer.innerHTML = `<div class="avatar avatar-lg ${value || 'avatar-bg-1'}" data-initials="?" aria-hidden="true"></div>`;
                             // Marcar a opção na grid também
                              const grid = form.querySelector('.avatar-grid');
                              if(grid) {
                                  grid.querySelectorAll('.avatar-option').forEach(opt => {
                                       Utils.toggleClass(opt, 'selected', opt.dataset.colorClass === value);
                                       opt.setAttribute('aria-checked', opt.dataset.colorClass === value);
                                  });
                              }
                         }
                     }

                } else {
                    // console.warn(`Campo não encontrado no formulário para a chave: ${key}`);
                }
            }
        }
    },

    /**
     * Serializa os dados de um formulário em um objeto.
     * @param {string | HTMLFormElement} formElementOuId O formulário ou seu ID.
     * @returns {object} Objeto com os dados do formulário (chave: valor).
     */
     serializeForm(formElementOuId) {
        const form = (typeof formElementOuId === 'string') ? Utils.$(formElementOuId) : formElementOuId;
        if (!form || form.tagName !== 'FORM') return {};

        const formData = new FormData(form);
        const data = {};

        formData.forEach((value, key) => {
             // Tratamento para múltiplos checkboxes com mesmo nome (se necessário)
             if (data.hasOwnProperty(key)) {
                if (!Array.isArray(data[key])) {
                    data[key] = [data[key]]; // Converte para array
                }
                data[key].push(value);
            } else {
                 // Tratamento para checkbox único (valor 'on' ou nada)
                 const element = form.elements[key];
                 if (element && element.type === 'checkbox' && !formData.has(key) && element.value === 'on') {
                    // Se o checkbox não está no FormData (desmarcado) e seu valor padrão é 'on',
                    // podemos querer enviar 'false' ou simplesmente não incluir a chave.
                    // Vamos não incluir por padrão, mas pode ser ajustado.
                    // data[key] = false;
                 } else if (element && element.type === 'checkbox') {
                      data[key] = element.checked; // Envia true/false
                 }
                 else {
                     data[key] = value;
                 }
            }
        });

         // Incluir valores de inputs hidden que não são pegos pelo FormData diretamente (caso necessário)
         form.querySelectorAll('input[type="hidden"]').forEach(input => {
             if (input.name && !data.hasOwnProperty(input.name)) {
                 data[input.name] = input.value;
             } else if (input.id && !data.hasOwnProperty(input.id)) {
                 // Fallback para ID se não tiver nome (menos comum para serialização)
                 // data[input.id] = input.value;
             }
         });


        return data;
    },


    // TODO: Adicionar funções para validação de formulário (showError, clearErrors, validateForm)

}; // Fim do objeto UIComponents (Importante!)


// ===== FIM: BLOCO 25 ==============================

// ===== INÍCIO: BLOCO 26 ==============================
// ==== JAVASCRIPT - APP PRINCIPAL (app.js) - Parte 1 ====
// Depende de: config.js, utils.js, firebaseService.js, uiComponents.js
//             e dos arquivos de módulo (e.g., modules/dashboard.js)

const App = {

    // --- Estado da Aplicação ---
    state: {
        currentUser: null, // Futuro: para dados do usuário logado
        currentModule: null, // Módulo carregado atualmente (objeto do módulo)
        currentModuleName: '', // Nome do módulo atual (string)
        globalData: { // Dados carregados globalmente
            categories: [],
            persons: [],
            cards: [],
            // Outros dados globais se necessário
        },
        isDataLoading: false, // Flag para indicar carregamento inicial de dados
        currentFilters: { // Filtros globais ativos
             monthYear: Utils.getCurrentMonthYear(),
             personId: 'all',
        },
    },

    // --- Módulos da Aplicação ---
    // Mapeia o nome do módulo (data-module) para o objeto do módulo JS
    modules: {
        // Os objetos dos módulos (DashboardModule, SettingsModule, etc.)
        // serão definidos em seus próprios arquivos e adicionados aqui
        // Exemplo:
        // dashboard: DashboardModule,
        // settings: SettingsModule,
        // monthlyAnalysis: MonthlyAnalysisModule,
        // cashProjection: CashProjectionModule,
        // financialGoals: FinancialGoalsModule,
    },

    // --- Inicialização Principal ---
    /**
     * Inicializa toda a aplicação.
     */
    async init() {
        console.log("App: Iniciando aplicação...");
        UIComponents.showLoading(); // Mostra loading principal

        // 1. Inicializar UI básica (menus, tema, etc.)
        UIComponents.init(); // Chama o init dos componentes UI

        // 2. Carregar dados globais essenciais (categorias, pessoas, cartões)
        await this.loadGlobalData();

        // 3. Configurar listeners de eventos globais da UI
        this.setupEventListeners();

        // 4. Carregar o módulo inicial (Dashboard por padrão)
        const initialModule = 'dashboard'; // Ou pegar de um hash/rota
        await this.loadModule(initialModule);

        UIComponents.hideLoading(); // Esconde loading principal
        console.log("App: Aplicação pronta.");
    },

    // --- Carregamento de Dados Globais ---
    /**
     * Carrega dados que são usados em múltiplos módulos (categorias, pessoas).
     */
    async loadGlobalData() {
        console.log("App: Carregando dados globais...");
        this.state.isDataLoading = true;
        try {
            // Carrega em paralelo usando Promise.all
            const [categories, persons, cards] = await Promise.all([
                FirebaseService.categories.getAll(),
                FirebaseService.persons.getAll(),
                FirebaseService.cards.getAll()
            ]);

            this.state.globalData.categories = categories || [];
            this.state.globalData.persons = persons || [];
            this.state.globalData.cards = cards || [];

            console.log("App: Dados globais carregados:", this.state.globalData);

            // Popula filtros globais que dependem desses dados
            UIComponents.populateGlobalPersonFilter(this.state.globalData.persons);
            // Popula selects em modais que dependem desses dados (será chamado ao abrir modal)

        } catch (error) {
            console.error("App: Erro crítico ao carregar dados globais:", error);
            UIComponents.renderError("Falha ao carregar dados essenciais.", "Verifique a conexão com o banco de dados e as permissões.");
            // Travar a aplicação ou mostrar mensagem persistente
        } finally {
            this.state.isDataLoading = false;
        }
    },

     // --- Configuração de Listeners Globais ---
     /**
      * Configura listeners para eventos customizados disparados pela UI.
      */
     setupEventListeners() {
        console.log("App: Configurando listeners globais...");
        // Listener para navegar entre módulos
        document.addEventListener('navigateToModule', (event) => {
            const moduleName = event.detail.moduleName;
            console.log(`App: Evento navigateToModule recebido para '${moduleName}'`);
            this.loadModule(moduleName);
        });

         // Listener para mudança nos filtros globais
         document.addEventListener('globalFilterChanged', (event) => {
             const { filterType, value } = event.detail;
             console.log(`App: Evento globalFilterChanged recebido - ${filterType}: ${value}`);
             this.state.currentFilters[filterType === 'monthYear' ? 'monthYear' : 'personId'] = value;

             // Recarrega o módulo atual para refletir o novo filtro
             if (this.state.currentModule && typeof this.state.currentModule.render === 'function') {
                 console.log(`App: Recarregando módulo '${this.state.currentModuleName}' devido à mudança de filtro.`);
                 UIComponents.showLoading();
                 // Adiciona um pequeno delay para dar tempo da UI atualizar o select antes de recarregar
                 setTimeout(async () => {
                     try {
                         await this.state.currentModule.render(this.state.currentFilters);
                     } catch (error) {
                          console.error(`App: Erro ao re-renderizar módulo ${this.state.currentModuleName}:`, error);
                          UIComponents.renderError(`Erro ao aplicar filtro no módulo ${this.state.currentModuleName}.`);
                     } finally {
                          UIComponents.hideLoading();
                     }
                 }, 50); // 50ms delay
             }
         });

         // Adicionar outros listeners globais (ex: usuário logado/deslogado)
     },


    // --- Carregamento e Gerenciamento de Módulos ---
    /**
     * Carrega e renderiza um módulo específico.
     * @param {string} moduleName O nome do módulo a ser carregado (chave em App.modules).
     */
    async loadModule(moduleName) {
        console.log(`App: Carregando módulo '${moduleName}'...`);
        UIComponents.showLoading(); // Mostra loading antes de carregar

        const module = this.modules[moduleName];

        if (!module) {
            console.error(`App: Módulo '${moduleName}' não encontrado!`);
            UIComponents.renderError(`Módulo '${moduleName}' não implementado.`);
            UIComponents.hideLoading();
            return;
        }

        // Verifica se o módulo tem uma função de inicialização (opcional)
        if (this.state.currentModule && typeof this.state.currentModule.destroy === 'function') {
             try {
                await this.state.currentModule.destroy();
                console.log(`App: Módulo '${this.state.currentModuleName}' destruído.`);
             } catch(error) {
                 console.error(`App: Erro ao destruir módulo '${this.state.currentModuleName}':`, error);
             }
        }


        this.state.currentModule = module;
        this.state.currentModuleName = moduleName;

         // Verifica se o módulo tem uma função de inicialização (opcional)
         if (typeof module.init === 'function') {
             try {
                await module.init();
                 console.log(`App: Módulo '${moduleName}' inicializado.`);
             } catch(error) {
                 console.error(`App: Erro ao inicializar módulo '${moduleName}':`, error);
                  UIComponents.renderError(`Erro ao inicializar módulo ${moduleName}.`);
                  UIComponents.hideLoading();
                  return; // Interrompe se a inicialização falhar
             }
         }


        // Renderiza o conteúdo do módulo
        if (typeof module.render === 'function') {
            try {
                // Passa os filtros atuais para a função render
                await module.render(this.state.currentFilters);
                 console.log(`App: Módulo '${moduleName}' renderizado.`);
                // Atualiza título e item ativo do menu APÓS renderizar com sucesso
                UIComponents.updateModuleTitle(Utils.qs(`.nav-item[data-module="${moduleName}"] .nav-text`)?.textContent || moduleName);
                UIComponents.setActiveNavItem(moduleName); // Garante que o item correto está ativo
            } catch (error) {
                console.error(`App: Erro ao renderizar módulo '${moduleName}':`, error);
                UIComponents.renderError(`Erro ao carregar conteúdo do módulo ${moduleName}.`);
            }
        } else {
            console.error(`App: Módulo '${moduleName}' não possui função render!`);
            UIComponents.renderError(`Módulo '${moduleName}' não pode ser exibido.`);
        }

        UIComponents.hideLoading(); // Esconde loading após carregar
    },

     // --- Funções a serem adicionadas na Parte 2 ---
     // prepareTransactionModal (para limpar/preencher dados antes de abrir)
     // prepareCategoryModal
     // preparePersonModal
     // prepareCardModal
     // prepareGoalModal
     // prepareContributionModal
     // showConfirmationDialog (para usar o modal de confirmação)
     // Funções de tratamento de submissão de formulários dos modais

}; // Fim do objeto App

// --- Ponto de Entrada da Aplicação ---
// Garante que o DOM esteja pronto antes de iniciar o App
document.addEventListener('DOMContentLoaded', () => {
    // Registra os módulos JS no App.modules ANTES de chamar App.init()
    // Ex: App.modules.dashboard = DashboardModule;
    //     App.modules.settings = SettingsModule;
    // ... (Isso será feito nos blocos de cada módulo)

    // Inicia a aplicação
    // App.init(); // Comentado por enquanto, será chamado no final
});


// ===== FIM: BLOCO 26 ==============================


// ===== INÍCIO: BLOCO 27 ==============================
// ==== JAVASCRIPT - MÓDULO DASHBOARD (modules/dashboard.js) ====
// Depende de: utils.js, firebaseService.js, uiComponents.js

const DashboardModule = (() => { // IIFE para encapsular o módulo

    // --- Referências a Elementos do Módulo (obtidos no render) ---
    let elements = {}; // Será preenchido com IDs específicos do dashboard

    // --- Estado Interno do Módulo ---
    let state = {
        transactions: [],
        categories: [],
        persons: [],
        cards: [],
        currentFilters: {}, // Recebe os filtros globais do App
        charts: {}, // Armazena instâncias dos gráficos Chart.js
    };

    // --- Funções Privadas ---

    /**
     * Busca os dados necessários para o dashboard com base nos filtros.
     * @param {object} filters Filtros atuais (monthYear, personId).
     */
    async function fetchData(filters) {
        console.log("Dashboard: Buscando dados com filtros:", filters);
        UIComponents.showLoading(); // Mostra loading específico do módulo (se houver) ou global

        try {
             // Usar filtros para buscar dados. Por enquanto, busca tudo e filtra no front-end.
             // O ideal seria filtrar no backend/Firebase se os dados forem muitos.
             const allTransactions = await FirebaseService.transactions.getAll(); // TODO: Otimizar query no futuro

             // Filtra transações pelo mês/ano e pessoa selecionados
             state.transactions = allTransactions.filter(t => {
                 const isInMonth = Utils.isDateInMonth(t.date, filters.monthYear);
                 const matchPerson = filters.personId === 'all' || t.personId === filters.personId;
                 return isInMonth && matchPerson;
             });

            // Pega dados globais já carregados pelo App
            state.categories = App.state.globalData.categories;
            state.persons = App.state.globalData.persons;
            state.cards = App.state.globalData.cards;

            console.log(`Dashboard: ${state.transactions.length} transações encontradas para ${filters.monthYear}.`);

        } catch (error) {
            console.error("Dashboard: Erro ao buscar dados:", error);
            UIComponents.renderError("Erro ao carregar dados do Dashboard.");
            state.transactions = []; // Reseta em caso de erro
        } finally {
             // UIComponents.hideLoading(); // Esconde loading
        }
    }

    /**
     * Renderiza os cards de KPI.
     */
    function renderKpis() {
        if (!elements.kpiGridMain) return;
        elements.kpiGridMain.innerHTML = ''; // Limpa área de KPIs

        // Calcula valores
        const totalIncome = state.transactions
            .filter(t => t.type === 'income')
            .reduce((sum, t) => sum + t.amount, 0);
        const totalExpense = state.transactions
            .filter(t => t.type === 'expense')
            .reduce((sum, t) => sum + t.amount, 0);
        const balance = totalIncome - totalExpense;

        // TODO: Calcular Saldo Atual Global (não apenas do mês filtrado)
        // const globalBalance = calcularSaldoGlobal(); // Precisa buscar todas as transações até hoje

        // Criar e adicionar KPIs
        // Exemplo:
        elements.kpiGridMain.appendChild(
            UIComponents.createKpiCard({ // Passar objeto de configuração
                title: "Receitas no Mês",
                value: Utils.formatCurrency(totalIncome),
                icon: 'fa-arrow-up',
                type: 'positive' // Ou calcular classe dinamicamente
            })
        );
         elements.kpiGridMain.appendChild(
            UIComponents.createKpiCard({
                title: "Despesas no Mês",
                value: Utils.formatCurrency(totalExpense),
                icon: 'fa-arrow-down',
                type: 'negative'
            })
        );
         elements.kpiGridMain.appendChild(
            UIComponents.createKpiCard({
                title: "Saldo do Mês",
                value: Utils.formatCurrency(balance),
                icon: balance >= 0 ? 'fa-check-circle' : 'fa-exclamation-circle',
                type: balance >= 0 ? 'positive' : 'negative'
            })
        );
         // Adicionar mais KPIs (Saldo Atual Global, Fixas vs Variáveis, etc.)

         console.log("Dashboard: KPIs renderizados.");
    }

     /**
      * Renderiza os gráficos.
      */
     function renderCharts() {
        // Destroi gráficos anteriores para evitar memory leaks
         destroyCharts();

         renderCategoryExpenseChart();
         renderIncomeExpenseChart();
         // Chamar outras funções de renderização de gráficos

         console.log("Dashboard: Gráficos renderizados.");
     }

     /**
      * Renderiza o gráfico de despesas por categoria.
      */
     function renderCategoryExpenseChart() {
         const canvas = elements.categoryExpenseChart;
         const container = elements.categoryExpenseChartContainer;
         const emptyMessage = container?.querySelector('.chart-empty-message');
         if (!canvas || !container || !emptyMessage) return;

         const expenses = state.transactions.filter(t => t.type === 'expense');
         if (expenses.length === 0) {
             canvas.style.display = 'none';
             emptyMessage.style.display = 'flex';
             return;
         } else {
             canvas.style.display = 'block';
             emptyMessage.style.display = 'none';
         }


         const dataByCategory = expenses.reduce((acc, t) => {
             const category = state.categories.find(c => c.id === t.categoryId);
             const categoryName = category ? category.name : 'Sem Categoria';
             const categoryColor = category ? category.color : '#cccccc';
             if (!acc[categoryName]) {
                 acc[categoryName] = { total: 0, color: categoryColor };
             }
             acc[categoryName].total += t.amount;
             return acc;
         }, {});

         const labels = Object.keys(dataByCategory);
         const data = labels.map(label => dataByCategory[label].total);
         const backgroundColors = labels.map(label => dataByCategory[label].color);

         state.charts.categoryExpense = new Chart(canvas.getContext('2d'), {
             type: 'doughnut',
             data: {
                 labels: labels,
                 datasets: [{
                     label: 'Despesas por Categoria',
                     data: data,
                     backgroundColor: backgroundColors,
                     borderColor: Utils.getCssVariable('--color-surface'), // Borda da cor do fundo do card
                     borderWidth: 2,
                     hoverOffset: 8
                 }]
             },
             options: {
                 responsive: true,
                 maintainAspectRatio: false,
                 plugins: {
                     legend: {
                         position: 'bottom',
                         labels: { padding: 15, boxWidth: 12, font: { size: 12 } }
                     },
                     tooltip: {
                         callbacks: {
                             label: function(context) {
                                 const label = context.label || '';
                                 const value = context.parsed || 0;
                                 const percentage = ((value / data.reduce((a, b) => a + b, 0)) * 100).toFixed(1);
                                 return `${label}: ${Utils.formatCurrency(value)} (${percentage}%)`;
                             }
                         }
                     }
                 }
             }
         });
     }

     /**
      * Renderiza o gráfico de Receitas vs Despesas (Exemplo - precisa de dados históricos).
      */
     function renderIncomeExpenseChart() {
        const canvas = elements.incomeExpenseChart;
        const container = elements.incomeExpenseChartContainer;
        const emptyMessage = container?.querySelector('.chart-empty-message');
        if (!canvas || !container || !emptyMessage) return;

        // TODO: Buscar e processar dados históricos (últimos 6 meses)
        const historicalDataAvailable = false; // Substituir pela lógica real

         if (!historicalDataAvailable) {
             canvas.style.display = 'none';
             emptyMessage.style.display = 'flex';
             emptyMessage.textContent = 'Dados históricos não disponíveis.';
             return;
         } else {
             canvas.style.display = 'block';
             emptyMessage.style.display = 'none';
         }

         // Exemplo de dados (substituir pelos dados reais processados)
         const labels = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun'];
         const incomeData = [3000, 3200, 3100, 3500, 3400, 3600];
         const expenseData = [2500, 2800, 2600, 3000, 2900, 3100];

         state.charts.incomeExpense = new Chart(canvas.getContext('2d'), {
             type: 'bar',
             data: {
                 labels: labels,
                 datasets: [
                     {
                         label: 'Receitas',
                         data: incomeData,
                         backgroundColor: Utils.getCssVariable('--color-success'),
                         borderColor: Utils.getCssVariable('--color-success'),
                         borderWidth: 1
                     },
                     {
                         label: 'Despesas',
                         data: expenseData,
                         backgroundColor: Utils.getCssVariable('--color-danger'),
                         borderColor: Utils.getCssVariable('--color-danger'),
                         borderWidth: 1
                     }
                 ]
             },
             options: {
                 responsive: true,
                 maintainAspectRatio: false,
                 scales: {
                     y: {
                         beginAtZero: true,
                         ticks: {
                            callback: function(value) { return Utils.formatCurrency(value, false); } // Formata eixo Y
                         }
                     }
                 },
                 plugins: {
                     tooltip: {
                         callbacks: {
                             label: function(context) {
                                 return `${context.dataset.label}: ${Utils.formatCurrency(context.parsed.y)}`;
                             }
                         }
                     }
                 }
             }
         });
     }

    /**
     * Renderiza a tabela de transações recentes.
     */
    function renderRecentTransactions() {
        const container = elements.recentTransactionsTableContainer;
        if (!container) return;

        const loadingPlaceholder = container.querySelector('.table-loading-placeholder');
        if (loadingPlaceholder) loadingPlaceholder.style.display = 'none'; // Esconde o placeholder

        // Pega as últimas N transações (ordenadas por data se buscadas corretamente)
        const recentTransactions = state.transactions.slice(0, 10); // Exibe as 10 mais recentes do mês filtrado

        // Cria e insere a tabela
        // TODO: Adaptar UIComponents.createTransactionsTable se necessário ou criar uma nova função
        container.innerHTML = ''; // Limpa o container
        container.appendChild(
             UIComponents.createTransactionsTable( // Assumindo que esta função existe e está adaptada
                 recentTransactions,
                 state.categories,
                 state.persons,
                 state.cards,
                 ['date', 'description', 'category', 'amount', 'actions'] // Colunas desejadas
             )
         );
         console.log("Dashboard: Tabela de transações recentes renderizada.");
    }

    /**
     * Destroi instâncias de gráficos Chart.js para liberar memória.
     */
    function destroyCharts() {
        Object.values(state.charts).forEach(chartInstance => {
            if (chartInstance && typeof chartInstance.destroy === 'function') {
                chartInstance.destroy();
            }
        });
        state.charts = {}; // Limpa o objeto de referências
        console.log("Dashboard: Gráficos anteriores destruídos.");
    }

     /**
     * Adiciona listeners específicos do módulo.
     */
     function setupModuleListeners() {
        // Exemplo: Listener para botão "Ver Todas as Transações"
        const viewAllBtn = Utils.$('view-all-transactions-btn');
        viewAllBtn?.addEventListener('click', () => {
             console.log("Dashboard: Botão 'Ver Todas' clicado.");
             // Navega para o módulo de Análise Mensal (ou outra tela de transações)
              document.dispatchEvent(new CustomEvent('navigateToModule', {
                  detail: { moduleName: 'monthly-analysis' } // Ou o nome do módulo correto
              }));
        });
     }


    // --- Funções Públicas do Módulo ---
    return {
        /**
         * Inicializa o módulo Dashboard (opcional, pode buscar dados iniciais aqui).
         */
        async init() {
            console.log("DashboardModule: Inicializando...");
            // Pode fazer algo na inicialização, se necessário
        },

        /**
         * Renderiza o conteúdo do módulo Dashboard na área de conteúdo.
         * @param {object} filters Filtros globais recebidos do App.
         */
        async render(filters) {
            console.log("DashboardModule: Renderizando com filtros:", filters);
            state.currentFilters = filters; // Armazena filtros atuais

             // 1. Carrega o HTML base do módulo na tela
             UIComponents.renderContent(App.templates['dashboard']); // Usa template HTML pré-carregado (definiremos depois)

             // 2. Seleciona elementos específicos do módulo APÓS renderizar o HTML
             elements = {
                 kpiGridMain: Utils.$('kpi-grid-main'),
                 chartsGridMain: Utils.$('charts-grid-main'),
                 categoryExpenseChartContainer: Utils.$('category-expense-chart-container'),
                 categoryExpenseChart: Utils.$('category-expense-chart'),
                 incomeExpenseChartContainer: Utils.$('income-expense-chart-container'),
                 incomeExpenseChart: Utils.$('income-expense-chart'),
                 recentTransactionsTableContainer: Utils.$('recent-transactions-table-container'),
                 dashboardAlerts: Utils.$('dashboard-alerts'),
             };

             // 3. Busca os dados necessários com base nos filtros
             await fetchData(filters);

             // 4. Renderiza os componentes do dashboard com os dados buscados
             renderKpis();
             renderCharts();
             renderRecentTransactions();
             // renderAlerts(); // Função para renderizar alertas se houver

              // 5. Configura listeners específicos do módulo
              setupModuleListeners();

             console.log("DashboardModule: Renderização concluída.");
        },

        /**
         * Limpa recursos do módulo (listeners, instâncias de gráficos) ao sair.
         */
        destroy() {
            console.log("DashboardModule: Destruindo...");
            destroyCharts();
            // Remover outros listeners específicos do módulo, se houver
            elements = {}; // Limpa referências DOM
        }
    };

})(); // Fim da IIFE

// ===== FIM: BLOCO 27 ==============================

// ===== INÍCIO: BLOCO 28 ==============================
// ==== JAVASCRIPT - COMPONENTES UI (uiComponents.js) - Parte 4 ====
// Adicionar esta função dentro do objeto UIComponents

const UIComponents = {
    // ... (código dos Blocos 23, 24, 25) ...

    /**
     * Cria e retorna um elemento HTML para um card de KPI.
     * @param {object} options Opções para o card de KPI.
     * @param {string} options.title Título do KPI (e.g., "Saldo Atual").
     * @param {string} options.value Valor principal a ser exibido (já formatado).
     * @param {string} [options.icon] Classe Font Awesome do ícone principal (e.g., 'fa-wallet').
     * @param {string} [options.type] Tipo semântico para cores ('positive', 'negative', 'neutral', ou cor base como 'primary').
     * @param {object} [options.footer] Objeto com dados do rodapé (opcional).
     * @param {string} [options.footer.trendValue] Valor da tendência (e.g., "+5.2%", "-100,00").
     * @param {string} [options.footer.trendIcon] Classe Font Awesome para ícone de tendência (e.g., 'fa-arrow-up').
     * @param {string} [options.footer.trendType] Tipo semântico da tendência ('positive', 'negative', 'neutral').
     * @param {string} [options.footer.period] Descrição do período da tendência (e.g., "últimos 30 dias").
     * @param {string} [options.cssClass] Classes CSS adicionais para o card.
     * @returns {HTMLElement} O elemento div do card de KPI criado.
     */
    createKpiCard(options = {}) {
        const {
            title = 'KPI Título',
            value = '---',
            icon = null, // 'fa-question-circle' como fallback?
            type = 'neutral', // 'positive', 'negative', 'neutral', 'primary', 'info', etc.
            footer = null,
            cssClass = ''
        } = options;

        const card = document.createElement('div');
        card.className = `kpi-card ${cssClass}`;
        // Adicionar classe de tipo se não for neutral para estilização opcional
        if (type !== 'neutral') {
            card.classList.add(`kpi-type-${type}`);
        }

        // 1. Cabeçalho do KPI
        const header = document.createElement('div');
        header.className = 'kpi-header';

        const kpiTitle = document.createElement('span');
        kpiTitle.className = 'kpi-title';
        kpiTitle.textContent = title;
        header.appendChild(kpiTitle);

        if (icon) {
            const kpiIcon = document.createElement('i');
            // Adiciona classes base e a classe específica do ícone
            kpiIcon.className = `fas ${icon} kpi-icon`;
            // Define a cor do ícone baseada no tipo semântico (ou usa cor padrão)
             const iconColorVar = `--color-${type}`; // Tenta usar a cor semântica
             kpiIcon.style.color = `var(${iconColorVar}, var(--color-text-tertiary))`; // Usa fallback
            header.appendChild(kpiIcon);
        }
        card.appendChild(header);

        // 2. Valor Principal
        const kpiValue = document.createElement('div');
        kpiValue.className = 'kpi-value';
        kpiValue.innerHTML = value; // Usa innerHTML para permitir formatação (e.g., <sup>R$</sup>) se necessário
        // Adiciona classe de cor baseada no tipo
         if (type === 'positive') kpiValue.classList.add('positive-value');
         else if (type === 'negative') kpiValue.classList.add('negative-value');
        card.appendChild(kpiValue);

        // 3. Rodapé do KPI (Opcional)
        if (footer) {
            const kpiFooter = document.createElement('div');
            kpiFooter.className = 'kpi-footer';

            // Tendência (se houver)
            if (footer.trendValue) {
                const trendSpan = document.createElement('span');
                trendSpan.className = 'kpi-trend';
                 // Adiciona classe de cor para a tendência
                 if (footer.trendType === 'positive') trendSpan.classList.add('positive-value');
                 else if (footer.trendType === 'negative') trendSpan.classList.add('negative-value');

                let trendHTML = '';
                if (footer.trendIcon) {
                    trendHTML += `<i class="fas ${footer.trendIcon}" aria-hidden="true"></i> `;
                }
                trendHTML += footer.trendValue;
                trendSpan.innerHTML = trendHTML;
                kpiFooter.appendChild(trendSpan);
            } else {
                 kpiFooter.appendChild(document.createElement('span')); // Placeholder para alinhar período à direita
            }


            // Período (se houver)
            if (footer.period) {
                const periodSpan = document.createElement('span');
                periodSpan.className = 'kpi-period';
                periodSpan.textContent = footer.period;
                kpiFooter.appendChild(periodSpan);
            }

            card.appendChild(kpiFooter);
        }

        return card;
    },

    // ... (restante do código UIComponents - Blocos 23, 24, 25) ...

}; // Fim do objeto UIComponents

// ===== FIM: BLOCO 28 ==============================

// ===== INÍCIO: BLOCO 29 ==============================
// ==== JAVASCRIPT - COMPONENTES UI (uiComponents.js) - Parte 5 ====
// Adicionar esta função dentro do objeto UIComponents

const UIComponents = {
    // ... (código dos Blocos 23, 24, 25, 28) ...

    /**
     * Cria e retorna um elemento TABLE para exibir transações.
     * @param {Array<object>} transactions Array de objetos de transação.
     * @param {Array<object>} categories Array de objetos de categoria (para lookup).
     * @param {Array<object>} persons Array de objetos de pessoa (para lookup).
     * @param {Array<object>} cards Array de objetos de cartão (para lookup, opcional).
     * @param {Array<string>} columns Array de strings indicando quais colunas exibir e a ordem.
     *        Valores possíveis: 'date', 'description', 'category', 'person', 'payment', 'amount', 'actions'.
     * @returns {HTMLElement} O elemento table criado.
     */
    createTransactionsTable(transactions = [], categories = [], persons = [], cards = [], columns = ['date', 'description', 'category', 'amount', 'actions']) {

        const table = document.createElement('table');
        table.className = 'table transactions-table'; // Adiciona classe específica

        // --- Mapeamentos para performance ---
        const categoryMap = new Map(categories.map(cat => [cat.id, cat]));
        const personMap = new Map(persons.map(p => [p.id, p]));
        const cardMap = new Map(cards.map(card => [card.id, card]));

        // --- Cabeçalho da Tabela ---
        const thead = table.createTHead();
        const headerRow = thead.insertRow();

        const columnHeaders = {
            date: 'Data',
            description: 'Descrição',
            category: 'Categoria',
            person: 'Pessoa',
            payment: 'Pagamento',
            amount: 'Valor',
            actions: 'Ações'
        };

        columns.forEach(colKey => {
            const th = document.createElement('th');
            th.textContent = columnHeaders[colKey] || colKey; // Usa nome amigável ou a chave
            if (colKey === 'amount') {
                th.classList.add('currency'); // Alinha valor à direita
            }
            if (colKey === 'actions') {
                th.classList.add('action-cell'); // Alinha ações à direita
            }
            headerRow.appendChild(th);
        });

        // --- Corpo da Tabela ---
        const tbody = table.createTBody();

        if (transactions.length === 0) {
            // Linha indicando que não há dados
            const emptyRow = tbody.insertRow();
            emptyRow.className = 'table-empty-row';
            const cell = emptyRow.insertCell();
            cell.colSpan = columns.length; // Ocupa todas as colunas
            cell.textContent = 'Nenhuma transação encontrada para os critérios selecionados.';
        } else {
            // Cria uma linha para cada transação
            transactions.forEach(transaction => {
                const row = tbody.insertRow();
                row.dataset.transactionId = transaction.id; // Adiciona ID para referência

                columns.forEach(colKey => {
                    const cell = row.insertCell();
                    let content = ''; // Conteúdo da célula

                    switch (colKey) {
                        case 'date':
                            content = Utils.formatDate(transaction.date);
                            break;
                        case 'description':
                            cell.classList.add('wrap'); // Permite quebra de linha na descrição
                            content = transaction.description || '---';
                             // Adicionar observações como tooltip ou ícone?
                             if(transaction.notes) {
                                 cell.title = transaction.notes; // Tooltip simples
                                 // Poderia adicionar um ícone:
                                 // content += ` <i class="fas fa-info-circle note-indicator" title="${transaction.notes}"></i>`;
                             }
                             // Indicar parcelamento
                             if (transaction.installments && transaction.installments > 1) {
                                 const current = transaction.installmentNumber || 1; // Assume 1 se não definido
                                 content += ` <span class="installment-badge">(${current}/${transaction.installments})</span>`;
                             }
                             // Indicar recorrência
                             if (transaction.isRecurrent) {
                                 content += ` <i class="fas fa-sync-alt recurrent-indicator" title="Recorrente"></i>`;
                             }
                            break;
                        case 'category':
                            const category = categoryMap.get(transaction.categoryId);
                            if (category) {
                                content = `
                                    <span class="badge category-badge" style="background-color: ${category.color || 'var(--color-neutral)'}1A; color: ${category.color || 'var(--color-text-secondary)'}; border: 1px solid ${category.color || 'var(--color-border)'}33;">
                                        ${category.icon ? `<i class="fas ${category.icon}" aria-hidden="true"></i> ` : ''}
                                        ${category.name}
                                    </span>`;
                            } else {
                                content = '<span class="badge badge-neutral">Sem Categoria</span>';
                            }
                            break;
                        case 'person':
                            const person = personMap.get(transaction.personId);
                            content = person ? person.name : 'N/D';
                             // Adicionar avatar pequeno?
                             // if (person && person.avatar) {
                             //    content = `<div class="person-cell"><span class="avatar avatar-sm ${person.avatar}"></span> ${person.name}</div>`;
                             // }
                            break;
                        case 'payment':
                             let paymentText = 'N/D';
                             switch(transaction.paymentMethod) {
                                 case 'cash': paymentText = 'Dinheiro'; break;
                                 case 'debit': paymentText = 'Débito'; break;
                                 case 'credit':
                                      const card = cardMap.get(transaction.cardId);
                                      paymentText = `Crédito${card ? ': ' + card.name : ''}`;
                                      break;
                                 case 'pix': paymentText = 'PIX'; break;
                                 case 'transfer': paymentText = 'Transf.'; break;
                                 case 'other': paymentText = 'Outro'; break;
                             }
                             content = paymentText;
                             break;
                        case 'amount':
                            cell.classList.add('currency');
                            const amount = transaction.amount || 0;
                            content = Utils.formatCurrency(amount);
                            // Adiciona classe de cor baseada no tipo
                            cell.classList.add(transaction.type === 'income' ? 'positive-value' : 'negative-value');
                            break;
                        case 'actions':
                            cell.classList.add('action-cell');
                             cell.innerHTML = `
                                <div class="action-buttons">
                                    <button class="btn btn-icon-only btn-link btn-sm btn-edit-transaction" title="Editar Transação" data-id="${transaction.id}">
                                        <i class="fas fa-edit" aria-hidden="true"></i>
                                    </button>
                                    <button class="btn btn-icon-only btn-link btn-sm btn-delete-transaction" title="Excluir Transação" data-id="${transaction.id}">
                                        <i class="fas fa-trash-alt" aria-hidden="true"></i>
                                    </button>
                                </div>`;
                            break;
                        default:
                            content = transaction[colKey] || '---'; // Fallback para outras colunas
                    }

                    // Usa innerHTML para permitir tags HTML (como badges e ícones)
                    cell.innerHTML = content;
                });
            });
        }

        // Adiciona listeners DELEGADOS para os botões de ação APÓS a tabela ser criada
        // É mais eficiente do que adicionar um listener para cada botão
        tbody.addEventListener('click', (event) => {
             const editButton = event.target.closest('.btn-edit-transaction');
             const deleteButton = event.target.closest('.btn-delete-transaction');

             if (editButton) {
                 const transactionId = editButton.dataset.id;
                 console.log("Clicou em Editar:", transactionId);
                 // Dispara evento para o App/Módulo tratar a edição
                  document.dispatchEvent(new CustomEvent('editTransactionRequest', {
                       detail: { transactionId: transactionId }
                  }));
             } else if (deleteButton) {
                 const transactionId = deleteButton.dataset.id;
                 const transactionDescription = deleteButton.closest('tr')?.querySelector('td:nth-child(2)')?.textContent || 'esta transação'; // Pega a descrição da linha
                 console.log("Clicou em Excluir:", transactionId);
                  // Dispara evento para o App/Módulo pedir confirmação e excluir
                  document.dispatchEvent(new CustomEvent('deleteTransactionRequest', {
                       detail: { transactionId: transactionId, description: transactionDescription }
                  }));
             }
        });


        return table;
    },

    // ... (restante do código UIComponents) ...

}; // Fim do objeto UIComponents

// Adicionar estilos para as novas classes se necessário (no CSS)
// .installment-badge { font-size: 0.8em; opacity: 0.7; margin-left: 4px; }
// .recurrent-indicator { font-size: 0.8em; opacity: 0.7; margin-left: 4px; color: var(--color-info); }
// .category-badge { display: inline-flex; align-items: center; gap: 4px; }
// .category-badge i { font-size: 0.9em; }


// ===== FIM: BLOCO 29 ==============================

// ===== INÍCIO: BLOCO 30 ==============================
// ==== JAVASCRIPT - APP PRINCIPAL (app.js) - Parte 2 ====
// Continuação do objeto App...

const App = {
    // ... (código do Bloco 26: state, modules, init, loadGlobalData, setupEventListeners, loadModule) ...

    // --- Funções de Preparação de Modais ---
    // Estas funções são chamadas ANTES de abrir um modal para resetar
    // o formulário, definir títulos e preencher dados (se for edição).

    /**
     * Prepara o modal de transação para adição ou edição.
     * @param {object | null} [transactionData=null] Dados da transação para edição, ou null para nova.
     */
    async prepareTransactionModal(transactionData = null) {
        console.log("App: Preparando modal de transação. Dados:", transactionData);
        const formId = 'transaction-form';
        const modalId = 'transaction-modal';
        const titleElement = Utils.$('transaction-modal-title');

        // 1. Resetar o formulário
        UIComponents.resetForm(formId);

        // 2. Popular selects essenciais (Categoria, Pessoa, Cartão)
        // Garante que as opções estejam atualizadas
        const categorySelect = Utils.$('transaction-category');
        const personSelect = Utils.$('transaction-person');
        const cardSelect = Utils.$('transaction-card');

        await Promise.all([
            this.populateSelectWithOptions(categorySelect, this.state.globalData.categories, 'Selecione Categoria...', 'id', 'name'),
            this.populateSelectWithOptions(personSelect, this.state.globalData.persons, 'Selecione Pessoa...', 'id', 'name'),
            this.populateSelectWithOptions(cardSelect, this.state.globalData.cards, 'Nenhum (ou selecione)', 'id', 'name', true) // Permite opção vazia
        ]);

        // 3. Gerar opções de parcelas (ex: 2x a 12x)
         const installmentsSelect = Utils.$('transaction-installments');
         if(installmentsSelect) {
             // Limpa opções antigas (exceto a primeira 'À vista')
             while (installmentsSelect.options.length > 1) { installmentsSelect.remove(1); }
             for (let i = 2; i <= 12; i++) {
                 const option = new Option(`${i}x`, i);
                 installmentsSelect.add(option);
             }
         }


        // 4. Definir título e preencher dados se for edição
        if (transactionData && transactionData.id) {
            // Modo Edição
            if (titleElement) titleElement.textContent = 'Editar Transação';
            // Preenche o formulário com os dados existentes
            UIComponents.fillForm(formId, transactionData);

             // Forçar visibilidade dos campos condicionais se necessário
             setTimeout(() => { // Pequeno delay para garantir que fillForm disparou 'change'
                 const paymentMethod = Utils.$('transaction-payment-method').value;
                 const isRecurrent = Utils.$('transaction-recurrent').checked;
                 Utils.toggleClass(Utils.$('credit-card-details'), 'visible', paymentMethod === 'credit');
                 Utils.toggleClass(Utils.$('recurrent-details'), 'visible', isRecurrent);
             }, 50);


        } else {
            // Modo Adição
            if (titleElement) titleElement.textContent = 'Nova Transação';
            // Define a data atual como padrão para novas transações
            Utils.$('transaction-date').value = Utils.getCurrentDateForInput();
            // Garante que campos condicionais comecem escondidos
            Utils.removeClass(Utils.$('credit-card-details'), 'visible');
            Utils.removeClass(Utils.$('recurrent-details'), 'visible');
             // Reseta o <details> de opções avançadas
             const detailsElement = Utils.qs('#transaction-form .advanced-options');
             if(detailsElement) detailsElement.open = false;
        }
    },

    // --- Funções Auxiliares de UI ---

    /**
     * Popula um elemento <select> com opções de um array de dados.
     * @param {HTMLSelectElement | null} selectElement O elemento select.
     * @param {Array<object>} dataArray Array de objetos para as opções.
     * @param {string | null} placeholder Texto da opção inicial desabilitada (ou null para nenhuma).
     * @param {string} valueKey Chave do objeto a ser usada como 'value' da opção.
     * @param {string} textKey Chave do objeto a ser usada como texto visível da opção.
     * @param {boolean} allowEmpty Permitir uma opção com valor vazio selecionável (além do placeholder)?
     */
    async populateSelectWithOptions(selectElement, dataArray, placeholder, valueKey, textKey, allowEmpty = false) {
        if (!selectElement) return;
        // Guarda valor atual para tentar restaurar depois
        const currentValue = selectElement.value;
        selectElement.innerHTML = ''; // Limpa

        // Adiciona placeholder desabilitado
        if (placeholder) {
            const phOption = new Option(placeholder, "");
            phOption.disabled = true;
            selectElement.add(phOption);
        }
        // Adiciona opção vazia selecionável, se permitido
        if(allowEmpty && !placeholder) { // Só adiciona se não houver placeholder, ou ajuste a lógica
             const emptyOption = new Option("Nenhum(a)", "");
             selectElement.add(emptyOption);
        }


        // Adiciona opções do array de dados
        if (dataArray && dataArray.length > 0) {
            dataArray.forEach(item => {
                const value = item[valueKey];
                const text = item[textKey];
                if (value !== undefined && text !== undefined) {
                    const option = new Option(text, value);
                    // Adicionar data-attributes se precisar de mais infos (e.g., cor da categoria)
                    // option.dataset.color = item.color;
                    selectElement.add(option);
                }
            });
        }

         // Tenta restaurar valor anterior ou define placeholder/vazio como selecionado
         if (currentValue && selectElement.querySelector(`option[value="${currentValue}"]`)) {
            selectElement.value = currentValue;
        } else if (!placeholder) { // Se não tem placeholder, seleciona a primeira opção (ou a vazia se existir)
             selectElement.selectedIndex = allowEmpty ? 0 : (selectElement.options.length > 0 ? 0 : -1);
         } else {
              selectElement.value = ""; // Seleciona o placeholder
         }
    },


    // --- Tratamento de Submissão de Formulários (Exemplo: Transação) ---
    /**
     * Lida com a submissão do formulário de transação.
     * @param {Event} event O evento de submissão.
     */
    async handleTransactionFormSubmit(event) {
        event.preventDefault(); // Previne recarregamento da página
        const form = event.target;
        const submitButton = form.querySelector('button[type="submit"]');
        const originalButtonText = submitButton.innerHTML;

        // TODO: Adicionar Validação do Formulário aqui antes de prosseguir

        // Desabilita botão e mostra loading
        submitButton.disabled = true;
        submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Salvando...';

        const formData = UIComponents.serializeForm(form);
        const transactionId = formData.id || null; // Pega ID para saber se é edição

        console.log(`App: Submetendo formulário de transação (${transactionId ? 'Edição' : 'Nova'}). Dados:`, formData);

        let success = false;
        try {
            if (transactionId) {
                // Edição
                delete formData.id; // Remove ID dos dados a serem atualizados
                success = await FirebaseService.transactions.update(transactionId, formData);
            } else {
                // Nova transação
                const newId = await FirebaseService.transactions.add(formData);
                success = !!newId; // Sucesso se um ID foi retornado
            }

            if (success) {
                UIComponents.closeModal(); // Fecha o modal
                UIComponents.showToast(
                    `Transação ${transactionId ? 'atualizada' : 'adicionada'} com sucesso!`,
                    { type: 'success' }
                );
                 // Recarrega o módulo atual para exibir a mudança
                 if (this.state.currentModule && typeof this.state.currentModule.render === 'function') {
                     // Idealmente, o módulo deveria apenas atualizar a lista,
                     // mas recarregar é mais simples por enquanto.
                      await this.loadModule(this.state.currentModuleName); // Recarrega o módulo atual
                 }
            } else {
                 throw new Error("Falha ao salvar no FirebaseService.");
            }

        } catch (error) {
            console.error("App: Erro ao salvar transação:", error);
            UIComponents.showToast(
                `Erro ao salvar transação${transactionId ? ' (Edição)' : ''}. Tente novamente.`,
                { type: 'danger', duration: 7000 }
            );
        } finally {
            // Reabilita botão e restaura texto
            submitButton.disabled = false;
            submitButton.innerHTML = originalButtonText;
        }
    },

     // TODO: Adicionar handlers para submit dos outros formulários (categoria, pessoa, etc.)
     // Ex: handleCategoryFormSubmit, handlePersonFormSubmit...


     // --- Tratamento de Ações da Tabela (Exemplo: Transação) ---
     /**
      * Lida com a solicitação de edição de uma transação vinda da tabela.
      * @param {CustomEvent} event Evento customizado com detail: { transactionId }.
      */
     async handleEditTransactionRequest(event) {
        const { transactionId } = event.detail;
        if (!transactionId) return;

        console.log("App: Recebido pedido para editar transação:", transactionId);
        UIComponents.showLoading(); // Mostra loading rápido
        const transactionData = await FirebaseService.transactions.getById(transactionId);
        UIComponents.hideLoading();

        if (transactionData) {
            await this.prepareTransactionModal(transactionData); // Prepara com dados existentes
            UIComponents.openModal('transaction-modal');
        } else {
             UIComponents.showToast(`Transação ${transactionId} não encontrada.`, { type: 'warning' });
        }
     },

      /**
      * Lida com a solicitação de exclusão de uma transação vinda da tabela.
      * @param {CustomEvent} event Evento customizado com detail: { transactionId, description }.
      */
     handleDeleteTransactionRequest(event) {
         const { transactionId, description } = event.detail;
         if (!transactionId) return;

          console.log("App: Recebido pedido para excluir transação:", transactionId, description);

         // Usa a função showConfirmationDialog (que definiremos depois)
         this.showConfirmationDialog({
             title: 'Confirmar Exclusão',
             message: `Tem certeza que deseja excluir a transação "${description}"? Esta ação não pode ser desfeita.`,
             confirmButtonText: 'Excluir',
             confirmButtonClass: 'btn-danger',
             onConfirm: async () => {
                 console.log("App: Confirmada exclusão da transação:", transactionId);
                 UIComponents.showLoading();
                 const success = await FirebaseService.transactions.remove(transactionId);
                 UIComponents.hideLoading();

                 if (success) {
                     UIComponents.showToast('Transação excluída com sucesso!', { type: 'success' });
                      // Recarrega o módulo atual
                      if (this.state.currentModule && typeof this.state.currentModule.render === 'function') {
                         await this.loadModule(this.state.currentModuleName);
                     }
                 } else {
                     UIComponents.showToast('Erro ao excluir a transação.', { type: 'danger' });
                 }
             }
         });
     },

      // --- Funções a serem adicionadas na Parte 3 ---
      // showConfirmationDialog

}; // Fim do objeto App


// --- Ponto de Entrada da Aplicação ---
document.addEventListener('DOMContentLoaded', () => {
    console.log("DOM Carregado. Registrando módulos e iniciando App...");

    // === REGISTRO DOS MÓDULOS ===
    // Garante que os objetos dos módulos estejam disponíveis antes de App.init()
    App.modules.dashboard = DashboardModule;
    // App.modules.monthlyAnalysis = MonthlyAnalysisModule; // Descomentar quando criar o arquivo
    // App.modules.cashProjection = CashProjectionModule; // Descomentar quando criar o arquivo
    // App.modules.financialGoals = FinancialGoalsModule; // Descomentar quando criar o arquivo
    // App.modules.settings = SettingsModule; // Descomentar quando criar o arquivo

    // === INICIALIZAÇÃO ===
    App.init().catch(error => {
        // Captura erros não tratados na inicialização principal
        console.error("Erro fatal na inicialização do App:", error);
        UIComponents.hideLoading(); // Garante que o loading suma
        UIComponents.renderError("Ocorreu um erro inesperado ao iniciar a aplicação.", "Por favor, recarregue a página ou contate o suporte.");
    });

    // === ADICIONAR LISTENERS GLOBAIS PARA FORMULÁRIOS ===
    // Adiciona listeners aqui para evitar ter que adicioná-los/removê-los a cada renderização de modal
    const transactionForm = Utils.$('transaction-form');
    if(transactionForm) {
        transactionForm.addEventListener('submit', (event) => App.handleTransactionFormSubmit(event));
    }
     // Adicionar listeners para outros forms (category-form, person-form, etc.) aqui...

    // === ADICIONAR LISTENERS GLOBAIS PARA AÇÕES DELEGADAS ===
     document.addEventListener('editTransactionRequest', (event) => App.handleEditTransactionRequest(event));
     document.addEventListener('deleteTransactionRequest', (event) => App.handleDeleteTransactionRequest(event));
      // Adicionar listeners para outras ações (editCategory, deletePerson, etc.) aqui...


});


// ===== FIM: BLOCO 30 ==============================

// ===== INÍCIO: BLOCO 31 ==============================
// ==== JAVASCRIPT - APP PRINCIPAL (app.js) - Parte 3 ====
// Continuação do objeto App...

const App = {
    // ... (código dos Blocos 26 e 30) ...

    // --- Funções de Preparação de Modais (Continuação) ---

    /**
     * Prepara o modal de categoria para adição ou edição.
     * @param {object | null} [categoryData=null] Dados da categoria para edição.
     */
    async prepareCategoryModal(categoryData = null) {
        console.log("App: Preparando modal de categoria. Dados:", categoryData);
        const formId = 'category-form';
        const modalId = 'category-modal';
        const titleElement = Utils.$('category-modal-title');
        const iconInput = Utils.$('category-icon');
        const iconDisplay = Utils.$('category-selected-icon-display');
        const defaultIcon = 'fa-tag'; // Ícone padrão

        UIComponents.resetForm(formId); // Reseta valores e estado visual

        // (Re)Inicializa o seletor de ícones (caso a lista possa mudar ou para garantir estado)
        // Idealmente, a lista de ícones é fixa e pode ser definida em config.js
        const availableIcons = ['fa-tag', 'fa-home', 'fa-shopping-cart', 'fa-utensils', 'fa-car', 'fa-plane', 'fa-bus', 'fa-tshirt', 'fa-pills', 'fa-graduation-cap', 'fa-gamepad', 'fa-gift', 'fa-glass-cheers', 'fa-dog', 'fa-baby', 'fa-money-bill-wave', 'fa-hand-holding-usd', 'fa-piggy-bank', 'fa-donate', 'fa-credit-card', 'fa-heartbeat', 'fa-laptop']; // Exemplo
        UIComponents.setupIconPicker(
            'category-icon-button',
            'category-icon-dropdown',
            'category-icon',
            'category-selected-icon-display',
            availableIcons
        );


        if (categoryData && categoryData.id) {
            // Modo Edição
            if (titleElement) titleElement.textContent = 'Editar Categoria';
            UIComponents.fillForm(formId, categoryData);
            // Garante que o ícone e cor sejam exibidos corretamente após fillForm
             if(iconInput && iconDisplay) {
                 const currentIcon = categoryData.icon || defaultIcon;
                 iconInput.value = currentIcon;
                 iconDisplay.innerHTML = `<i class="fas ${currentIcon}"></i>`;
             }
             const colorInput = Utils.$('category-color');
             if(colorInput) colorInput.value = categoryData.color || '#0A84FF';


        } else {
            // Modo Adição
            if (titleElement) titleElement.textContent = 'Nova Categoria';
             // Garante valores padrão
             if(iconInput && iconDisplay) {
                 iconInput.value = defaultIcon;
                 iconDisplay.innerHTML = `<i class="fas ${defaultIcon}"></i>`;
             }
             Utils.$('category-color').value = '#0A84FF'; // Cor primária padrão
        }
    },

     /**
     * Prepara o modal de pessoa para adição ou edição.
     * @param {object | null} [personData=null] Dados da pessoa para edição.
     */
    async preparePersonModal(personData = null) {
        console.log("App: Preparando modal de pessoa. Dados:", personData);
        const formId = 'person-form';
        const modalId = 'person-modal';
        const titleElement = Utils.$('person-modal-title');
        const avatarColorInput = Utils.$('person-avatar-color');
        const defaultAvatarColor = 'avatar-bg-1';

        UIComponents.resetForm(formId);

        // (Re)Inicializa o seletor de avatar
        const availableAvatarColors = ['avatar-bg-1', 'avatar-bg-2', 'avatar-bg-3', 'avatar-bg-4', 'avatar-bg-5', 'avatar-bg-6', 'avatar-bg-7', 'avatar-bg-8']; // Exemplo
        UIComponents.setupAvatarPicker(
            'person-avatar-grid',
            'person-selected-avatar-display',
            'person-avatar-color',
            availableAvatarColors
        );


        if (personData && personData.id) {
            // Modo Edição
            if (titleElement) titleElement.textContent = 'Editar Pessoa';
            UIComponents.fillForm(formId, { // Passa objeto com a chave correta do input
                 'person-id': personData.id,
                 'person-name': personData.name,
                 'person-avatar-color': personData.avatar || defaultAvatarColor // 'avatar' no DB vira 'person-avatar-color' no form
            });

        } else {
            // Modo Adição
            if (titleElement) titleElement.textContent = 'Nova Pessoa';
             // Garante valor padrão
             avatarColorInput.value = defaultAvatarColor;
             // Atualiza o display (setupAvatarPicker já faz isso, mas garante)
              Utils.$('person-selected-avatar-display').innerHTML = `<div class="avatar avatar-lg ${defaultAvatarColor}" data-initials="?" aria-hidden="true"></div>`;
        }
    },

    /**
     * Prepara o modal de cartão para adição ou edição.
     * @param {object | null} [cardData=null] Dados do cartão para edição.
     */
    async prepareCardModal(cardData = null) {
        console.log("App: Preparando modal de cartão. Dados:", cardData);
        const formId = 'card-form';
        const modalId = 'card-modal';
        const titleElement = Utils.$('card-modal-title');

        UIComponents.resetForm(formId);

        if (cardData && cardData.id) {
            // Modo Edição
            if (titleElement) titleElement.textContent = 'Editar Cartão';
            UIComponents.fillForm(formId, cardData);
             // Garante cor padrão se não houver
             Utils.$('card-color').value = cardData.color || '#FF453A';
        } else {
            // Modo Adição
            if (titleElement) titleElement.textContent = 'Novo Cartão de Crédito';
             // Garante cor padrão
             Utils.$('card-color').value = '#FF453A'; // Vermelho padrão
        }
    },

     /**
     * Prepara o modal de meta para adição ou edição.
     * @param {object | null} [goalData=null] Dados da meta para edição.
     */
     async prepareGoalModal(goalData = null) {
        console.log("App: Preparando modal de meta. Dados:", goalData);
        const formId = 'goal-form';
        const modalId = 'goal-modal';
        const titleElement = Utils.$('goal-modal-title');
        const personSelect = Utils.$('goal-person');
        const iconInput = Utils.$('goal-icon');
        const iconDisplay = Utils.$('goal-selected-icon-display');
        const defaultGoalIcon = 'fa-bullseye';
        const defaultGoalColor = '#FF9F0A'; // Laranja padrão

        UIComponents.resetForm(formId);

         // Popula select de pessoas (permitindo "Para todos")
         await this.populateSelectWithOptions(personSelect, this.state.globalData.persons, null, 'id', 'name', true); // allowEmpty = true

         // Inicializa seletor de ícones para metas
          const goalIcons = ['fa-bullseye', 'fa-piggy-bank', 'fa-car', 'fa-home', 'fa-plane', 'fa-graduation-cap', 'fa-gift', 'fa-heartbeat', 'fa-laptop', 'fa-baby', 'fa-ring']; // Exemplo de ícones para metas
          UIComponents.setupIconPicker(
              'goal-icon-button',
              'goal-icon-dropdown',
              'goal-icon',
              'goal-selected-icon-display',
              goalIcons
          );


        if (goalData && goalData.id) {
            // Modo Edição
            if (titleElement) titleElement.textContent = 'Editar Meta';
            UIComponents.fillForm(formId, goalData);
             // Garante ícone e cor
             if(iconInput && iconDisplay) {
                 const currentIcon = goalData.icon || defaultGoalIcon;
                 iconInput.value = currentIcon;
                 iconDisplay.innerHTML = `<i class="fas ${currentIcon}"></i>`;
             }
             Utils.$('goal-color').value = goalData.color || defaultGoalColor;
        } else {
            // Modo Adição
            if (titleElement) titleElement.textContent = 'Nova Meta Financeira';
             // Garante valores padrão
              if(iconInput && iconDisplay) {
                 iconInput.value = defaultGoalIcon;
                 iconDisplay.innerHTML = `<i class="fas ${defaultGoalIcon}"></i>`;
             }
             Utils.$('goal-color').value = defaultGoalColor;
             Utils.$('goal-person').value = ""; // Define "Para todos" como padrão
        }
    },

    /**
     * Prepara o modal de aporte para uma meta específica.
     * @param {string} goalId ID da meta.
     * @param {string} goalName Nome da meta.
     */
    async prepareContributionModal(goalId, goalName) {
        console.log(`App: Preparando modal de aporte para meta ID: ${goalId}, Nome: ${goalName}`);
        const formId = 'contribution-form';
        const modalId = 'contribution-modal';
        const titleElement = Utils.$('contribution-modal-title');
        const goalNameDisplay = Utils.$('contribution-goal-name-display');

        UIComponents.resetForm(formId);

        // Define título e nome da meta
        if (titleElement) titleElement.textContent = 'Adicionar Aporte';
        if (goalNameDisplay) goalNameDisplay.textContent = goalName || 'Meta não identificada';

        // Define ID da meta e data atual
        Utils.$('contribution-goal-id').value = goalId;
        Utils.$('contribution-date').value = Utils.getCurrentDateForInput();
    },


    // --- Diálogo de Confirmação ---
     /**
      * Exibe um modal de confirmação genérico.
      * @param {object} options Opções do diálogo.
      * @param {string} options.title Título do diálogo.
      * @param {string} options.message Mensagem de confirmação (pode conter HTML básico).
      * @param {string} [options.confirmButtonText='Confirmar'] Texto do botão de confirmação.
      * @param {string} [options.cancelButtonText='Cancelar'] Texto do botão de cancelar.
      * @param {string} [options.confirmButtonClass='btn-danger'] Classe CSS para o botão de confirmação.
      * @param {function} options.onConfirm Função a ser executada se o usuário confirmar.
      * @param {function} [options.onCancel] Função a ser executada se o usuário cancelar (opcional).
      */
     showConfirmationDialog(options = {}) {
        const {
            title = 'Confirmar Ação',
            message = 'Tem certeza?',
            confirmButtonText = 'Confirmar',
            cancelButtonText = 'Cancelar',
            confirmButtonClass = 'btn-danger', // Padrão perigoso
            onConfirm,
            onCancel
        } = options;

        const dialogElement = Utils.$('confirm-dialog');
        if (!dialogElement) return;

        // Preenche o conteúdo do diálogo
        Utils.$('confirm-dialog-title').textContent = title;
        Utils.$('confirm-dialog-message').innerHTML = message; // Permite HTML simples na mensagem

        const confirmBtn = Utils.$('confirm-dialog-confirm-btn');
        const cancelBtn = Utils.$('confirm-dialog-cancel-btn');

        confirmBtn.textContent = confirmButtonText;
        cancelBtn.textContent = cancelButtonText;

        // Remove classes antigas e adiciona a nova classe ao botão de confirmação
        confirmBtn.className = 'btn'; // Reseta classes
        confirmBtn.classList.add(confirmButtonClass);

        // Armazena temporariamente as funções de callback
        // Removendo listeners antigos antes de adicionar novos para evitar duplicação
        const newConfirmHandler = () => {
             UIComponents.closeModal(); // Fecha o diálogo
             if (typeof onConfirm === 'function') {
                 onConfirm();
             }
             // Limpa listeners após execução
             confirmBtn.removeEventListener('click', newConfirmHandler);
             cancelBtn.removeEventListener('click', newCancelHandler);
        };

         const newCancelHandler = () => {
             UIComponents.closeModal(); // Fecha o diálogo
             if (typeof onCancel === 'function') {
                 onCancel();
             }
              // Limpa listeners após execução
             confirmBtn.removeEventListener('click', newConfirmHandler);
             cancelBtn.removeEventListener('click', newCancelHandler);
         };

         // Garante que listeners antigos sejam removidos antes de adicionar novos
         // (Uma abordagem mais robusta seria usar AbortController, mas isso é mais simples)
         confirmBtn.replaceWith(confirmBtn.cloneNode(true)); // Clona para remover listeners antigos
         cancelBtn.replaceWith(cancelBtn.cloneNode(true));
         // Re-seleciona os botões clonados
         const newConfirmBtn = Utils.$('confirm-dialog-confirm-btn');
         const newCancelBtn = Utils.$('confirm-dialog-cancel-btn');

         newConfirmBtn.addEventListener('click', newConfirmHandler);
         newCancelBtn.addEventListener('click', newCancelHandler);


        // Abre o modal de confirmação
        UIComponents.openModal('confirm-dialog');
    },

     // TODO: Adicionar handlers para submit dos formulários restantes
     // handleCategoryFormSubmit, handlePersonFormSubmit, handleCardFormSubmit,
     // handleGoalFormSubmit, handleContributionFormSubmit

     // TODO: Adicionar handlers para requisições de edição/exclusão dos outros itens
     // handleEditCategoryRequest, handleDeleteCategoryRequest, etc.


}; // Fim do objeto App


// ===== FIM: BLOCO 31 ==============================


// ===== INÍCIO: BLOCO 32 ==============================
// ==== JAVASCRIPT - APP PRINCIPAL (app.js) - Parte 4 ====
// Continuação do objeto App...

const App = {
    // ... (código dos Blocos 26, 30, 31) ...

    // --- Tratamento de Submissão de Formulários (Continuação) ---

    /**
     * Lida com a submissão do formulário de Categoria.
     * @param {Event} event O evento de submissão.
     */
    async handleCategoryFormSubmit(event) {
        event.preventDefault();
        const form = event.target;
        const submitButton = form.querySelector('button[type="submit"]');
        if (!submitButton || submitButton.disabled) return;
        const originalButtonText = submitButton.innerHTML;

        submitButton.disabled = true;
        submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Salvando...';

        const formData = UIComponents.serializeForm(form);
        const categoryId = formData.id || null;

        console.log(`App: Submetendo Categoria (${categoryId ? 'Edição' : 'Nova'}). Dados:`, formData);

        let success = false;
        try {
             // TODO: Validação dos dados (nome não pode ser vazio)
             if (!formData.name || formData.name.trim() === '') {
                 throw new Error("O nome da categoria é obrigatório.");
             }

            if (categoryId) {
                 delete formData.id; // Remover ID para atualização
                 // Renomear 'category-icon' para 'icon' se necessário pelo FirebaseService
                 formData.icon = formData['category-icon']; delete formData['category-icon'];
                 formData.color = formData['category-color']; delete formData['category-color'];
                 formData.name = formData['category-name']; delete formData['category-name'];

                success = await FirebaseService.categories.update(categoryId, formData);
            } else {
                 // Renomear campos antes de adicionar
                 formData.icon = formData['category-icon']; delete formData['category-icon'];
                 formData.color = formData['category-color']; delete formData['category-color'];
                 formData.name = formData['category-name']; delete formData['category-name'];

                const newId = await FirebaseService.categories.add(formData);
                success = !!newId;
            }

            if (success) {
                UIComponents.closeModal();
                UIComponents.showToast(`Categoria ${categoryId ? 'atualizada' : 'adicionada'}!`, { type: 'success' });
                await this.loadGlobalData(); // Recarrega categorias globais
                await this.reloadCurrentModuleIf('settings'); // Recarrega Ajustes se for o módulo atual
            } else {
                 throw new Error("Falha ao salvar no FirebaseService.");
            }
        } catch (error) {
            console.error("App: Erro ao salvar categoria:", error);
            UIComponents.showToast(`Erro: ${error.message || 'Não foi possível salvar a categoria.'}`, { type: 'danger' });
        } finally {
            submitButton.disabled = false;
            submitButton.innerHTML = originalButtonText;
        }
    },

     /**
     * Lida com a submissão do formulário de Pessoa.
     * @param {Event} event O evento de submissão.
     */
     async handlePersonFormSubmit(event) {
        event.preventDefault();
        const form = event.target;
        const submitButton = form.querySelector('button[type="submit"]');
         if (!submitButton || submitButton.disabled) return;
        const originalButtonText = submitButton.innerHTML;

        submitButton.disabled = true;
        submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Salvando...';

        const formData = UIComponents.serializeForm(form);
        const personId = formData.id || null;

        console.log(`App: Submetendo Pessoa (${personId ? 'Edição' : 'Nova'}). Dados:`, formData);

        let success = false;
        try {
             if (!formData.name || formData.name.trim() === '') {
                 throw new Error("O nome da pessoa é obrigatório.");
             }

             // Prepara dados para salvar (renomeia/ajusta campos)
             const dataToSave = {
                 name: formData.name,
                 avatar: formData['person-avatar-color'] // Campo do input hidden
             };

            if (personId) {
                 // Não precisa remover ID aqui pois pegamos os dados manualmente
                success = await FirebaseService.persons.update(personId, dataToSave);
            } else {
                const newId = await FirebaseService.persons.add(dataToSave);
                success = !!newId;
            }

            if (success) {
                UIComponents.closeModal();
                UIComponents.showToast(`Pessoa ${personId ? 'atualizada' : 'adicionada'}!`, { type: 'success' });
                await this.loadGlobalData(); // Recarrega pessoas globais
                 await this.reloadCurrentModuleIf('settings'); // Recarrega Ajustes
                 await this.reloadCurrentModuleIf('dashboard'); // Recarrega Dashboard (filtro global)
                 await this.reloadCurrentModuleIf('monthly-analysis'); // Recarrega Análise (filtro global)
            } else {
                 throw new Error("Falha ao salvar no FirebaseService.");
            }
        } catch (error) {
            console.error("App: Erro ao salvar pessoa:", error);
            UIComponents.showToast(`Erro: ${error.message || 'Não foi possível salvar a pessoa.'}`, { type: 'danger' });
        } finally {
            submitButton.disabled = false;
            submitButton.innerHTML = originalButtonText;
        }
    },

     /**
     * Lida com a submissão do formulário de Cartão.
     * @param {Event} event O evento de submissão.
     */
     async handleCardFormSubmit(event) {
        event.preventDefault();
        const form = event.target;
        const submitButton = form.querySelector('button[type="submit"]');
         if (!submitButton || submitButton.disabled) return;
        const originalButtonText = submitButton.innerHTML;

        submitButton.disabled = true;
        submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Salvando...';

        const formData = UIComponents.serializeForm(form);
        const cardId = formData.id || null;

        console.log(`App: Submetendo Cartão (${cardId ? 'Edição' : 'Nova'}). Dados:`, formData);

        let success = false;
        try {
             if (!formData.name || formData.name.trim() === '') {
                 throw new Error("O nome do cartão é obrigatório.");
             }
             // Validações adicionais (dia fechamento/vencimento, etc.) podem ir aqui

             // Prepara dados (converte para número se necessário)
             const dataToSave = {
                 name: formData.name,
                 limit: formData.limit ? parseFloat(formData.limit) || null : null, // Null se vazio ou inválido
                 closingDay: formData.closingDay ? parseInt(formData.closingDay) || null : null,
                 dueDay: formData.dueDay ? parseInt(formData.dueDay) || null : null,
                 color: formData.color || '#FF453A'
             };


            if (cardId) {
                success = await FirebaseService.cards.update(cardId, dataToSave);
            } else {
                const newId = await FirebaseService.cards.add(dataToSave);
                success = !!newId;
            }

            if (success) {
                UIComponents.closeModal();
                UIComponents.showToast(`Cartão ${cardId ? 'atualizado' : 'adicionado'}!`, { type: 'success' });
                await this.loadGlobalData(); // Recarrega cartões globais
                await this.reloadCurrentModuleIf('settings'); // Recarrega Ajustes
            } else {
                 throw new Error("Falha ao salvar no FirebaseService.");
            }
        } catch (error) {
            console.error("App: Erro ao salvar cartão:", error);
            UIComponents.showToast(`Erro: ${error.message || 'Não foi possível salvar o cartão.'}`, { type: 'danger' });
        } finally {
            submitButton.disabled = false;
            submitButton.innerHTML = originalButtonText;
        }
    },

     /**
     * Lida com a submissão do formulário de Meta.
     * @param {Event} event O evento de submissão.
     */
     async handleGoalFormSubmit(event) {
        event.preventDefault();
        const form = event.target;
        const submitButton = form.querySelector('button[type="submit"]');
         if (!submitButton || submitButton.disabled) return;
        const originalButtonText = submitButton.innerHTML;

        submitButton.disabled = true;
        submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Salvando...';

        const formData = UIComponents.serializeForm(form);
        const goalId = formData.id || null;

        console.log(`App: Submetendo Meta (${goalId ? 'Edição' : 'Nova'}). Dados:`, formData);

        let success = false;
        try {
            if (!formData.name || formData.name.trim() === '') throw new Error("O nome da meta é obrigatório.");
            if (!formData.target || parseFloat(formData.target) <= 0) throw new Error("O valor alvo deve ser maior que zero.");
            if (!formData.deadline) throw new Error("O prazo final é obrigatório.");

            // Prepara dados
            const dataToSave = {
                name: formData.name,
                target: parseFloat(formData.target),
                deadline: formData.deadline, // Já está no formato aaaa-mm-dd
                personId: formData.person || null, // Pode ser null se 'Para todos'
                icon: formData.icon || 'fa-bullseye',
                color: formData.color || '#FF9F0A',
                purpose: formData.purpose || '',
            };

            if (goalId) {
                success = await FirebaseService.goals.update(goalId, dataToSave);
            } else {
                const newId = await FirebaseService.goals.add(dataToSave);
                success = !!newId;
            }

            if (success) {
                UIComponents.closeModal();
                UIComponents.showToast(`Meta ${goalId ? 'atualizada' : 'adicionada'}!`, { type: 'success' });
                await this.reloadCurrentModuleIf('financial-goals'); // Recarrega módulo de metas
            } else {
                 throw new Error("Falha ao salvar no FirebaseService.");
            }
        } catch (error) {
            console.error("App: Erro ao salvar meta:", error);
            UIComponents.showToast(`Erro: ${error.message || 'Não foi possível salvar a meta.'}`, { type: 'danger' });
        } finally {
            submitButton.disabled = false;
            submitButton.innerHTML = originalButtonText;
        }
    },

     /**
     * Lida com a submissão do formulário de Aporte.
     * @param {Event} event O evento de submissão.
     */
     async handleContributionFormSubmit(event) {
        event.preventDefault();
        const form = event.target;
        const submitButton = form.querySelector('button[type="submit"]');
         if (!submitButton || submitButton.disabled) return;
        const originalButtonText = submitButton.innerHTML;

        submitButton.disabled = true;
        submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Salvando...';

        const formData = UIComponents.serializeForm(form);
        const contributionId = formData.id || null; // Para futuras edições, se necessário
        const goalId = formData['contribution-goal-id'];

        console.log(`App: Submetendo Aporte (${contributionId ? 'Edição' : 'Novo'}). Meta ID: ${goalId}. Dados:`, formData);

        let success = false;
        try {
            if (!goalId) throw new Error("ID da meta não encontrado.");
            if (!formData.amount || parseFloat(formData.amount) <= 0) throw new Error("O valor do aporte deve ser maior que zero.");
            if (!formData.date) throw new Error("A data do aporte é obrigatória.");

            // Prepara dados
            const dataToSave = {
                goalId: goalId,
                amount: parseFloat(formData.amount),
                date: formData.date, // Já está aaaa-mm-dd
                notes: formData.notes || ''
            };

            if (contributionId) {
                // Lógica de Edição (se implementada no futuro)
                // success = await FirebaseService.contributions.update(contributionId, dataToSave);
                throw new Error("Edição de aportes ainda não implementada."); // Remover se implementar
            } else {
                const newId = await FirebaseService.contributions.add(dataToSave);
                success = !!newId;
            }

            if (success) {
                UIComponents.closeModal();
                UIComponents.showToast(`Aporte ${contributionId ? 'atualizado' : 'adicionado'}!`, { type: 'success' });
                await this.reloadCurrentModuleIf('financial-goals'); // Recarrega módulo de metas
            } else {
                 throw new Error("Falha ao salvar no FirebaseService.");
            }
        } catch (error) {
            console.error("App: Erro ao salvar aporte:", error);
            UIComponents.showToast(`Erro: ${error.message || 'Não foi possível salvar o aporte.'}`, { type: 'danger' });
        } finally {
            submitButton.disabled = false;
            submitButton.innerHTML = originalButtonText;
        }
    },


    // --- Tratamento de Ações Delegadas (Continuação) ---

    // TODO: Implementar handlers para edição/exclusão de Categoria, Pessoa, Cartão, Meta
    // Exemplo: handleEditCategoryRequest, handleDeletePersonRequest...
    // Eles seguirão um padrão similar ao handleEditTransactionRequest e handleDeleteTransactionRequest:
    // 1. Receber o evento com o ID do item.
    // 2. Buscar os dados do item no FirebaseService.
    // 3. Chamar a função `prepare...Modal` correspondente com os dados.
    // 4. Abrir o modal (`UIComponents.openModal`).
    // Ou, para exclusão:
    // 1. Chamar `App.showConfirmationDialog`.
    // 2. Dentro do `onConfirm`, chamar a função `remove` do FirebaseService.
    // 3. Mostrar Toast de sucesso/erro.
    // 4. Recarregar dados globais e/ou o módulo atual.


    // --- Função Auxiliar para Recarregar Módulo ---
    /**
     * Recarrega o módulo atual SE ele for o módulo especificado.
     * @param {string} moduleNameToReload Nome do módulo que deve ser recarregado.
     */
     async reloadCurrentModuleIf(moduleNameToReload) {
         if (this.state.currentModuleName === moduleNameToReload) {
             console.log(`App: Recarregando módulo '${moduleNameToReload}'...`);
             await this.loadModule(moduleNameToReload); // Usa loadModule para garantir ciclo completo
         }
     }

}; // Fim do objeto App


// --- Ponto de Entrada da Aplicação (Registro de Módulos e Init - já no Bloco 30) ---
// ... (código do final do Bloco 30) ...

// --- ADICIONAR LISTENERS GLOBAIS PARA FORMULÁRIOS (Continuação) ---
// Adiciona listeners para os novos formulários
document.addEventListener('DOMContentLoaded', () => {
     // ... (listeners do Bloco 30: transaction-form, editTransactionRequest, deleteTransactionRequest) ...

     const categoryForm = Utils.$('category-form');
     if(categoryForm) categoryForm.addEventListener('submit', (e) => App.handleCategoryFormSubmit(e));

     const personForm = Utils.$('person-form');
     if(personForm) personForm.addEventListener('submit', (e) => App.handlePersonFormSubmit(e));

     const cardForm = Utils.$('card-form');
     if(cardForm) cardForm.addEventListener('submit', (e) => App.handleCardFormSubmit(e));

     const goalForm = Utils.$('goal-form');
     if(goalForm) goalForm.addEventListener('submit', (e) => App.handleGoalFormSubmit(e));

     const contributionForm = Utils.$('contribution-form');
     if(contributionForm) contributionForm.addEventListener('submit', (e) => App.handleContributionFormSubmit(e));

     // TODO: Adicionar listeners para as outras ações delegadas (edit/delete Category, Person, etc.)
     // document.addEventListener('editCategoryRequest', (e) => App.handleEditCategoryRequest(e));
     // document.addEventListener('deleteCategoryRequest', (e) => App.handleDeleteCategoryRequest(e));
     // ... etc ...
});


// ===== FIM: BLOCO 32 ==============================

// ===== INÍCIO: BLOCO 33 ==============================
// ==== JAVASCRIPT - MÓDULO ANÁLISE MENSAL (modules/monthlyAnalysis.js) ====
// Depende de: utils.js, firebaseService.js, uiComponents.js, app.js (para App.templates)

const MonthlyAnalysisModule = (() => { // IIFE

    // --- Referências a Elementos do Módulo ---
    let elements = {};

    // --- Estado Interno do Módulo ---
    let state = {
        transactions: [], // Transações do mês/filtros atuais
        categories: [],
        persons: [],
        cards: [],
        currentFilters: {}, // Recebe filtros globais + filtros locais
        appliedLocalFilters: {}, // Armazena os filtros aplicados localmente
    };

    // --- Funções Privadas ---

    /**
     * Busca as transações para o mês selecionado nos filtros globais.
     * @param {object} globalFilters Filtros globais (monthYear, personId).
     */
    async function fetchData(globalFilters) {
        console.log("Análise Mensal: Buscando dados com filtros globais:", globalFilters);
        state.currentFilters = { ...globalFilters, ...state.appliedLocalFilters }; // Combina filtros

        // Busca transações APENAS do mês/ano global selecionado
        // A filtragem adicional (categoria, tipo, etc.) será feita localmente por enquanto.
        // Poderia ser otimizado buscando já filtrado do Firebase se necessário.
        const monthlyTransactions = await FirebaseService.transactions.getByMonth(globalFilters.monthYear);

        // Filtra também pela pessoa global selecionada
        state.transactions = monthlyTransactions.filter(t => {
             return globalFilters.personId === 'all' || t.personId === globalFilters.personId;
        });


        // Pega dados globais já carregados
        state.categories = App.state.globalData.categories;
        state.persons = App.state.globalData.persons;
        state.cards = App.state.globalData.cards;

        console.log(`Análise Mensal: ${state.transactions.length} transações encontradas para ${globalFilters.monthYear}.`);
    }

     /**
     * Aplica os filtros locais (categoria, tipo, pagamento, etc.) às transações já carregadas.
     * @returns {Array<object>} Array de transações filtradas e ordenadas.
     */
     function applyLocalFiltersAndSort() {
        let filtered = [...state.transactions]; // Cria cópia para não modificar original

         const categoryFilter = state.currentFilters['ma-category-filter'];
         const paymentFilter = state.currentFilters['ma-payment-filter'];
         const typeFilter = state.currentFilters['ma-type-filter'];
         const sortFilter = state.currentFilters['ma-sort-filter'] || 'date-desc'; // Padrão

         // 1. Aplicar filtros
         if (categoryFilter && categoryFilter !== 'all') {
             filtered = filtered.filter(t => t.categoryId === categoryFilter);
         }
         if (paymentFilter && paymentFilter !== 'all') {
             filtered = filtered.filter(t => t.paymentMethod === paymentFilter);
         }
          if (typeFilter && typeFilter !== 'all') {
             filtered = filtered.filter(t => t.type === typeFilter);
         }
          // TODO: Adicionar filtro de prioridade se existir o campo no HTML

         // 2. Aplicar ordenação
         filtered.sort((a, b) => {
            // Converte datas para comparação (Timestamp ou Date)
             const dateA = a.date instanceof firebase.firestore.Timestamp ? a.date.toMillis() : new Date(a.date).getTime();
             const dateB = b.date instanceof firebase.firestore.Timestamp ? b.date.toMillis() : new Date(b.date).getTime();
             const amountA = a.amount || 0;
             const amountB = b.amount || 0;
             const descA = a.description?.toLowerCase() || '';
             const descB = b.description?.toLowerCase() || '';


             switch (sortFilter) {
                 case 'date-asc': return dateA - dateB;
                 case 'amount-desc': return amountB - amountA;
                 case 'amount-asc': return amountA - amountB;
                 case 'description-asc': return descA.localeCompare(descB);
                 case 'date-desc': // Fallback e padrão
                 default: return dateB - dateA;
             }
         });

         console.log("Análise Mensal: Filtros locais aplicados, resultado:", filtered.length, "transações.");
         return filtered;
     }


    /**
     * Renderiza os cards de resumo do mês.
     * @param {Array<object>} filteredTransactions Transações após aplicação de TODOS os filtros.
     */
    function renderSummary(filteredTransactions) {
        if (!elements.monthlySummaryGrid) return;
        elements.monthlySummaryGrid.innerHTML = ''; // Limpa

        const totalIncome = filteredTransactions
            .filter(t => t.type === 'income')
            .reduce((sum, t) => sum + t.amount, 0);
        const totalExpense = filteredTransactions
            .filter(t => t.type === 'expense')
            .reduce((sum, t) => sum + t.amount, 0);
        const balance = totalIncome - totalExpense;

        // Cria e adiciona cards de resumo
        elements.monthlySummaryGrid.appendChild(
            UIComponents.createSummaryCard({ // Função a ser criada em UIComponents
                title: 'Receitas',
                value: Utils.formatCurrency(totalIncome),
                icon: 'fa-arrow-up',
                type: 'income'
            })
        );
         elements.monthlySummaryGrid.appendChild(
            UIComponents.createSummaryCard({
                title: 'Despesas',
                value: Utils.formatCurrency(totalExpense),
                icon: 'fa-arrow-down',
                type: 'expense'
            })
        );
          elements.monthlySummaryGrid.appendChild(
            UIComponents.createSummaryCard({
                title: 'Saldo',
                value: Utils.formatCurrency(balance),
                icon: balance >= 0 ? 'fa-equals' : 'fa-exclamation-triangle', // Mudei ícone
                type: 'balance',
                isNegative: balance < 0
            })
        );
         console.log("Análise Mensal: Resumo renderizado.");
    }

    /**
     * Renderiza a tabela de transações detalhadas.
      * @param {Array<object>} filteredTransactions Transações após aplicação de TODOS os filtros.
     */
    function renderTransactionsTable(filteredTransactions) {
         const container = elements.monthlyTransactionsTableContainer;
        if (!container) return;

        const loadingPlaceholder = container.querySelector('.table-loading-placeholder');
        if (loadingPlaceholder) loadingPlaceholder.style.display = 'none';

        container.innerHTML = ''; // Limpa antes de adicionar a tabela

        // Define as colunas desejadas para esta tabela específica
        const columns = ['date', 'description', 'category', 'person', 'payment', 'amount', 'actions'];

        container.appendChild(
            UIComponents.createTransactionsTable(
                filteredTransactions,
                state.categories,
                state.persons,
                state.cards,
                columns // Passa a ordem das colunas
            )
        );
        console.log("Análise Mensal: Tabela de transações renderizada.");
    }

     /**
     * Configura os listeners para os filtros locais do módulo.
     */
     function setupLocalFilters() {
         const form = elements.filtersForm;
         if (!form) return;

         const applyButton = elements.applyFiltersButton; // Botão Aplicar
         const filterInputs = form.querySelectorAll('select'); // Pega todos os selects

         // Função para aplicar filtros e re-renderizar tabela/resumo
         const applyFiltersAndRender = () => {
             console.log("Análise Mensal: Aplicando filtros locais...");
              // Atualiza o estado com os valores atuais dos filtros locais
             filterInputs.forEach(input => {
                 state.appliedLocalFilters[input.id] = input.value;
             });
              state.currentFilters = { ...App.state.currentFilters, ...state.appliedLocalFilters }; // Atualiza filtros combinados

              const filteredAndSorted = applyLocalFiltersAndSort();
              renderSummary(filteredAndSorted); // Re-renderiza resumo com dados filtrados
              renderTransactionsTable(filteredAndSorted); // Re-renderiza tabela
         };

         // Listener no botão Aplicar (se existir)
         applyButton?.addEventListener('click', applyFiltersAndRender);

         // Opcional: Atualizar dinamicamente ao mudar um select (sem botão)
         // Comentado por padrão para usar o botão 'Aplicar'
         /*
         filterInputs.forEach(input => {
             input.addEventListener('change', () => {
                  // Usar debounce pode ser bom aqui se a atualização for pesada
                  applyFiltersAndRender();
             });
         });
         */

         // Listener para botão de Limpar Filtros
         elements.resetFiltersButton?.addEventListener('click', () => {
             console.log("Análise Mensal: Limpando filtros locais...");
             form.reset(); // Reseta o formulário
             state.appliedLocalFilters = {}; // Limpa filtros locais aplicados
             // Dispara a aplicação para re-renderizar com filtros limpos
             applyFiltersAndRender();
         });
     }

    // --- Funções Públicas do Módulo ---
    return {
        /**
         * Inicializa o módulo (opcional).
         */
        async init() {
            console.log("MonthlyAnalysisModule: Inicializando...");
            state.appliedLocalFilters = {}; // Reseta filtros locais ao inicializar
        },

        /**
         * Renderiza o conteúdo do módulo Análise Mensal.
         * @param {object} filters Filtros globais recebidos do App (monthYear, personId).
         */
        async render(filters) {
            console.log("MonthlyAnalysisModule: Renderizando com filtros globais:", filters);
            state.currentFilters = { ...filters }; // Armazena filtros globais

             // 1. Renderiza HTML base
             UIComponents.renderContent(App.templates['monthlyAnalysis']); // Usa template HTML

             // 2. Seleciona elementos DOM do módulo
             elements = {
                 filtersForm: Utils.$('monthly-analysis-filters-form'),
                 applyFiltersButton: Utils.$('apply-ma-filters-btn'),
                 resetFiltersButton: Utils.$('reset-filters-btn'),
                 monthlySummaryGrid: Utils.$('monthly-summary-grid'),
                 monthlyTransactionsTableContainer: Utils.$('monthly-transactions-table-container'),
                 categoryFilter: Utils.$('ma-category-filter'),
                 // Adicionar outros selects de filtro aqui...
             };

             // 3. Popula selects de filtro que dependem de dados globais
             App.populateSelectWithOptions(elements.categoryFilter, App.state.globalData.categories, 'Todas as Categorias', 'id', 'name', true);
             // TODO: Popular outros filtros se necessário (Prioridade?)

             // 4. Busca dados iniciais com base nos filtros globais
             await fetchData(filters);

             // 5. Aplica filtros locais (se houver algum salvo) e ordena
             const initialFilteredAndSorted = applyLocalFiltersAndSort();

             // 6. Renderiza resumo e tabela com dados filtrados iniciais
             renderSummary(initialFilteredAndSorted);
             renderTransactionsTable(initialFilteredAndSorted);

             // 7. Configura listeners dos filtros locais
             setupLocalFilters();

             console.log("MonthlyAnalysisModule: Renderização concluída.");
        },

        /**
         * Limpa recursos do módulo ao sair.
         */
        destroy() {
            console.log("MonthlyAnalysisModule: Destruindo...");
            // Remover listeners específicos se necessário
            elements = {};
            state.appliedLocalFilters = {}; // Limpa filtros locais ao sair
        }
    };

})(); // Fim da IIFE

// ===== FIM: BLOCO 33 ==============================

// ===== INÍCIO: BLOCO 34 ==============================
// ==== JAVASCRIPT - COMPONENTES UI (uiComponents.js) - Parte 6 ====
// Adicionar esta função dentro do objeto UIComponents

const UIComponents = {
    // ... (código dos Blocos 23, 24, 25, 28, 29) ...

    /**
     * Cria e retorna um elemento HTML para um card de resumo.
     * Usado em módulos como Análise Mensal.
     * @param {object} options Opções para o card de resumo.
     * @param {string} options.title Título do resumo (e.g., "Receitas", "Saldo").
     * @param {string} options.value Valor principal a ser exibido (já formatado).
     * @param {string} [options.icon] Classe Font Awesome do ícone (e.g., 'fa-arrow-up').
     * @param {string} [options.type] Tipo semântico ('income', 'expense', 'balance'). Define a cor do ícone.
     * @param {boolean} [options.isNegative=false] Usado com type='balance' para estilizar valor negativo.
     * @param {string} [options.cssClass] Classes CSS adicionais para o card.
     * @returns {HTMLElement} O elemento div do card de resumo criado.
     */
    createSummaryCard(options = {}) {
        const {
            title = 'Resumo',
            value = '---',
            icon = 'fa-info-circle',
            type = 'neutral', // income, expense, balance, neutral
            isNegative = false,
            cssClass = ''
        } = options;

        const card = document.createElement('div');
        card.className = `summary-card summary-${type} ${cssClass}`;
        if (type === 'balance' && isNegative) {
            card.classList.add('negative');
        }

        // 1. Ícone
        const iconWrapper = document.createElement('div');
        iconWrapper.className = 'summary-icon';
        const iconElement = document.createElement('i');
        iconElement.className = `fas ${icon}`;
        iconWrapper.appendChild(iconElement);
        card.appendChild(iconWrapper);

        // 2. Conteúdo (Título e Valor)
        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'summary-content';

        const summaryTitle = document.createElement('span');
        summaryTitle.className = 'summary-title';
        summaryTitle.textContent = title;
        contentWrapper.appendChild(summaryTitle);

        const summaryValue = document.createElement('span');
        summaryValue.className = 'summary-value';
        summaryValue.innerHTML = value; // Permite HTML se necessário

        // Aplica classe de cor ao valor se for Receita, Despesa ou Saldo Negativo
        if (type === 'income') summaryValue.classList.add('positive-value');
        else if (type === 'expense') summaryValue.classList.add('negative-value');
        else if (type === 'balance' && isNegative) summaryValue.classList.add('negative-value');
        // Não adiciona classe para saldo positivo, usa a cor padrão de texto primário

        contentWrapper.appendChild(summaryValue);
        card.appendChild(contentWrapper);

        return card;
    },

    // ... (restante do código UIComponents) ...

}; // Fim do objeto UIComponents

// ===== FIM: BLOCO 34 ==============================

// ===== INÍCIO: BLOCO 35 ==============================
// ==== JAVASCRIPT - MÓDULO PROJEÇÃO DE CAIXA (modules/cashProjection.js) ====
// Depende de: utils.js, firebaseService.js, uiComponents.js, app.js

const CashProjectionModule = (() => { // IIFE

    // --- Referências a Elementos do Módulo ---
    let elements = {};

    // --- Estado Interno do Módulo ---
    let state = {
        allTransactions: [], // Todas as transações carregadas
        projectionData: [], // Dados calculados da projeção (array de objetos por período)
        currentBalance: 0, // Saldo atual calculado
        projectionSettings: { // Configurações atuais da projeção
            periodMonths: 6, // Padrão: 6 meses
            startDate: null, // Para período customizado
            endDate: null, // Para período customizado
            includeRecurring: true,
            includeInstallments: true,
            includeGoals: false, // Aportes de metas (futuro)
        },
        chartInstance: null, // Instância do gráfico Chart.js
    };

    // --- Funções Privadas ---

    /**
     * Busca TODOS os dados de transações necessários para a projeção.
     * Idealmente, poderia buscar apenas transações a partir de uma data relevante.
     */
    async function fetchData() {
        console.log("Projeção Caixa: Buscando todas as transações...");
        try {
            // Por enquanto, busca todas. Otimizar depois se necessário.
            state.allTransactions = await FirebaseService.transactions.getAll();
            console.log(`Projeção Caixa: ${state.allTransactions.length} transações totais encontradas.`);
        } catch (error) {
            console.error("Projeção Caixa: Erro ao buscar dados:", error);
            UIComponents.renderError("Erro ao carregar dados para a projeção.");
            state.allTransactions = [];
        }
    }

    /**
     * Calcula os dados da projeção com base nas transações e configurações.
     */
    function calculateProjection() {
        console.log("Projeção Caixa: Calculando projeção com configurações:", state.projectionSettings);
        state.projectionData = []; // Limpa dados antigos
        state.currentBalance = 0; // Reseta saldo atual

        if (state.allTransactions.length === 0) {
            console.warn("Projeção Caixa: Sem transações para calcular.");
            return;
        }

        const now = new Date();
        const today = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate())); // Dia atual em UTC

        // 1. Calcular Saldo Atual (até hoje)
        state.currentBalance = state.allTransactions
            .filter(t => {
                const transactionDate = t.date instanceof firebase.firestore.Timestamp ? t.date.toDate() : new Date(t.date);
                 // Compara apenas a data, ignorando hora, em UTC
                 const transactionDay = new Date(Date.UTC(transactionDate.getFullYear(), transactionDate.getMonth(), transactionDate.getDate()));
                return transactionDay <= today;
            })
            .reduce((balance, t) => balance + (t.type === 'income' ? t.amount : -t.amount), 0);

        console.log("Projeção Caixa: Saldo Atual Calculado:", state.currentBalance);

        // 2. Determinar Período da Projeção
        let projectionEndDate;
        const startDate = new Date(today); // Começa a projeção a partir de amanhã
        startDate.setUTCDate(startDate.getUTCDate() + 1);

        if (state.projectionSettings.endDate) {
            // Período Customizado (garante que seja Date object)
            projectionEndDate = new Date(state.projectionSettings.endDate + 'T23:59:59Z'); // Fim do dia selecionado
             // Ajusta data inicial se customizada
             if(state.projectionSettings.startDate) {
                  const customStartDate = new Date(state.projectionSettings.startDate + 'T00:00:00Z');
                  if(customStartDate > startDate) startDate.setTime(customStartDate.getTime());
             }

        } else {
            // Período padrão (N meses)
            projectionEndDate = new Date(startDate);
            projectionEndDate.setUTCMonth(projectionEndDate.getUTCMonth() + state.projectionSettings.periodMonths);
             projectionEndDate.setUTCDate(0); // Vai para o último dia do mês anterior ao N+1 (ou seja, último dia do N)
             projectionEndDate.setUTCHours(23,59,59,999); // Garante fim do dia
        }

         console.log(`Projeção Caixa: Período de ${Utils.formatDate(startDate)} a ${Utils.formatDate(projectionEndDate)}`);

        // 3. Filtrar Transações Futuras Relevantes
        const futureTransactions = state.allTransactions.filter(t => {
            const transactionDate = t.date instanceof firebase.firestore.Timestamp ? t.date.toDate() : new Date(t.date);
            // Pega data em UTC para comparação
            const transactionDay = new Date(Date.UTC(transactionDate.getFullYear(), transactionDate.getMonth(), transactionDate.getDate()));

            if (transactionDay < startDate || transactionDay > projectionEndDate) {
                return false; // Fora do período de projeção
            }

            // Filtra por tipo incluído nas configurações
            if (t.isRecurrent && !state.projectionSettings.includeRecurring) return false;
            if (t.installments && t.installments > 1 && !state.projectionSettings.includeInstallments) return false;
            // TODO: Adicionar filtro de metas se 'includeGoals' for true

            return true;
        });

        console.log(`Projeção Caixa: ${futureTransactions.length} transações futuras consideradas.`);

        // 4. Agrupar por Mês e Calcular Saldos
        const monthlyProjection = {}; // Objeto para agrupar: {'aaaa-mm': { income, expense }}
        futureTransactions.forEach(t => {
            const transactionDate = t.date instanceof firebase.firestore.Timestamp ? t.date.toDate() : new Date(t.date);
            const yearMonth = `${transactionDate.getUTCFullYear()}-${String(transactionDate.getUTCMonth() + 1).padStart(2, '0')}`;

            if (!monthlyProjection[yearMonth]) {
                monthlyProjection[yearMonth] = { income: 0, expense: 0, periodLabel: Utils.formatMonthYear(yearMonth) };
            }

            if (t.type === 'income') {
                monthlyProjection[yearMonth].income += t.amount;
            } else {
                monthlyProjection[yearMonth].expense += t.amount;
            }
        });

        // 5. Ordenar Meses e Calcular Saldo Acumulado
        const sortedMonths = Object.keys(monthlyProjection).sort();
        let runningBalance = state.currentBalance;

        sortedMonths.forEach(monthKey => {
            const monthData = monthlyProjection[monthKey];
            const monthlyBalance = monthData.income - monthData.expense;
            runningBalance += monthlyBalance;

            state.projectionData.push({
                period: monthKey, // 'aaaa-mm'
                periodLabel: monthData.periodLabel, // 'Mês Ano'
                income: monthData.income,
                expense: monthData.expense,
                balance: monthlyBalance,
                accumulatedBalance: runningBalance
            });
        });

        console.log("Projeção Caixa: Cálculo concluído:", state.projectionData);
    }

    /**
     * Renderiza os cards de resumo da projeção.
     */
    function renderSummary() {
        if (!elements.projectionSummaryGrid) return;
        elements.projectionSummaryGrid.innerHTML = ''; // Limpa

        const finalProjection = state.projectionData[state.projectionData.length - 1];
        const projectedFinalBalance = finalProjection ? finalProjection.accumulatedBalance : state.currentBalance;

         // Calcular totais de entradas/saídas futuras no período projetado
         const totalFutureIncome = state.projectionData.reduce((sum, p) => sum + p.income, 0);
         const totalFutureExpense = state.projectionData.reduce((sum, p) => sum + p.expense, 0);


        elements.projectionSummaryGrid.appendChild(
            UIComponents.createSummaryCard({
                title: 'Saldo Atual',
                value: Utils.formatCurrency(state.currentBalance),
                icon: 'fa-wallet',
                type: 'balance',
                isNegative: state.currentBalance < 0
            })
        );
         elements.projectionSummaryGrid.appendChild(
            UIComponents.createSummaryCard({
                title: 'Entradas Projetadas',
                 value: Utils.formatCurrency(totalFutureIncome),
                icon: 'fa-arrow-up',
                type: 'income'
            })
        );
         elements.projectionSummaryGrid.appendChild(
            UIComponents.createSummaryCard({
                title: 'Saídas Projetadas',
                 value: Utils.formatCurrency(totalFutureExpense),
                icon: 'fa-arrow-down',
                type: 'expense'
            })
        );
         elements.projectionSummaryGrid.appendChild(
            UIComponents.createSummaryCard({
                title: 'Saldo Final Projetado',
                value: Utils.formatCurrency(projectedFinalBalance),
                icon: 'fa-flag-checkered',
                type: 'balance',
                isNegative: projectedFinalBalance < 0
            })
        );
         console.log("Projeção Caixa: Resumo renderizado.");
    }

    /**
     * Renderiza o gráfico de evolução do saldo.
     */
    function renderProjectionChart() {
        const canvas = elements.projectionChart;
        const container = elements.projectionChartContainer;
        const emptyMessage = container?.querySelector('.chart-empty-message');

        // Destroi gráfico anterior
         if (state.chartInstance) {
             state.chartInstance.destroy();
             state.chartInstance = null;
         }

        if (!canvas || !container || !emptyMessage) return;

        if (state.projectionData.length === 0) {
            canvas.style.display = 'none';
            emptyMessage.style.display = 'flex'; // Mostra mensagem de vazio
            return;
        } else {
            canvas.style.display = 'block';
            emptyMessage.style.display = 'none'; // Esconde mensagem
        }

        // Prepara dados para o gráfico
        const labels = ['Saldo Atual', ...state.projectionData.map(p => p.periodLabel)];
        const data = [state.currentBalance, ...state.projectionData.map(p => p.accumulatedBalance)];

        // Define cores dinâmicas para linha/ponto baseado em positivo/negativo
         const pointBackgroundColors = data.map(value => value >= 0 ? Utils.getCssVariable('--color-success') : Utils.getCssVariable('--color-danger'));
         const segmentColors = (ctx, value) => ctx.p0.parsed.y >= 0 && ctx.p1.parsed.y >= 0 ? Utils.getCssVariable('--color-success') : (ctx.p0.parsed.y < 0 && ctx.p1.parsed.y < 0 ? Utils.getCssVariable('--color-danger') : Utils.getCssVariable('--color-warning')); // Linha laranja se cruzar zero


        state.chartInstance = new Chart(canvas.getContext('2d'), {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Saldo Projetado',
                    data: data,
                    fill: false, // Sem preenchimento abaixo da linha
                    borderColor: Utils.getCssVariable('--color-primary'), // Cor padrão da linha (pode ser sobrescrita por segment)
                    // Cor da linha por segmento (se cruzar zero)
                     segment: {
                          borderColor: ctx => segmentColors(ctx, 'border'),
                     },
                    tension: 0.1, // Linha ligeiramente curvada
                    pointBackgroundColor: pointBackgroundColors,
                    pointBorderColor: pointBackgroundColors,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        ticks: { callback: value => Utils.formatCurrency(value, false) }
                    }
                },
                plugins: {
                    legend: { display: false }, // Esconde legenda padrão
                    tooltip: {
                        callbacks: {
                             label: function(context) {
                                 return `${context.label}: ${Utils.formatCurrency(context.parsed.y)}`;
                             }
                        }
                    }
                }
            }
        });
        console.log("Projeção Caixa: Gráfico renderizado.");
    }

    /**
     * Renderiza a tabela detalhada da projeção.
     */
    function renderDetailsTable() {
         const container = elements.projectionDetailsTableContainer;
        if (!container) return;

        const loadingPlaceholder = container.querySelector('.table-loading-placeholder');
        if (loadingPlaceholder) loadingPlaceholder.style.display = 'none';

        container.innerHTML = ''; // Limpa antes

        if (state.projectionData.length === 0) {
             container.innerHTML = `<div class="table-empty-row"><td colspan="5">Não foi possível gerar o detalhamento da projeção.</td></div>`;
             return;
        }

        const table = document.createElement('table');
        table.className = 'table projection-details-table';
        table.id = 'projection-details-table';

         // Cabeçalho
         const thead = table.createTHead();
         const headerRow = thead.insertRow();
         ['Período', 'Entradas', 'Saídas', 'Saldo do Período', 'Saldo Acumulado'].forEach(text => {
             const th = document.createElement('th');
             th.textContent = text;
              if (['Entradas', 'Saídas', 'Saldo do Período', 'Saldo Acumulado'].includes(text)) {
                 th.classList.add('currency');
             }
             headerRow.appendChild(th);
         });

         // Corpo
         const tbody = table.createTBody();
          // Linha do Saldo Atual (como referência)
         const currentRow = tbody.insertRow();
         currentRow.insertCell().textContent = 'Saldo Atual';
         currentRow.insertCell().textContent = '-';
         currentRow.insertCell().textContent = '-';
         currentRow.insertCell().textContent = '-';
         const currentBalanceCell = currentRow.insertCell();
         currentBalanceCell.textContent = Utils.formatCurrency(state.currentBalance);
         currentBalanceCell.classList.add('currency', state.currentBalance >= 0 ? 'positive-value' : 'negative-value');


         // Linhas da projeção
         state.projectionData.forEach(period => {
             const row = tbody.insertRow();
             row.insertCell().textContent = period.periodLabel;

             const incomeCell = row.insertCell();
             incomeCell.textContent = Utils.formatCurrency(period.income);
             incomeCell.classList.add('currency', 'positive-value');

             const expenseCell = row.insertCell();
             expenseCell.textContent = Utils.formatCurrency(period.expense);
             expenseCell.classList.add('currency', 'negative-value');

             const balanceCell = row.insertCell();
             balanceCell.textContent = Utils.formatCurrency(period.balance);
             balanceCell.classList.add('currency', period.balance >= 0 ? 'positive-value' : 'negative-value');

             const accumulatedCell = row.insertCell();
             accumulatedCell.textContent = Utils.formatCurrency(period.accumulatedBalance);
              accumulatedCell.classList.add('currency', period.accumulatedBalance >= 0 ? 'positive-value' : 'negative-value');
         });

         container.appendChild(table);
         console.log("Projeção Caixa: Tabela de detalhes renderizada.");
    }

    /**
     * Configura os listeners para os controles e filtros do módulo.
     */
    function setupProjectionControls() {
        const periodSelect = elements.periodFilter;
        const customRangeContainer = elements.customDateRangeContainer;
        const startDateInput = elements.projectionStartDate;
        const endDateInput = elements.projectionEndDate;
        const includeCheckboxes = elements.filtersForm?.querySelectorAll('.form-check-input');

         // Mostrar/Esconder período customizado
         periodSelect?.addEventListener('change', () => {
             const showCustom = periodSelect.value === 'custom';
              if(customRangeContainer) customRangeContainer.style.display = showCustom ? 'flex' : 'none';
              if (!showCustom) {
                  state.projectionSettings.periodMonths = parseInt(periodSelect.value, 10);
                  state.projectionSettings.startDate = null;
                  state.projectionSettings.endDate = null;
                   triggerProjectionRecalculation(); // Recalcula ao mudar período padrão
              }
         });

         // Atualizar datas customizadas
         startDateInput?.addEventListener('change', () => {
             state.projectionSettings.startDate = startDateInput.value;
              triggerProjectionRecalculation();
         });
          endDateInput?.addEventListener('change', () => {
             state.projectionSettings.endDate = endDateInput.value;
              triggerProjectionRecalculation();
         });

         // Atualizar opções de inclusão
         includeCheckboxes?.forEach(checkbox => {
             checkbox.addEventListener('change', () => {
                 state.projectionSettings[checkbox.id] = checkbox.checked; // Assumindo que ID = chave no state
                  triggerProjectionRecalculation();
             });
         });

    }

     /**
      * Dispara o recálculo e re-renderização da projeção (com debounce).
      */
     const triggerProjectionRecalculation = Utils.debounce(() => {
        console.log("Projeção Caixa: Disparando recálculo...");
        UIComponents.showLoading(); // Mostra loading
        // Não precisa buscar dados novamente, apenas recalcular e re-renderizar
         calculateProjection();
         renderSummary();
         renderProjectionChart();
         renderDetailsTable();
         UIComponents.hideLoading(); // Esconde loading
     }, 300); // Atraso de 300ms para evitar recálculos múltiplos rápidos


    // --- Funções Públicas do Módulo ---
    return {
        async init() {
            console.log("CashProjectionModule: Inicializando...");
             // Define as configurações iniciais com base nos elementos do formulário (se já renderizados)
             const periodSelect = Utils.$('projection-period-filter');
             if(periodSelect) state.projectionSettings.periodMonths = parseInt(periodSelect.value, 10);
             state.projectionSettings.includeRecurring = Utils.$('include-recurring')?.checked ?? true;
             state.projectionSettings.includeInstallments = Utils.$('include-installments')?.checked ?? true;
             state.projectionSettings.includeGoals = Utils.$('include-goals')?.checked ?? false;

            // Busca todos os dados necessários uma vez
             await fetchData();
        },

        async render(filters) { // Filtros globais não são usados diretamente aqui, mas podem ser no futuro
            console.log("CashProjectionModule: Renderizando...");
            state.currentFilters = filters; // Guarda filtros globais se precisar

            // 1. Renderiza HTML base
            UIComponents.renderContent(App.templates['cashProjection']); // Usa template HTML

            // 2. Seleciona elementos DOM
            elements = {
                filtersForm: Utils.$('projection-filters-form'),
                periodFilter: Utils.$('projection-period-filter'),
                customDateRangeContainer: Utils.$('custom-date-range-container'),
                projectionStartDate: Utils.$('projection-start-date'),
                projectionEndDate: Utils.$('projection-end-date'),
                projectionSummaryGrid: Utils.$('projection-summary-grid'),
                projectionChartContainer: Utils.$('projection-chart-container'),
                projectionChart: Utils.$('projection-chart'),
                projectionDetailsTableContainer: Utils.$('projection-details-table-container'),
            };

            // 3. Configura os controles (listeners)
             setupProjectionControls();

            // 4. Calcula e renderiza a projeção inicial
            // Usar setTimeout para garantir que a UI esteja pronta antes do cálculo pesado
             setTimeout(() => {
                  triggerProjectionRecalculation();
             }, 50);


            console.log("CashProjectionModule: Renderização inicial concluída.");
        },

        destroy() {
            console.log("CashProjectionModule: Destruindo...");
             if (state.chartInstance) {
                state.chartInstance.destroy();
                state.chartInstance = null;
             }
            // Remover listeners específicos se necessário
            elements = {};
        }
    };

})(); // Fim da IIFE

// ===== FIM: BLOCO 35 ==============================

// ===== INÍCIO: BLOCO 36 ==============================
// ==== JAVASCRIPT - MÓDULO METAS FINANCEIRAS (modules/financialGoals.js) ====
// Depende de: utils.js, firebaseService.js, uiComponents.js, app.js

const FinancialGoalsModule = (() => { // IIFE

    // --- Referências a Elementos do Módulo ---
    let elements = {};

    // --- Estado Interno do Módulo ---
    let state = {
        goals: [], // Todas as metas com dados calculados
        persons: [], // Cópia dos dados globais de pessoas
        contributions: {}, // Cache de contribuições por goalId { goalId: [contrib...] }
        isLoading: false,
    };

    // --- Funções Privadas ---

    /**
     * Busca os dados de metas e suas respectivas contribuições.
     */
    async function fetchData() {
        if (state.isLoading) return;
        state.isLoading = true;
        console.log("Metas: Buscando dados...");
        // UIComponents.showLoading(); // Pode usar loading específico da seção

        try {
            const [goalsData, personsData] = await Promise.all([
                FirebaseService.goals.getAll(), // Busca todas as metas
                FirebaseService.persons.getAll() // Garante que temos as pessoas mais recentes
            ]);

            state.persons = personsData || [];
            const personMap = new Map(state.persons.map(p => [p.id, p.name]));

            // Busca contribuições para cada meta em paralelo e calcula progresso
            const goalsWithDetails = await Promise.all(goalsData.map(async (goal) => {
                const contributions = await FirebaseService.contributions.getByGoalId(goal.id);
                state.contributions[goal.id] = contributions; // Cache contribuições

                const target = parseFloat(goal.target) || 0;
                const contributed = contributions.reduce((sum, c) => sum + (parseFloat(c.amount) || 0), 0);
                const remaining = Math.max(0, target - contributed);
                const progress = target > 0 ? Math.min(100, (contributed / target) * 100) : (contributed > 0 ? 100 : 0); // 100% se alvo é 0 e contribuiu algo

                // Calcular aporte mensal necessário (simplificado)
                let requiredMonthly = 0;
                if (progress < 100 && remaining > 0 && goal.deadline) {
                    const deadlineDate = goal.deadline instanceof firebase.firestore.Timestamp ? goal.deadline.toDate() : new Date(goal.deadline);
                     const today = new Date();
                     // Calcula meses restantes (considerando o mês atual parcialmente)
                     let monthsRemaining = (deadlineDate.getFullYear() - today.getFullYear()) * 12;
                     monthsRemaining -= today.getMonth();
                     monthsRemaining += deadlineDate.getMonth();
                     // Se o prazo é neste mês ou já passou, meses restantes é <= 0
                     if (monthsRemaining <= 0) {
                         requiredMonthly = remaining; // Precisa do valor total agora
                     } else {
                         requiredMonthly = remaining / monthsRemaining;
                     }
                }


                return {
                    ...goal,
                    personName: personMap.get(goal.personId) || 'Todos', // Nome da pessoa
                    contributions: contributions, // Array de contribuições
                    contributedAmount: contributed,
                    remainingAmount: remaining,
                    progressPercentage: progress,
                    requiredMonthlyContribution: requiredMonthly > 0 ? requiredMonthly : 0, // Não mostra negativo
                    isCompleted: progress >= 100,
                };
            }));

             // Ordena: Ativas primeiro (por prazo), depois Concluídas (por prazo)
             goalsWithDetails.sort((a, b) => {
                 if (a.isCompleted !== b.isCompleted) {
                    return a.isCompleted ? 1 : -1; // Concluídas no final
                 }
                 // Se ambos têm prazo, ordena por prazo mais próximo
                 const deadlineA = a.deadline instanceof firebase.firestore.Timestamp ? a.deadline.toMillis() : new Date(a.deadline || 0).getTime();
                 const deadlineB = b.deadline instanceof firebase.firestore.Timestamp ? b.deadline.toMillis() : new Date(b.deadline || 0).getTime();
                 if(deadlineA && deadlineB) return deadlineA - deadlineB;
                 // Fallback se um não tiver prazo
                 return deadlineA ? -1 : (deadlineB ? 1 : 0);
             });


            state.goals = goalsWithDetails;
            console.log("Metas: Dados carregados e processados:", state.goals);

        } catch (error) {
            console.error("Metas: Erro ao buscar dados:", error);
            UIComponents.renderError("Erro ao carregar dados das Metas Financeiras.");
            state.goals = [];
        } finally {
            state.isLoading = false;
            // UIComponents.hideLoading();
        }
    }

    /**
     * Renderiza os cards de metas nas grids apropriadas (ativas/concluídas).
     */
    function renderGoalCards() {
        if (!elements.activeGoalsGrid || !elements.completedGoalsGrid) return;

        elements.activeGoalsGrid.innerHTML = ''; // Limpa grids
        elements.completedGoalsGrid.innerHTML = '';
        Utils.hide(elements.noActiveGoalsMessage); // Esconde mensagens de vazio
        Utils.hide(elements.noCompletedGoalsMessage);

        let hasActive = false;
        let hasCompleted = false;

        if (state.goals.length === 0) {
            Utils.show(elements.noActiveGoalsMessage); // Mostra apenas msg de ativo se tudo vazio
        } else {
            state.goals.forEach(goal => {
                const goalCardElement = createGoalCardElement(goal); // Cria o HTML do card

                if (goal.isCompleted) {
                    elements.completedGoalsGrid.appendChild(goalCardElement);
                    hasCompleted = true;
                } else {
                    elements.activeGoalsGrid.appendChild(goalCardElement);
                    hasActive = true;
                }
            });

            // Mostra/esconde mensagens de vazio conforme necessário
            Utils.setVisible(elements.noActiveGoalsMessage, !hasActive);
            Utils.setVisible(elements.noCompletedGoalsMessage, !hasCompleted);
            // Esconde a seção de concluídas se não houver nenhuma
             Utils.setVisible(elements.completedGoalsSection, hasCompleted);
        }
        console.log("Metas: Cards renderizados.");
    }

    /**
     * Cria o elemento HTML para um card de meta.
     * @param {object} goal Objeto da meta com dados processados.
     * @returns {HTMLElement} O elemento div do card.
     */
    function createGoalCardElement(goal) {
        const card = document.createElement('div');
        card.className = `goal-card ${goal.isCompleted ? 'completed' : 'active'}`;
        card.dataset.goalId = goal.id;

        const color = goal.color || 'var(--color-primary)'; // Usa cor da meta ou padrão

        card.innerHTML = `
            <div class="goal-card-header" style="border-left-color: ${color};">
                <div class="goal-icon" style="background-color: ${color};">
                    <i class="fas ${goal.icon || 'fa-bullseye'}" aria-hidden="true"></i>
                </div>
                <div class="goal-info">
                    <h5 class="goal-name" title="${goal.name}">${goal.name}</h5>
                    <span class="goal-details">
                        ${goal.personName ? `Para: ${goal.personName} | ` : ''}
                        Prazo: ${goal.deadline ? Utils.formatDate(goal.deadline) : 'Sem prazo'}
                    </span>
                </div>
                <div class="goal-actions">
                    ${!goal.isCompleted ? `<button class="btn btn-icon-only btn-link btn-sm btn-add-contribution" title="Adicionar Aporte"><i class="fas fa-plus-circle"></i></button>` : ''}
                    <button class="btn btn-icon-only btn-link btn-sm btn-edit-goal" title="Editar Meta"><i class="fas fa-edit"></i></button>
                    <button class="btn btn-icon-only btn-link btn-sm btn-delete-goal" title="Excluir Meta"><i class="fas fa-trash-alt"></i></button>
                </div>
            </div>
            <div class="goal-card-body">
                <div class="goal-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${goal.progressPercentage.toFixed(1)}%; background-color: ${goal.isCompleted ? 'var(--color-success)' : color};"></div>
                    </div>
                    <div class="progress-text">
                        <span>${goal.progressPercentage.toFixed(1)}%</span>
                        <span>${Utils.formatCurrency(goal.contributedAmount)} / ${Utils.formatCurrency(goal.target)}</span>
                    </div>
                </div>
                ${!goal.isCompleted && goal.remainingAmount > 0 ? `
                <div class="goal-summary">
                    <span>Restante: <strong class="negative-value">${Utils.formatCurrency(goal.remainingAmount)}</strong></span>
                    ${goal.requiredMonthlyContribution > 0 ? `<span>Aporte Ideal: <strong>${Utils.formatCurrency(goal.requiredMonthlyContribution)}/mês</strong></span>` : ''}
                </div>
                ` : ''}
                 ${goal.purpose ? `<p class="goal-purpose-text">${goal.purpose}</p>` : ''}
            </div>
            ${goal.contributions && goal.contributions.length > 0 ? `
            <div class="goal-card-footer">
                 <span class="footer-text">Último aporte: ${Utils.formatCurrency(goal.contributions[0].amount)} (${Utils.formatDate(goal.contributions[0].date)})</span>
                 <button class="btn btn-link btn-sm btn-view-contributions">Ver Aportes (${goal.contributions.length})</button>
            </div>
            ` : ''}
        `;

        // Adicionar listeners aos botões DEPOIS de criar o HTML
        card.querySelector('.btn-add-contribution')?.addEventListener('click', (e) => {
             e.stopPropagation();
             App.prepareContributionModal(goal.id, goal.name);
             UIComponents.openModal('contribution-modal');
        });
        card.querySelector('.btn-edit-goal')?.addEventListener('click', (e) => {
             e.stopPropagation();
             App.prepareGoalModal(goal); // Passa o objeto completo da meta
             UIComponents.openModal('goal-modal');
        });
        card.querySelector('.btn-delete-goal')?.addEventListener('click', (e) => {
             e.stopPropagation();
             App.showConfirmationDialog({
                 title: 'Confirmar Exclusão de Meta',
                 message: `Tem certeza que deseja excluir a meta "${goal.name}"? Todos os aportes também serão removidos.`,
                 confirmButtonText: 'Excluir Meta',
                 onConfirm: async () => {
                     console.log("Metas: Confirmada exclusão da meta:", goal.id);
                     UIComponents.showLoading();
                     const success = await FirebaseService.goals.remove(goal.id); // Remove a meta e suas contribuições
                     UIComponents.hideLoading();
                     if (success) {
                         UIComponents.showToast('Meta excluída com sucesso!', { type: 'success' });
                         await fetchData(); // Busca dados novamente
                         renderGoalCards(); // Re-renderiza os cards
                     } else {
                         UIComponents.showToast('Erro ao excluir a meta.', { type: 'danger' });
                     }
                 }
             });
        });
         card.querySelector('.btn-view-contributions')?.addEventListener('click', (e) => {
              e.stopPropagation();
              // TODO: Implementar visualização de aportes (talvez um modal?)
              UIComponents.showToast(`Visualizar ${goal.contributions.length} aportes (Em breve!)`, { type: 'info' });
         });


        return card;
    }

    // --- Funções Públicas do Módulo ---
    return {
        async init() {
            console.log("FinancialGoalsModule: Inicializando...");
            // Pode pré-carregar algo se necessário
        },

        async render(filters) { // Filtros globais não são usados aqui diretamente
            console.log("FinancialGoalsModule: Renderizando...");
            // 1. Renderiza HTML base
            UIComponents.renderContent(App.templates['financialGoals']);

            // 2. Seleciona elementos DOM
            elements = {
                activeGoalsGrid: Utils.$('active-goals-grid'),
                completedGoalsGrid: Utils.$('completed-goals-grid'),
                noActiveGoalsMessage: Utils.$('no-active-goals-message'),
                noCompletedGoalsMessage: Utils.$('no-completed-goals-message'),
                 completedGoalsSection: Utils.qs('.completed-goals-section'), // Seleciona a seção inteira
                addNewGoalBtn: Utils.$('add-new-goal-btn'),
            };

            // 3. Configura botão principal do módulo
             elements.addNewGoalBtn?.addEventListener('click', () => {
                 App.prepareGoalModal(); // Prepara para nova meta
                 UIComponents.openModal('goal-modal');
             });

            // 4. Busca dados (metas e contribuições)
            await fetchData();

            // 5. Renderiza os cards de metas
            renderGoalCards();

            console.log("FinancialGoalsModule: Renderização concluída.");
        },

        destroy() {
            console.log("FinancialGoalsModule: Destruindo...");
            // Remover listeners se houver algum adicionado diretamente a elementos do módulo
            elements = {};
            state.contributions = {}; // Limpa cache de contribuições
        }
    };

})(); // Fim da IIFE

// ===== FIM: BLOCO 36 ==============================

// ===== INÍCIO: BLOCO 37 ==============================
// ==== JAVASCRIPT - MÓDULO AJUSTES (modules/settings.js) ====
// Depende de: utils.js, firebaseService.js, uiComponents.js, app.js

const SettingsModule = (() => { // IIFE

    // --- Referências a Elementos do Módulo ---
    let elements = {};

    // --- Estado Interno do Módulo ---
    let state = {
        activeTab: 'categories', // Aba inicial
        categories: [],
        persons: [],
        cards: [],
        recurring: [], // Dados de recorrências (a serem definidos)
        isLoading: { // Controla loading por aba
            categories: false,
            persons: false,
            cards: false,
            recurring: false,
        },
    };

    // --- Funções Privadas ---

    /**
     * Busca os dados para uma aba específica.
     * @param {string} tabId ID da aba (e.g., 'categories', 'persons').
     */
    async function fetchDataForTab(tabId) {
        if (state.isLoading[tabId]) return; // Evita buscas duplicadas
        state.isLoading[tabId] = true;
        console.log(`Ajustes: Buscando dados para aba '${tabId}'...`);
        // UIComponents.showLoading(); // Pode ter loading por painel

        try {
            switch (tabId) {
                case 'categories':
                    state.categories = await FirebaseService.categories.getAll();
                    break;
                case 'persons':
                    state.persons = await FirebaseService.persons.getAll();
                    break;
                case 'cards':
                    state.cards = await FirebaseService.cards.getAll();
                    break;
                case 'recurring':
                    // TODO: Implementar busca de recorrências no FirebaseService
                    // state.recurring = await FirebaseService.recurring.getAll();
                    state.recurring = []; // Placeholder
                    console.warn("Busca de Recorrências ainda não implementada.");
                    break;
                default:
                    console.warn(`Aba desconhecida para busca de dados: ${tabId}`);
            }
            console.log(`Ajustes: Dados carregados para aba '${tabId}'.`);
        } catch (error) {
            console.error(`Ajustes: Erro ao buscar dados para aba '${tabId}':`, error);
            // Mostra erro no painel específico?
        } finally {
            state.isLoading[tabId] = false;
            // UIComponents.hideLoading();
        }
    }

    /**
     * Renderiza o conteúdo da aba ativa.
     */
    function renderActiveTabContent() {
        const tabId = state.activeTab;
        console.log(`Ajustes: Renderizando conteúdo da aba '${tabId}'.`);

        // Esconde placeholder de carregamento do painel ativo (se existir)
        const loadingPlaceholder = elements[`${tabId}LoadingPlaceholder`];
        if (loadingPlaceholder) loadingPlaceholder.style.display = 'none';


        switch (tabId) {
            case 'categories':
                renderCategoriesTable();
                break;
            case 'persons':
                renderPersonsGrid(); // Ou renderPersonsTable()
                break;
            case 'cards':
                renderCardsTable();
                break;
            case 'recurring':
                renderRecurringTable();
                break;
            default:
                console.warn(`Nenhuma função de renderização para a aba: ${tabId}`);
        }
    }

    /**
     * Renderiza a tabela de categorias.
     */
    function renderCategoriesTable() {
        const container = elements.categoriesTableContainer;
        if (!container) return;
        container.innerHTML = ''; // Limpa

        // TODO: Criar UIComponents.createSettingsTable ou adaptar createTransactionsTable
        // Por enquanto, exemplo simples:
        const table = document.createElement('table');
        table.className = 'table settings-table';
        table.innerHTML = `
            <thead>
                <tr>
                    <th>Cor</th>
                    <th>Ícone</th>
                    <th>Nome</th>
                    <th class="action-cell">Ações</th>
                </tr>
            </thead>
            <tbody>
                ${state.categories.length === 0 ? `
                    <tr class="table-empty-row"><td colspan="4">Nenhuma categoria cadastrada.</td></tr>
                ` : state.categories.map(cat => `
                    <tr data-id="${cat.id}">
                        <td><span class="color-indicator" style="background-color: ${cat.color || '#ccc'};"></span></td>
                        <td><i class="fas ${cat.icon || 'fa-question-circle'}" style="color: ${cat.color || 'inherit'}; font-size: 1.1em;"></i></td>
                        <td>${Utils.escapeHTML(cat.name)}</td>
                        <td class="action-cell">
                            <div class="action-buttons">
                                <button class="btn btn-icon-only btn-link btn-sm btn-edit-category" title="Editar Categoria" data-id="${cat.id}"><i class="fas fa-edit"></i></button>
                                <button class="btn btn-icon-only btn-link btn-sm btn-delete-category" title="Excluir Categoria" data-id="${cat.id}"><i class="fas fa-trash-alt"></i></button>
                            </div>
                        </td>
                    </tr>
                `).join('')}
            </tbody>
        `;
         // Adicionar listeners delegados para os botões da tabela
         table.querySelector('tbody')?.addEventListener('click', handleTableActions);
        container.appendChild(table);
    }

    /**
     * Renderiza a grid de pessoas.
     */
    function renderPersonsGrid() {
        const container = elements.personsGridContainer;
        if (!container) return;
        container.innerHTML = ''; // Limpa

         if (state.persons.length === 0) {
             container.innerHTML = `<div class="empty-section-message compact"><p>Nenhuma pessoa cadastrada.</p></div>`;
             return;
         }

        state.persons.forEach(person => {
            const card = document.createElement('div');
            card.className = 'person-card';
            card.dataset.id = person.id;
            card.innerHTML = `
                <div class="avatar avatar-md ${person.avatar || 'avatar-bg-1'}" aria-hidden="true"></div>
                <div class="person-info">
                    <div class="person-name">${Utils.escapeHTML(person.name)}</div>
                    <!-- <div class="person-details">Detalhes...</div> -->
                </div>
                <div class="person-actions">
                    <button class="btn btn-icon-only btn-link btn-sm btn-edit-person" title="Editar Pessoa" data-id="${person.id}"><i class="fas fa-edit"></i></button>
                    <button class="btn btn-icon-only btn-link btn-sm btn-delete-person" title="Excluir Pessoa" data-id="${person.id}"><i class="fas fa-trash-alt"></i></button>
                </div>
            `;
             // Adicionar listeners (pode ser delegado no container)
             card.querySelector('.btn-edit-person')?.addEventListener('click', handleGridActions);
             card.querySelector('.btn-delete-person')?.addEventListener('click', handleGridActions);

            container.appendChild(card);
        });
    }

    /**
     * Renderiza a tabela de cartões.
     */
    function renderCardsTable() {
        const container = elements.cardsTableContainer;
        if (!container) return;
        container.innerHTML = ''; // Limpa

        const table = document.createElement('table');
        table.className = 'table settings-table';
        table.innerHTML = `
            <thead>
                <tr>
                    <th>Cor</th>
                    <th>Nome</th>
                    <th class="currency">Limite</th>
                    <th>Fechamento</th>
                    <th>Vencimento</th>
                    <th class="action-cell">Ações</th>
                </tr>
            </thead>
            <tbody>
                ${state.cards.length === 0 ? `
                    <tr class="table-empty-row"><td colspan="6">Nenhum cartão cadastrado.</td></tr>
                ` : state.cards.map(card => `
                    <tr data-id="${card.id}">
                        <td><span class="color-indicator" style="background-color: ${card.color || '#ccc'};"></span></td>
                        <td>${Utils.escapeHTML(card.name)}</td>
                        <td class="currency">${card.limit ? Utils.formatCurrency(card.limit) : '-'}</td>
                        <td>${card.closingDay ? `Dia ${card.closingDay}` : '-'}</td>
                        <td>${card.dueDay ? `Dia ${card.dueDay}` : '-'}</td>
                         <td class="action-cell">
                            <div class="action-buttons">
                                <button class="btn btn-icon-only btn-link btn-sm btn-edit-card" title="Editar Cartão" data-id="${card.id}"><i class="fas fa-edit"></i></button>
                                <button class="btn btn-icon-only btn-link btn-sm btn-delete-card" title="Excluir Cartão" data-id="${card.id}"><i class="fas fa-trash-alt"></i></button>
                            </div>
                        </td>
                    </tr>
                `).join('')}
            </tbody>
        `;
         table.querySelector('tbody')?.addEventListener('click', handleTableActions);
        container.appendChild(table);
    }

    /**
     * Renderiza a tabela de recorrências (Exemplo).
     */
    function renderRecurringTable() {
         const container = elements.recurringTableContainer;
        if (!container) return;
        container.innerHTML = ''; // Limpa
         container.innerHTML = `<div class="table-empty-row"><td colspan="1">Gerenciamento de Recorrências (Em breve!).</td></div>`; // Placeholder
        // TODO: Implementar lógica e tabela real
    }


    /**
     * Configura a navegação entre as abas.
     */
    function setupTabs() {
        const tabsList = elements.tabsList;
        if (!tabsList) return;

        tabsList.addEventListener('click', async (event) => {
            const clickedTab = event.target.closest('.tab');
            if (!clickedTab || clickedTab.classList.contains('active')) {
                return; // Ignora clique fora de uma aba ou na aba já ativa
            }

            const newTabId = clickedTab.id.replace('tab-', ''); // e.g., 'categories'
            console.log(`Ajustes: Trocando para aba '${newTabId}'`);

            // 1. Atualiza estado visual das abas
            tabsList.querySelectorAll('.tab').forEach(tab => {
                const isClicked = tab === clickedTab;
                Utils.toggleClass(tab, 'active', isClicked);
                tab.setAttribute('aria-selected', isClicked);
            });

            // 2. Esconde todos os painéis e mostra o painel correspondente
             elements.tabsContent.querySelectorAll('.tab-panel').forEach(panel => {
                const panelId = panel.id.replace('tabpanel-', '');
                const isTarget = panelId === newTabId;
                 panel.hidden = !isTarget;
                 Utils.toggleClass(panel, 'active', isTarget); // Adiciona classe active para animação
             });

            // 3. Atualiza estado interno
            state.activeTab = newTabId;

            // 4. Busca dados E renderiza se ainda não foram carregados para esta aba
            //    (Evita buscar dados toda vez que troca de aba)
            if (!state[newTabId] || state[newTabId].length === 0 && !state.isLoading[newTabId]) {
                 // Mostra loading específico do painel
                 const loadingPlaceholder = elements[`${newTabId}LoadingPlaceholder`];
                 if (loadingPlaceholder) loadingPlaceholder.style.display = 'block';

                 await fetchDataForTab(newTabId);
                 renderActiveTabContent(); // Renderiza após buscar
            } else if(state[newTabId]) {
                 renderActiveTabContent(); // Apenas renderiza se os dados já existem
            }
        });
    }

    /**
     * Manipulador delegado para ações em tabelas (Editar/Excluir).
     * @param {Event} event
     */
     function handleTableActions(event) {
         const editBtn = event.target.closest('[class*="btn-edit-"]'); // Pega qualquer botão de edição
         const deleteBtn = event.target.closest('[class*="btn-delete-"]'); // Pega qualquer botão de exclusão
         const id = editBtn?.dataset.id || deleteBtn?.dataset.id;
         if (!id) return;

         const type = editBtn ? editBtn.className.match(/btn-edit-(\w+)/)?.[1] : deleteBtn.className.match(/btn-delete-(\w+)/)?.[1];
         if (!type) return; // Não identificou o tipo (category, card, etc.)

         if (editBtn) {
             console.log(`Ajustes: Editar ${type} ID: ${id}`);
              // Dispara evento genérico ou chama função específica
              document.dispatchEvent(new CustomEvent(`edit${capitalize(type)}Request`, { detail: { id: id } }));
         } else if (deleteBtn) {
              console.log(`Ajustes: Excluir ${type} ID: ${id}`);
              const name = deleteBtn.closest('tr')?.querySelector('td:nth-of-type(3)')?.textContent || `item ${id}`; // Tenta pegar nome
               document.dispatchEvent(new CustomEvent(`delete${capitalize(type)}Request`, { detail: { id: id, name: name } }));
         }
     }
     /**
      * Manipulador delegado para ações em grids (Pessoas).
      * @param {Event} event
      */
      function handleGridActions(event) {
          const button = event.target.closest('button');
          if (!button) return;
          const id = button.dataset.id;
          if(!id) return;

          const isEdit = button.classList.contains('btn-edit-person');
          const isDelete = button.classList.contains('btn-delete-person');
          const type = 'person';

           if (isEdit) {
             console.log(`Ajustes: Editar ${type} ID: ${id}`);
              document.dispatchEvent(new CustomEvent(`edit${capitalize(type)}Request`, { detail: { id: id } }));
         } else if (isDelete) {
              console.log(`Ajustes: Excluir ${type} ID: ${id}`);
              const name = button.closest('.person-card')?.querySelector('.person-name')?.textContent || `pessoa ${id}`;
               document.dispatchEvent(new CustomEvent(`delete${capitalize(type)}Request`, { detail: { id: id, name: name } }));
         }
      }
       // Função auxiliar simples para capitalizar strings (e.g., 'person' -> 'Person')
      function capitalize(str) { return str.charAt(0).toUpperCase() + str.slice(1); }


     /**
     * Configura os botões "Novo..." de cada painel.
     */
     function setupAddButtons() {
         elements.addNewCategoryBtn?.addEventListener('click', () => {
             App.prepareCategoryModal();
             UIComponents.openModal('category-modal');
         });
          elements.addNewPersonBtn?.addEventListener('click', () => {
             App.preparePersonModal();
             UIComponents.openModal('person-modal');
         });
          elements.addNewCardBtn?.addEventListener('click', () => {
             App.prepareCardModal();
             UIComponents.openModal('card-modal');
         });
         // Adicionar para recorrências se houver botão
     }


    // --- Funções Públicas do Módulo ---
    return {
        async init() {
            console.log("SettingsModule: Inicializando...");
            // Reseta estado de loading ao inicializar
             Object.keys(state.isLoading).forEach(key => state.isLoading[key] = false);
        },

        async render(filters) { // Filtros globais geralmente não são usados aqui
            console.log("SettingsModule: Renderizando...");
            // 1. Renderiza HTML base
            UIComponents.renderContent(App.templates['settings']);

            // 2. Seleciona elementos DOM
            elements = {
                tabsList: Utils.qs('.settings-tabs .tabs-list'),
                tabsContent: Utils.qs('.settings-tabs .tabs-content'),
                // Containers de conteúdo
                categoriesTableContainer: Utils.$('categories-table-container'),
                personsGridContainer: Utils.$('persons-grid-container'),
                cardsTableContainer: Utils.$('cards-table-container'),
                recurringTableContainer: Utils.$('recurring-table-container'),
                // Placeholders de loading
                 categoriesLoadingPlaceholder: Utils.qs('#tabpanel-categories .table-loading-placeholder'),
                 personsLoadingPlaceholder: Utils.qs('#tabpanel-persons .table-loading-placeholder'),
                 cardsLoadingPlaceholder: Utils.qs('#tabpanel-cards .table-loading-placeholder'),
                 recurringLoadingPlaceholder: Utils.qs('#tabpanel-recurring .table-loading-placeholder'),
                // Botões "Novo..."
                 addNewCategoryBtn: Utils.$('add-new-category-btn'),
                 addNewPersonBtn: Utils.$('add-new-person-btn'),
                 addNewCardBtn: Utils.$('add-new-card-btn'),
                 // Adicionar outros elementos se necessário
            };

            // 3. Configura navegação das abas
            setupTabs();

            // 4. Busca dados e renderiza a aba inicial (ativa)
             state.activeTab = elements.tabsList?.querySelector('.tab.active')?.id.replace('tab-', '') || 'categories';
             await fetchDataForTab(state.activeTab);
             renderActiveTabContent();

             // 5. Configura botões "Novo..."
             setupAddButtons();

            console.log("SettingsModule: Renderização concluída.");
        },

        destroy() {
            console.log("SettingsModule: Destruindo...");
            // Remover listeners específicos se houver
            elements = {};
        }
    };

})(); // Fim da IIFE


// Adicionar CSS se necessário para .empty-section-message.compact ou .color-indicator
// .empty-section-message.compact { padding: var(--spacing-4); font-size: var(--font-size-sm); }
// .color-indicator { width: 18px; height: 18px; border-radius: 50%; display: inline-block; vertical-align: middle; border: 1px solid var(--color-border); }


// ===== FIM: BLOCO 37 ==============================

// ===== INÍCIO: BLOCO 38 ==============================
// ==== JAVASCRIPT - APP PRINCIPAL (app.js) - HTML Templates ====
// Adicionar este objeto DENTRO do objeto App

const App = {
    // ... (state, modules, etc.) ...

    // --- HTML Templates para os Módulos ---
    // Armazena o HTML base de cada módulo como string.
    // UIComponents.renderContent() insere estas strings na #content-area.
    templates: {

        /**
         * Template HTML para o Módulo Dashboard
         * (Baseado no Bloco 8)
         */
        'dashboard': `
            <div class="dashboard-module">
                <section class="dashboard-section alerts-section" id="dashboard-alerts" aria-label="Alertas importantes"></section>
                <section class="dashboard-section kpi-section" aria-labelledby="kpi-section-title">
                    <h3 class="section-title" id="kpi-section-title">Resumo Financeiro Atual</h3>
                    <div class="kpi-grid" id="kpi-grid-main">
                        <div class="kpi-card placeholder"></div>
                        <div class="kpi-card placeholder"></div>
                        <div class="kpi-card placeholder"></div>
                        <div class="kpi-card placeholder"></div>
                    </div>
                </section>
                <section class="dashboard-section charts-section" aria-labelledby="charts-section-title">
                    <h3 class="section-title" id="charts-section-title">Análise Visual</h3>
                    <div class="charts-grid" id="charts-grid-main">
                        <div class="chart-container" id="category-expense-chart-container">
                            <h4 class="chart-title">Despesas por Categoria (Mês Atual)</h4>
                            <canvas id="category-expense-chart" class="chart-canvas" role="img" aria-label="Gráfico de pizza mostrando distribuição de despesas por categoria"></canvas>
                            <div class="chart-empty-message" style="display: none;">Sem dados de despesas para exibir.</div>
                        </div>
                        <div class="chart-container" id="income-expense-chart-container">
                            <h4 class="chart-title">Receitas vs. Despesas (Últimos 6 Meses)</h4>
                            <canvas id="income-expense-chart" class="chart-canvas" role="img" aria-label="Gráfico de barras comparando receitas e despesas mensais"></canvas>
                            <div class="chart-empty-message" style="display: none;">Sem dados suficientes para exibir o gráfico.</div>
                        </div>
                    </div>
                </section>
                <section class="dashboard-section transactions-section" aria-labelledby="transactions-section-title">
                    <h3 class="section-title" id="transactions-section-title">Transações Recentes</h3>
                    <div class="table-container" id="recent-transactions-table-container">
                        <div class="table-loading-placeholder active"><p>Carregando transações...</p></div>
                    </div>
                    <div class="section-footer">
                        <button class="btn btn-secondary btn-sm" id="view-all-transactions-btn">Ver Todas as Transações</button>
                    </div>
                </section>
            </div>
        `,

        /**
         * Template HTML para o Módulo Análise Mensal
         * (Baseado no Bloco 10)
         */
        'monthlyAnalysis': `
            <div class="monthly-analysis-module">
                <section class="filters-section card" aria-labelledby="filters-section-title">
                    <div class="card-header">
                        <h3 class="section-title no-border" id="filters-section-title">Filtros Avançados</h3>
                        <button class="btn btn-sm btn-link" id="reset-filters-btn">Limpar Filtros</button>
                    </div>
                    <div class="card-body">
                        <form class="filters-form" id="monthly-analysis-filters-form">
                            <div class="form-row">
                                <div class="form-group filter-group">
                                    <label for="ma-category-filter" class="form-label">Categoria</label>
                                    <select id="ma-category-filter" class="form-select filter-select">
                                        <option value="all">Todas as Categorias</option>
                                    </select>
                                </div>
                                <div class="form-group filter-group">
                                    <label for="ma-payment-filter" class="form-label">Forma de Pagamento</label>
                                    <select id="ma-payment-filter" class="form-select filter-select">
                                        <option value="all">Todas as Formas</option>
                                        <option value="cash">Dinheiro</option>
                                        <option value="debit">Débito</option>
                                        <option value="credit">Cartão de Crédito</option>
                                        <option value="pix">PIX</option>
                                        <option value="transfer">Transferência</option>
                                        <option value="other">Outro</option>
                                    </select>
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group filter-group">
                                    <label for="ma-type-filter" class="form-label">Tipo</label>
                                    <select id="ma-type-filter" class="form-select filter-select">
                                        <option value="all">Todos os Tipos</option>
                                        <option value="income">Receita</option>
                                        <option value="expense">Despesa</option>
                                    </select>
                                </div>
                                <div class="form-group filter-group">
                                    <label for="ma-sort-filter" class="form-label">Ordenar Por</label>
                                    <select id="ma-sort-filter" class="form-select filter-select">
                                        <option value="date-desc">Data (Mais Recente)</option>
                                        <option value="date-asc">Data (Mais Antiga)</option>
                                        <option value="amount-desc">Valor (Maior)</option>
                                        <option value="amount-asc">Valor (Menor)</option>
                                        <option value="description-asc">Descrição (A-Z)</option>
                                    </select>
                                </div>
                            </div>
                            <div class="form-actions no-border">
                                <button type="button" class="btn btn-primary" id="apply-ma-filters-btn">Aplicar Filtros</button>
                            </div>
                        </form>
                    </div>
                </section>
                <section class="summary-section" aria-labelledby="summary-section-title">
                    <h3 class="section-title" id="summary-section-title">Resumo do Mês Selecionado</h3>
                    <div class="summary-grid" id="monthly-summary-grid">
                        <div class="summary-card placeholder"></div>
                        <div class="summary-card placeholder"></div>
                        <div class="summary-card placeholder"></div>
                    </div>
                </section>
                <section class="transactions-section" aria-labelledby="ma-transactions-section-title">
                    <h3 class="section-title" id="ma-transactions-section-title">Detalhes das Transações</h3>
                    <div class="table-container" id="monthly-transactions-table-container">
                        <div class="table-loading-placeholder active"><p>Carregando transações do mês...</p></div>
                    </div>
                </section>
            </div>
        `,

        /**
         * Template HTML para o Módulo Projeção de Caixa
         * (Baseado no Bloco 12)
         */
        'cashProjection': `
            <div class="cash-projection-module">
                <section class="projection-controls card" aria-labelledby="projection-controls-title">
                    <div class="card-header">
                        <h3 class="section-title no-border" id="projection-controls-title">Configurar Projeção</h3>
                    </div>
                    <div class="card-body">
                        <form class="filters-form" id="projection-filters-form">
                            <div class="form-row">
                                <div class="form-group filter-group">
                                    <label for="projection-period-filter" class="form-label">Período da Projeção</label>
                                    <select id="projection-period-filter" class="form-select filter-select">
                                        <option value="3">Próximos 3 Meses</option>
                                        <option value="6" selected>Próximos 6 Meses</option>
                                        <option value="12">Próximos 12 Meses</option>
                                        <option value="custom">Período Personalizado</option>
                                    </select>
                                </div>
                                <div class="form-group filter-group date-range-filter" id="custom-date-range-container" style="display: none;">
                                    <div class="date-inputs">
                                        <div class="date-input-group">
                                            <label for="projection-start-date" class="form-label">Data Inicial</label>
                                            <input type="date" id="projection-start-date" class="form-input">
                                        </div>
                                        <div class="date-input-group">
                                            <label for="projection-end-date" class="form-label">Data Final</label>
                                            <input type="date" id="projection-end-date" class="form-input">
                                        </div>
                                    </div>
                                </div>
                            </div>
                             <div class="form-row">
                                <div class="form-group filter-group">
                                    <label class="form-label">Incluir na Projeção</label>
                                    <div class="checkbox-group">
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" value="recurring" id="include-recurring" checked>
                                            <label class="form-check-label" for="include-recurring">Recorrentes</label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" value="installments" id="include-installments" checked>
                                            <label class="form-check-label" for="include-installments">Parcelamentos</label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" value="goals" id="include-goals">
                                            <label class="form-check-label" for="include-goals">Aportes (Metas)</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </form>
                    </div>
                </section>
                <section class="summary-section" aria-labelledby="projection-summary-title">
                    <h3 class="section-title" id="projection-summary-title">Resumo Projetado</h3>
                    <div class="summary-grid" id="projection-summary-grid">
                        <div class="summary-card placeholder"></div>
                        <div class="summary-card placeholder"></div>
                        <div class="summary-card placeholder"></div>
                        <div class="summary-card placeholder"></div>
                    </div>
                </section>
                <section class="chart-section" aria-labelledby="projection-chart-title">
                    <h3 class="section-title" id="projection-chart-title">Evolução do Saldo Projetado</h3>
                    <div class="chart-container" id="projection-chart-container">
                        <canvas id="projection-chart" class="chart-canvas" role="img" aria-label="Gráfico de linha mostrando a evolução estimada do saldo ao longo do tempo"></canvas>
                        <div class="chart-empty-message" style="display: none;">Não há dados suficientes para gerar a projeção.</div>
                    </div>
                </section>
                <section class="details-table-section" aria-labelledby="projection-details-title">
                    <h3 class="section-title" id="projection-details-title">Detalhamento por Período</h3>
                    <div class="table-container" id="projection-details-table-container">
                        <div class="table-loading-placeholder active"><p>Calculando projeção detalhada...</p></div>
                    </div>
                </section>
            </div>
        `,

        /**
         * Template HTML para o Módulo Metas Financeiras
         * (Baseado no Bloco 14)
         */
        'financialGoals': `
            <div class="financial-goals-module">
                <section class="module-header-section">
                    <div class="header-content">
                        <h3 class="section-title no-border">Minhas Metas Financeiras</h3>
                        <p class="section-subtitle">Acompanhe o progresso dos seus objetivos.</p>
                    </div>
                    <div class="header-actions">
                        <button class="btn btn-primary btn-with-icon" id="add-new-goal-btn">
                            <i class="fas fa-plus" aria-hidden="true"></i>
                            <span class="btn-text">Nova Meta</span>
                        </button>
                    </div>
                </section>
                <section class="goals-section active-goals-section" aria-labelledby="active-goals-title">
                    <h4 class="subsection-title" id="active-goals-title">Metas em Andamento</h4>
                    <div class="goals-grid" id="active-goals-grid">
                         <div class="goal-card placeholder"></div>
                         <div class="goal-card placeholder"></div>
                    </div>
                    <div class="empty-section-message" id="no-active-goals-message" style="display: none;">
                        <i class="fas fa-flag-checkered empty-icon"></i>
                        <p>Você ainda não possui metas em andamento.</p>
                        <button class="btn btn-secondary btn-sm" onclick="document.getElementById('add-new-goal-btn').click()">Crie sua primeira meta!</button>
                    </div>
                </section>
                <section class="goals-section completed-goals-section" aria-labelledby="completed-goals-title" style="display: none;"> <!-- Começa escondida -->
                    <h4 class="subsection-title" id="completed-goals-title">Metas Concluídas</h4>
                    <div class="goals-grid" id="completed-goals-grid"></div>
                    <div class="empty-section-message" id="no-completed-goals-message" style="display: none;">
                        <i class="fas fa-history empty-icon"></i>
                        <p>Nenhuma meta concluída ainda.</p>
                    </div>
                </section>
            </div>
        `,

        /**
         * Template HTML para o Módulo Ajustes
         * (Baseado no Bloco 16)
         */
        'settings': `
            <div class="settings-module">
                <section class="module-header-section">
                    <div class="header-content">
                        <h3 class="section-title no-border">Ajustes Gerais</h3>
                        <p class="section-subtitle">Gerencie categorias, pessoas, cartões e outras configurações.</p>
                    </div>
                </section>
                <div class="tabs-container settings-tabs">
                    <nav class="tabs-nav" aria-label="Seções de Ajustes">
                        <ul class="tabs-list" role="tablist">
                            <li class="tab active" id="tab-categories" role="tab" aria-selected="true" aria-controls="tabpanel-categories">
                                <i class="fas fa-tags tab-icon" aria-hidden="true"></i><span class="tab-text">Categorias</span>
                            </li>
                            <li class="tab" id="tab-persons" role="tab" aria-selected="false" aria-controls="tabpanel-persons">
                                <i class="fas fa-users tab-icon" aria-hidden="true"></i><span class="tab-text">Pessoas</span>
                            </li>
                            <li class="tab" id="tab-cards" role="tab" aria-selected="false" aria-controls="tabpanel-cards">
                                <i class="fas fa-credit-card tab-icon" aria-hidden="true"></i><span class="tab-text">Cartões</span>
                            </li>
                             <li class="tab" id="tab-recurring" role="tab" aria-selected="false" aria-controls="tabpanel-recurring">
                                <i class="fas fa-sync-alt tab-icon" aria-hidden="true"></i><span class="tab-text">Recorrências</span>
                             </li>
                        </ul>
                    </nav>
                    <div class="tabs-content">
                        <div class="tab-panel active" id="tabpanel-categories" role="tabpanel" aria-labelledby="tab-categories">
                            <div class="tab-panel-header">
                                <h4 class="subsection-title">Gerenciar Categorias</h4>
                                <button class="btn btn-primary btn-sm btn-with-icon" id="add-new-category-btn">
                                    <i class="fas fa-plus" aria-hidden="true"></i><span class="btn-text">Nova Categoria</span>
                                </button>
                            </div>
                            <div class="table-container" id="categories-table-container">
                                 <div class="table-loading-placeholder active"><p>Carregando categorias...</p></div>
                            </div>
                        </div>
                        <div class="tab-panel" id="tabpanel-persons" role="tabpanel" aria-labelledby="tab-persons" hidden>
                            <div class="tab-panel-header">
                                <h4 class="subsection-title">Gerenciar Pessoas</h4>
                                <button class="btn btn-primary btn-sm btn-with-icon" id="add-new-person-btn">
                                    <i class="fas fa-plus" aria-hidden="true"></i><span class="btn-text">Nova Pessoa</span>
                                </button>
                            </div>
                            <div class="settings-grid" id="persons-grid-container">
                                <div class="table-loading-placeholder active"><p>Carregando pessoas...</p></div>
                            </div>
                        </div>
                        <div class="tab-panel" id="tabpanel-cards" role="tabpanel" aria-labelledby="tab-cards" hidden>
                             <div class="tab-panel-header">
                                <h4 class="subsection-title">Gerenciar Cartões de Crédito</h4>
                                <button class="btn btn-primary btn-sm btn-with-icon" id="add-new-card-btn">
                                    <i class="fas fa-plus" aria-hidden="true"></i><span class="btn-text">Novo Cartão</span>
                                </button>
                            </div>
                            <div class="table-container" id="cards-table-container">
                                <div class="table-loading-placeholder active"><p>Carregando cartões...</p></div>
                            </div>
                        </div>
                         <div class="tab-panel" id="tabpanel-recurring" role="tabpanel" aria-labelledby="tab-recurring" hidden>
                             <div class="tab-panel-header">
                                <h4 class="subsection-title">Gerenciar Transações Recorrentes</h4>
                            </div>
                            <div class="table-container" id="recurring-table-container">
                                <div class="table-loading-placeholder active"><p>Carregando recorrências...</p></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `,
    },

    // ... (restante do código do App: init, loadGlobalData, etc.) ...

}; // Fim do objeto App

// ===== FIM: BLOCO 38 ==============================

// ===== INÍCIO: BLOCO 39 ==============================
// ==== JAVASCRIPT - SERVIÇO FIREBASE (firebaseService.js) - Parte 2 ====
// Completando as operações CRUD para as outras coleções.

const FirebaseService = {

    getCollection(collectionName) {
        // ... (código do Bloco 22) ...
        const collectionRef = collections[collectionName];
        if (!collectionRef) {
            console.error(`FirebaseService: Coleção '${collectionName}' não encontrada ou DB não inicializado.`);
            return null;
        }
        return collectionRef;
    },

    // --- Transações ---
    transactions: {
        // ... (código do Bloco 22: add, update, remove, getById, getAll, getByDateRange, getByMonth) ...
        // TODO: Implementar createInstallments, createRecurrentTransactions
    },

    // ============================================
    // === OPERAÇÕES CRUD - CATEGORIES ==========
    // ============================================
    categories: {
        /** Adiciona uma nova categoria. */
        async add(categoryData) {
            const collectionRef = FirebaseService.getCollection('categories');
            if (!collectionRef) return null;
            try {
                const dataToSave = {
                    name: categoryData.name || 'Nova Categoria',
                    icon: categoryData.icon || 'fa-tag',
                    color: categoryData.color || '#cccccc',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                };
                const docRef = await collectionRef.add(dataToSave);
                return docRef.id;
            } catch (error) {
                console.error("Erro ao adicionar categoria:", error, categoryData);
                return null;
            }
        },
        /** Atualiza uma categoria existente. */
        async update(id, categoryUpdateData) {
            const collectionRef = FirebaseService.getCollection('categories');
            if (!collectionRef || !id) return false;
            try {
                const dataToUpdate = { ...categoryUpdateData }; // Copia para não modificar original
                 // Remove campos não editáveis
                delete dataToUpdate.id;
                delete dataToUpdate.createdAt;
                dataToUpdate.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                await collectionRef.doc(id).update(dataToUpdate);
                return true;
            } catch (error) {
                console.error("Erro ao atualizar categoria:", error, id, categoryUpdateData);
                return false;
            }
        },
        /** Remove uma categoria (CUIDADO: verificar dependências). */
        async remove(id) {
            const collectionRef = FirebaseService.getCollection('categories');
            if (!collectionRef || !id) return false;
            try {
                 // TODO: Verificar se a categoria está em uso em transações ANTES de excluir.
                 // Se estiver em uso, talvez impedir ou pedir para reatribuir transações.
                 // Exemplo de verificação (simplificado):
                 /*
                 const transCollection = FirebaseService.getCollection('transactions');
                 const snapshot = await transCollection.where('categoryId', '==', id).limit(1).get();
                 if (!snapshot.empty) {
                     console.warn(`Categoria ${id} está em uso e não pode ser excluída.`);
                     throw new Error("Categoria está em uso por transações."); // Lança erro para o App tratar
                 }
                 */
                await collectionRef.doc(id).delete();
                return true;
            } catch (error) {
                console.error("Erro ao remover categoria:", error, id);
                 // Re-lança o erro para o App poder mostrar mensagem específica
                 throw error; // Permite ao App.js capturar e informar o usuário
            }
        },
        /** Obtém uma categoria pelo ID. */
        async getById(id) {
            const collectionRef = FirebaseService.getCollection('categories');
            if (!collectionRef || !id) return null;
            try {
                const docSnap = await collectionRef.doc(id).get();
                return docSnap.exists ? { id: docSnap.id, ...docSnap.data() } : null;
            } catch (error) {
                console.error("Erro ao obter categoria por ID:", error, id);
                return null;
            }
        },
        /** Obtém todas as categorias ordenadas por nome. */
        async getAll() {
            const collectionRef = FirebaseService.getCollection('categories');
            if (!collectionRef) return [];
            try {
                const querySnapshot = await collectionRef.orderBy("name", "asc").get();
                return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (error) {
                console.error("Erro ao obter todas as categorias:", error);
                return [];
            }
        }
    },

    // ============================================
    // === OPERAÇÕES CRUD - PERSONS =============
    // ============================================
    persons: {
         /** Adiciona uma nova pessoa. */
        async add(personData) {
            const collectionRef = FirebaseService.getCollection('persons');
            if (!collectionRef) return null;
            try {
                 const dataToSave = {
                    name: personData.name || 'Nova Pessoa',
                    avatar: personData.avatar || 'avatar-bg-1', // Classe CSS da cor/imagem
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                };
                const docRef = await collectionRef.add(dataToSave);
                return docRef.id;
            } catch (error) {
                console.error("Erro ao adicionar pessoa:", error, personData);
                return null;
            }
        },
         /** Atualiza uma pessoa existente. */
        async update(id, personUpdateData) {
            const collectionRef = FirebaseService.getCollection('persons');
            if (!collectionRef || !id) return false;
            try {
                 const dataToUpdate = { ...personUpdateData };
                 delete dataToUpdate.id;
                 delete dataToUpdate.createdAt;
                 dataToUpdate.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                await collectionRef.doc(id).update(dataToUpdate);
                return true;
            } catch (error) {
                console.error("Erro ao atualizar pessoa:", error, id, personUpdateData);
                return false;
            }
        },
        /** Remove uma pessoa (CUIDADO: verificar dependências). */
        async remove(id) {
            const collectionRef = FirebaseService.getCollection('persons');
            if (!collectionRef || !id) return false;
            try {
                 // TODO: Verificar se a pessoa está em uso (transações, metas)
                 /*
                 const transSnapshot = await FirebaseService.getCollection('transactions').where('personId', '==', id).limit(1).get();
                 const goalSnapshot = await FirebaseService.getCollection('goals').where('personId', '==', id).limit(1).get();
                 if (!transSnapshot.empty || !goalSnapshot.empty) {
                     throw new Error("Pessoa está em uso e não pode ser excluída.");
                 }
                 */
                await collectionRef.doc(id).delete();
                return true;
            } catch (error) {
                console.error("Erro ao remover pessoa:", error, id);
                 throw error;
            }
        },
        /** Obtém uma pessoa pelo ID. */
        async getById(id) {
            const collectionRef = FirebaseService.getCollection('persons');
             if (!collectionRef || !id) return null;
            try {
                const docSnap = await collectionRef.doc(id).get();
                return docSnap.exists ? { id: docSnap.id, ...docSnap.data() } : null;
            } catch (error) {
                console.error("Erro ao obter pessoa por ID:", error, id);
                return null;
            }
        },
        /** Obtém todas as pessoas ordenadas por nome. */
        async getAll() {
            const collectionRef = FirebaseService.getCollection('persons');
             if (!collectionRef) return [];
            try {
                const querySnapshot = await collectionRef.orderBy("name", "asc").get();
                return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (error) {
                console.error("Erro ao obter todas as pessoas:", error);
                return [];
            }
        }
    },

    // ============================================
    // === OPERAÇÕES CRUD - CARDS ===============
    // ============================================
     cards: {
         /** Adiciona um novo cartão. */
        async add(cardData) {
            const collectionRef = FirebaseService.getCollection('cards');
            if (!collectionRef) return null;
            try {
                 const dataToSave = {
                    name: cardData.name || 'Novo Cartão',
                    limit: cardData.limit || null, // Armazena como null se vazio
                    closingDay: cardData.closingDay || null,
                    dueDay: cardData.dueDay || null,
                    color: cardData.color || '#cccccc',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                 };
                const docRef = await collectionRef.add(dataToSave);
                return docRef.id;
            } catch (error) {
                console.error("Erro ao adicionar cartão:", error, cardData);
                return null;
            }
        },
        /** Atualiza um cartão existente. */
        async update(id, cardUpdateData) {
            const collectionRef = FirebaseService.getCollection('cards');
             if (!collectionRef || !id) return false;
            try {
                 const dataToUpdate = { ...cardUpdateData };
                 delete dataToUpdate.id;
                 delete dataToUpdate.createdAt;
                 // Garante que campos numéricos sejam null se vazios
                 if (dataToUpdate.hasOwnProperty('limit')) dataToUpdate.limit = dataToUpdate.limit || null;
                 if (dataToUpdate.hasOwnProperty('closingDay')) dataToUpdate.closingDay = dataToUpdate.closingDay || null;
                 if (dataToUpdate.hasOwnProperty('dueDay')) dataToUpdate.dueDay = dataToUpdate.dueDay || null;

                 dataToUpdate.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                await collectionRef.doc(id).update(dataToUpdate);
                return true;
            } catch (error) {
                console.error("Erro ao atualizar cartão:", error, id, cardUpdateData);
                return false;
            }
        },
        /** Remove um cartão (CUIDADO: verificar dependências). */
        async remove(id) {
            const collectionRef = FirebaseService.getCollection('cards');
             if (!collectionRef || !id) return false;
            try {
                // TODO: Verificar se cartão está em uso em transações
                 /*
                 const transSnapshot = await FirebaseService.getCollection('transactions').where('cardId', '==', id).limit(1).get();
                 if (!transSnapshot.empty) {
                     throw new Error("Cartão está em uso por transações.");
                 }
                 */
                await collectionRef.doc(id).delete();
                return true;
            } catch (error) {
                console.error("Erro ao remover cartão:", error, id);
                 throw error;
            }
        },
         /** Obtém um cartão pelo ID. */
        async getById(id) {
            const collectionRef = FirebaseService.getCollection('cards');
             if (!collectionRef || !id) return null;
            try {
                const docSnap = await collectionRef.doc(id).get();
                return docSnap.exists ? { id: docSnap.id, ...docSnap.data() } : null;
            } catch (error) {
                console.error("Erro ao obter cartão por ID:", error, id);
                return null;
            }
        },
        /** Obtém todos os cartões ordenados por nome. */
        async getAll() {
            const collectionRef = FirebaseService.getCollection('cards');
             if (!collectionRef) return [];
            try {
                const querySnapshot = await collectionRef.orderBy("name", "asc").get();
                return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (error) {
                console.error("Erro ao obter todos os cartões:", error);
                return [];
            }
        }
    },

    // ============================================
    // === OPERAÇÕES CRUD - GOALS ===============
    // ============================================
     goals: {
        /** Adiciona uma nova meta. */
        async add(goalData) {
            const collectionRef = FirebaseService.getCollection('goals');
            if (!collectionRef) return null;
            try {
                const dataToSave = {
                    name: goalData.name || 'Nova Meta',
                    target: goalData.target || 0,
                    deadline: goalData.deadline ? firebase.firestore.Timestamp.fromDate(new Date(goalData.deadline + 'T00:00:00Z')) : null, // Converte aaaa-mm-dd para Timestamp
                    personId: goalData.personId || null, // ID da pessoa ou null
                    icon: goalData.icon || 'fa-bullseye',
                    color: goalData.color || '#cccccc',
                    purpose: goalData.purpose || '',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                 };
                const docRef = await collectionRef.add(dataToSave);
                return docRef.id;
            } catch (error) {
                console.error("Erro ao adicionar meta:", error, goalData);
                return null;
            }
        },
         /** Atualiza uma meta existente. */
        async update(id, goalUpdateData) {
            const collectionRef = FirebaseService.getCollection('goals');
             if (!collectionRef || !id) return false;
            try {
                 const dataToUpdate = { ...goalUpdateData };
                 delete dataToUpdate.id;
                 delete dataToUpdate.createdAt;
                 // Converte deadline se presente
                 if (dataToUpdate.deadline && typeof dataToUpdate.deadline === 'string') {
                     dataToUpdate.deadline = firebase.firestore.Timestamp.fromDate(new Date(dataToUpdate.deadline + 'T00:00:00Z'));
                 } else if (dataToUpdate.hasOwnProperty('deadline') && !dataToUpdate.deadline) {
                      dataToUpdate.deadline = null; // Permite remover prazo
                 }
                  // Converte target se presente
                  if (dataToUpdate.hasOwnProperty('target')) {
                      dataToUpdate.target = parseFloat(dataToUpdate.target) || 0;
                  }
                 // Garante personId como null se vazio
                 if (dataToUpdate.hasOwnProperty('personId') && !dataToUpdate.personId) {
                      dataToUpdate.personId = null;
                 }

                 dataToUpdate.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                await collectionRef.doc(id).update(dataToUpdate);
                return true;
            } catch (error) {
                console.error("Erro ao atualizar meta:", error, id, goalUpdateData);
                return false;
            }
        },
        /** Remove uma meta E SUAS CONTRIBUIÇÕES. */
        async remove(id) {
            const goalsCollectionRef = FirebaseService.getCollection('goals');
            const contribCollectionRef = FirebaseService.getCollection('contributions');
             if (!goalsCollectionRef || !contribCollectionRef || !id) return false;

            const batch = db.batch(); // Usar batch para operações atômicas

            try {
                // 1. Encontrar todas as contribuições da meta
                const contribSnapshot = await contribCollectionRef.where('goalId', '==', id).get();
                contribSnapshot.docs.forEach(doc => {
                    batch.delete(doc.ref); // Adiciona exclusão da contribuição ao batch
                });
                console.log(`Agendadas exclusões de ${contribSnapshot.size} contribuições para meta ${id}.`);

                 // 2. Adicionar exclusão da meta ao batch
                const goalRef = goalsCollectionRef.doc(id);
                batch.delete(goalRef);

                 // 3. Executar o batch
                await batch.commit();
                console.log(`Meta ${id} e suas contribuições removidas com sucesso.`);
                return true;
            } catch (error) {
                console.error("Erro ao remover meta e contribuições:", error, id);
                 throw error; // Re-lança para o App tratar
            }
        },
        /** Obtém uma meta pelo ID. */
        async getById(id) {
             const collectionRef = FirebaseService.getCollection('goals');
             if (!collectionRef || !id) return null;
            try {
                const docSnap = await collectionRef.doc(id).get();
                return docSnap.exists ? { id: docSnap.id, ...docSnap.data() } : null;
            } catch (error) {
                console.error("Erro ao obter meta por ID:", error, id);
                return null;
            }
        },
        /** Obtém todas as metas ordenadas por prazo. */
        async getAll() {
             const collectionRef = FirebaseService.getCollection('goals');
             if (!collectionRef) return [];
            try {
                 // Ordena por prazo, metas sem prazo podem ir para o final (ou início)
                const querySnapshot = await collectionRef.orderBy("deadline", "asc").get();
                return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (error) {
                console.error("Erro ao obter todas as metas:", error);
                return [];
            }
        }
    },

    // ============================================
    // === OPERAÇÕES CRUD - CONTRIBUTIONS =======
    // ============================================
    contributions: {
        /** Adiciona um novo aporte a uma meta. */
        async add(contributionData) {
            const collectionRef = FirebaseService.getCollection('contributions');
             if (!collectionRef || !contributionData.goalId) return null;
            try {
                 const dataToSave = {
                    goalId: contributionData.goalId,
                    amount: parseFloat(contributionData.amount) || 0,
                    date: contributionData.date ? firebase.firestore.Timestamp.fromDate(new Date(contributionData.date + 'T00:00:00Z')) : firebase.firestore.Timestamp.now(),
                    notes: contributionData.notes || '',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                 };
                const docRef = await collectionRef.add(dataToSave);
                return docRef.id;
            } catch (error) {
                console.error("Erro ao adicionar aporte:", error, contributionData);
                return null;
            }
        },
        // TODO: Implementar update e remove para contribuições, se necessário.
        // A remoção geralmente está atrelada à remoção da meta (como feito no goals.remove).
        /** Obtém todos os aportes de uma meta específica, ordenados por data. */
        async getByGoalId(goalId) {
            const collectionRef = FirebaseService.getCollection('contributions');
             if (!collectionRef || !goalId) return [];
             try {
                 const querySnapshot = await collectionRef
                    .where('goalId', '==', goalId)
                    .orderBy('date', 'desc') // Mais recentes primeiro
                    .get();
                 return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
             } catch (error) {
                 console.error("Erro ao obter aportes por meta:", error, "Goal ID:", goalId);
                 return [];
             }
        }
    }

}; // Fim do objeto FirebaseService

// ===== FIM: BLOCO 39 ==============================

// ===== INÍCIO: BLOCO 40 ==============================
// ==== JAVASCRIPT - APP PRINCIPAL (app.js) - Parte 4 - Handlers Finais ====
// Continuação do objeto App e do listener DOMContentLoaded

const App = {
    // ... (código dos Blocos 26, 30, 31, 32) ...

    // --- Tratamento de Ações Delegadas (Implementações Finais) ---

    /** Handler para editar Categoria */
    async handleEditCategoryRequest(event) {
        const { id } = event.detail;
        if (!id) return;
        console.log("App: Recebido pedido para editar categoria:", id);
        UIComponents.showLoading();
        const data = await FirebaseService.categories.getById(id);
        UIComponents.hideLoading();
        if (data) {
            await this.prepareCategoryModal(data);
            UIComponents.openModal('category-modal');
        } else {
            UIComponents.showToast(`Categoria ${id} não encontrada.`, { type: 'warning' });
        }
    },

    /** Handler para excluir Categoria */
    handleDeleteCategoryRequest(event) {
        const { id, name } = event.detail;
        if (!id) return;
        console.log("App: Recebido pedido para excluir categoria:", id, name);
        this.showConfirmationDialog({
            title: 'Confirmar Exclusão',
            message: `Tem certeza que deseja excluir a categoria "<strong>${Utils.escapeHTML(name)}</strong>"? <br><small>Verifique se ela não está sendo usada em nenhuma transação.</small>`,
            confirmButtonText: 'Excluir Categoria',
            onConfirm: async () => {
                console.log("App: Confirmada exclusão da categoria:", id);
                UIComponents.showLoading();
                let success = false;
                let errorMessage = 'Erro ao excluir a categoria.';
                try {
                    success = await FirebaseService.categories.remove(id);
                } catch (error) {
                    // Captura erro lançado pelo FirebaseService se categoria estiver em uso
                    errorMessage = error.message || errorMessage;
                    console.error("Erro capturado ao excluir categoria:", error);
                }
                UIComponents.hideLoading();
                if (success) {
                    UIComponents.showToast('Categoria excluída!', { type: 'success' });
                    await this.loadGlobalData(); // Recarrega dados globais
                    await this.reloadCurrentModuleIf('settings'); // Recarrega módulo de ajustes
                    // TODO: Recarregar outros módulos que usem categorias se necessário
                } else {
                    UIComponents.showToast(errorMessage, { type: 'danger' });
                }
            }
        });
    },

     /** Handler para editar Pessoa */
     async handleEditPersonRequest(event) {
        const { id } = event.detail;
        if (!id) return;
        console.log("App: Recebido pedido para editar pessoa:", id);
        UIComponents.showLoading();
        const data = await FirebaseService.persons.getById(id);
        UIComponents.hideLoading();
        if (data) {
            await this.preparePersonModal(data);
            UIComponents.openModal('person-modal');
        } else {
            UIComponents.showToast(`Pessoa ${id} não encontrada.`, { type: 'warning' });
        }
    },

    /** Handler para excluir Pessoa */
    handleDeletePersonRequest(event) {
        const { id, name } = event.detail;
        if (!id) return;
        console.log("App: Recebido pedido para excluir pessoa:", id, name);
        this.showConfirmationDialog({
            title: 'Confirmar Exclusão',
            message: `Tem certeza que deseja excluir a pessoa "<strong>${Utils.escapeHTML(name)}</strong>"? <br><small>Verifique se ela não está associada a transações ou metas.</small>`,
            confirmButtonText: 'Excluir Pessoa',
             onConfirm: async () => {
                 console.log("App: Confirmada exclusão da pessoa:", id);
                 UIComponents.showLoading();
                 let success = false;
                 let errorMessage = 'Erro ao excluir a pessoa.';
                 try {
                     success = await FirebaseService.persons.remove(id);
                 } catch (error) {
                     errorMessage = error.message || errorMessage;
                     console.error("Erro capturado ao excluir pessoa:", error);
                 }
                 UIComponents.hideLoading();
                 if (success) {
                     UIComponents.showToast('Pessoa excluída!', { type: 'success' });
                     await this.loadGlobalData();
                     await this.reloadCurrentModuleIf('settings');
                      // Recarregar outros módulos que usam pessoas (Dashboard, Análise)
                      await this.reloadCurrentModuleIf('dashboard');
                      await this.reloadCurrentModuleIf('monthly-analysis');
                 } else {
                     UIComponents.showToast(errorMessage, { type: 'danger' });
                 }
             }
        });
    },

     /** Handler para editar Cartão */
     async handleEditCardRequest(event) {
        const { id } = event.detail;
        if (!id) return;
        console.log("App: Recebido pedido para editar cartão:", id);
        UIComponents.showLoading();
        const data = await FirebaseService.cards.getById(id);
        UIComponents.hideLoading();
        if (data) {
            await this.prepareCardModal(data);
            UIComponents.openModal('card-modal');
        } else {
            UIComponents.showToast(`Cartão ${id} não encontrado.`, { type: 'warning' });
        }
    },

    /** Handler para excluir Cartão */
    handleDeleteCardRequest(event) {
        const { id, name } = event.detail;
        if (!id) return;
        console.log("App: Recebido pedido para excluir cartão:", id, name);
        this.showConfirmationDialog({
            title: 'Confirmar Exclusão',
            message: `Tem certeza que deseja excluir o cartão "<strong>${Utils.escapeHTML(name)}</strong>"? <br><small>Verifique se ele não está associado a transações.</small>`,
            confirmButtonText: 'Excluir Cartão',
             onConfirm: async () => {
                 console.log("App: Confirmada exclusão do cartão:", id);
                 UIComponents.showLoading();
                 let success = false;
                 let errorMessage = 'Erro ao excluir o cartão.';
                 try {
                     success = await FirebaseService.cards.remove(id);
                 } catch (error) {
                     errorMessage = error.message || errorMessage;
                      console.error("Erro capturado ao excluir cartão:", error);
                 }
                 UIComponents.hideLoading();
                 if (success) {
                     UIComponents.showToast('Cartão excluído!', { type: 'success' });
                     await this.loadGlobalData();
                     await this.reloadCurrentModuleIf('settings');
                     // Recarregar transações se necessário (para remover cartão associado)
                 } else {
                     UIComponents.showToast(errorMessage, { type: 'danger' });
                 }
             }
        });
    },

     /** Handler para editar Meta */
     async handleEditGoalRequest(event) {
        const { id } = event.detail;
        if (!id) return;
        console.log("App: Recebido pedido para editar meta:", id);
        UIComponents.showLoading();
        // Precisa buscar a meta E as pessoas para o select no modal
        const [data, persons] = await Promise.all([
             FirebaseService.goals.getById(id),
             FirebaseService.persons.getAll() // Garante lista atualizada de pessoas
        ]);
        this.state.globalData.persons = persons || []; // Atualiza global

        UIComponents.hideLoading();
        if (data) {
            await this.prepareGoalModal(data); // Prepara com dados e pessoas
            UIComponents.openModal('goal-modal');
        } else {
            UIComponents.showToast(`Meta ${id} não encontrada.`, { type: 'warning' });
        }
    },

     /** Handler para excluir Meta */
     handleDeleteGoalRequest(event) {
        const { id, name } = event.detail;
        if (!id) return;
        console.log("App: Recebido pedido para excluir meta:", id, name);
        this.showConfirmationDialog({
            title: 'Confirmar Exclusão',
            message: `Tem certeza que deseja excluir a meta "<strong>${Utils.escapeHTML(name)}</strong>"? <br><small>Todos os aportes associados também serão removidos.</small>`,
            confirmButtonText: 'Excluir Meta',
             onConfirm: async () => {
                 console.log("App: Confirmada exclusão da meta:", id);
                 UIComponents.showLoading();
                 let success = false;
                 let errorMessage = 'Erro ao excluir a meta.';
                 try {
                     // O remove do FirebaseService já exclui os aportes em batch
                     success = await FirebaseService.goals.remove(id);
                 } catch (error) {
                     errorMessage = error.message || errorMessage;
                      console.error("Erro capturado ao excluir meta:", error);
                 }
                 UIComponents.hideLoading();
                 if (success) {
                     UIComponents.showToast('Meta e aportes excluídos!', { type: 'success' });
                     await this.reloadCurrentModuleIf('financial-goals'); // Recarrega módulo de metas
                 } else {
                     UIComponents.showToast(errorMessage, { type: 'danger' });
                 }
             }
        });
    },

     // Adicionar handlers para Aportes (Editar/Excluir) se necessário

}; // Fim do objeto App


// --- Ponto de Entrada da Aplicação ---
document.addEventListener('DOMContentLoaded', () => {
    // ... (Registro de Módulos - Bloco 30) ...
     App.modules.dashboard = DashboardModule;
     App.modules.monthlyAnalysis = MonthlyAnalysisModule; // Descomentar se criado
     App.modules.cashProjection = CashProjectionModule; // Descomentar se criado
     App.modules.financialGoals = FinancialGoalsModule; // Descomentar se criado
     App.modules.settings = SettingsModule; // Descomentar se criado

    // ... (Chamada App.init() - Bloco 30) ...
     App.init().catch(error => { /* ... */ });

    // --- ADICIONAR LISTENERS GLOBAIS (Continuação) ---
    // ... (Listeners de Formulários - Bloco 32) ...
     const categoryForm = Utils.$('category-form'); if(categoryForm) categoryForm.addEventListener('submit', (e) => App.handleCategoryFormSubmit(e));
     const personForm = Utils.$('person-form'); if(personForm) personForm.addEventListener('submit', (e) => App.handlePersonFormSubmit(e));
     const cardForm = Utils.$('card-form'); if(cardForm) cardForm.addEventListener('submit', (e) => App.handleCardFormSubmit(e));
     const goalForm = Utils.$('goal-form'); if(goalForm) goalForm.addEventListener('submit', (e) => App.handleGoalFormSubmit(e));
     const contributionForm = Utils.$('contribution-form'); if(contributionForm) contributionForm.addEventListener('submit', (e) => App.handleContributionFormSubmit(e));


    // ... (Listeners de Ações Delegadas - Bloco 32) ...
     document.addEventListener('editTransactionRequest', (e) => App.handleEditTransactionRequest(e));
     document.addEventListener('deleteTransactionRequest', (e) => App.handleDeleteTransactionRequest(e));

     // Adiciona listeners para as novas ações
     document.addEventListener('editCategoryRequest', (e) => App.handleEditCategoryRequest(e));
     document.addEventListener('deleteCategoryRequest', (e) => App.handleDeleteCategoryRequest(e));
     document.addEventListener('editPersonRequest', (e) => App.handleEditPersonRequest(e));
     document.addEventListener('deletePersonRequest', (e) => App.handleDeletePersonRequest(e));
     document.addEventListener('editCardRequest', (e) => App.handleEditCardRequest(e));
     document.addEventListener('deleteCardRequest', (e) => App.handleDeleteCardRequest(e));
      document.addEventListener('editGoalRequest', (e) => App.handleEditGoalRequest(e));
      document.addEventListener('deleteGoalRequest', (e) => App.handleDeleteGoalRequest(e));
      // Adicionar listeners para Aportes se necessário

});

// ===== FIM: BLOCO 40 ==============================
