<!DOCTYPE html>
<html lang="pt-BR" data-theme="light">
<head>
 
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Gestão Financeira da Família - Controle financeiro com estilo Apple">
  <title>Gestão Financeira da Família</title>
  
  <!-- Fonte Inter via Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Scripts CDN: Chart.js 4 -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  
  <!-- Scripts CDN: Firebase v9 compat -->
  <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-auth-compat.js"></script>
  
  <style>
    /* Design-tokens em :root */
    :root {
      /* Cores neutras */
      --color-background: #ffffff;
      --color-surface: #f5f5f7;
      --color-surface-variant: #e8e8ed;
      --color-on-surface: #1d1d1f;
      --color-on-surface-variant: #86868b;
      --color-outline: #d2d2d7;
      
      /* Cores semânticas */
      --color-primary: #007AFF;
      --color-on-primary: #ffffff;
      --color-success: #34c759;
      --color-on-success: #ffffff;
      --color-warning: #ff9500;
      --color-on-warning: #ffffff;
      --color-error: #ff3b30;
      --color-on-error: #ffffff;
      --color-info: #007aff;
      --color-on-info: #ffffff;
      
      /* Cores para receitas e despesas */
      --color-income: #34c759;
      --color-expense: #ff3b30;
      
      /* Cores de cartões */
      --color-card-blue: #007aff;
      --color-card-green: #34c759;
      --color-card-orange: #ff9500;
      --color-card-red: #ff3b30;
      --color-card-purple: #af52de;
      --color-card-invoice: #FFD700; /* Cor amarelo ouro para fatura */
      
      /* Tipografia */
      --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      --font-size-xs: 0.75rem;
      --font-size-sm: 0.875rem;
      --font-size-md: 1rem;
      --font-size-lg: 1.125rem;
      --font-size-xl: 1.25rem;
      --font-size-2xl: 1.5rem;
      --font-size-3xl: 1.875rem;
      --font-size-4xl: 2.25rem;
      --font-weight-light: 300;
      --font-weight-regular: 400;
      --font-weight-medium: 500;
      --font-weight-semibold: 600;
      --font-weight-bold: 700;
      
      /* Espaçamento */
      --spacing-2xs: 0.25rem;
      --spacing-xs: 0.5rem;
      --spacing-sm: 0.75rem;
      --spacing-md: 1rem;
      --spacing-lg: 1.5rem;
      --spacing-xl: 2rem;
      --spacing-2xl: 3rem;
      
      /* Bordas e raios */
      --radius-sm: 0.5rem;
      --radius-md: 0.75rem;
      --radius-lg: 1rem;
      --radius-xl: 1.5rem;
      --radius-full: 9999px;
      
      /* Sombras */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.05), 0 1px 3px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.05), 0 4px 6px rgba(0, 0, 0, 0.05);
      
      /* Animações */
      --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-normal: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-slow: 0.35s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Tema escuro */
    [data-theme="dark"] {
      --color-background: #000000;
      --color-surface: #1c1c1e;
      --color-surface-variant: #2c2c2e;
      --color-on-surface: #f5f5f7;
      --color-on-surface-variant: #8e8e93;
      --color-outline: #38383a;
      color: var(--color-on-surface);
    }
    
    /* Reset básico */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html, body {
      height: 100%;
      font-family: var(--font-family);
      background-color: var(--color-background);
      color: var(--color-on-surface);
      font-size: var(--font-size-md);
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      transition: background-color var(--transition-normal), color var(--transition-normal);
    }
    
    img, picture, video, canvas, svg {
      display: block;
      max-width: 100%;
    }
    
    input, button, textarea, select {
      font: inherit;
      color: inherit;
    }
    
    button {
      background: none;
      border: none;
      cursor: pointer;
    }
    
    a {
      color: inherit;
      text-decoration: none;
    }
    
    table {
      border-collapse: collapse;
      width: 100%;
    }

    /* Layout principal */
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: var(--spacing-md);
    }
  
    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-md) 0;
      margin-bottom: var(--spacing-xl);
      position: sticky;
      top: 0;
      background-color: var(--color-background);
      z-index: 100;
      transition: background-color var(--transition-normal);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--color-outline);
    }
    
    .header-filters {
      display: flex;
      gap: var(--spacing-md);
      align-items: center;
    }
    
    .header-actions {
      display: flex;
      gap: var(--spacing-md);
      align-items: center;
    }
    
    /* Título principal do app */
    .app-title {
      font-size: var(--font-size-2xl);
      font-weight: var(--font-weight-semibold);
      letter-spacing: -0.02em;
      margin-bottom: var(--spacing-md);
    }
    
    /* Hero Section similar ao mockup */
    .hero {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      margin-bottom: var(--spacing-2xl);
    }
    
    .hero-title {
      font-size: var(--font-size-3xl);
      font-weight: var(--font-weight-semibold);
      letter-spacing: -0.03em;
      margin-bottom: var(--spacing-md);
      line-height: 1.1;
    }
    
    .hero-subtitle {
      font-size: var(--font-size-lg);
      color: var(--color-on-surface-variant);
      margin-bottom: var(--spacing-xl);
      max-width: 600px;
    }
    
    /* Área de KPIs */
    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: var(--spacing-lg);
      margin-bottom: var(--spacing-xl);
    }
    
    /* Insights banner */
    .insights-banner {
      margin-bottom: var(--spacing-xl);
      border-radius: var(--radius-lg);
      overflow: hidden;
    }
    
    /* Gráficos */
    .charts-container {
      margin-bottom: var(--spacing-2xl);
    }
    
    .charts-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-semibold);
      margin-bottom: var(--spacing-lg);
    }
    
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--spacing-xl);
      margin-bottom: var(--spacing-xl);
    }
    
    .chart-container {
      position: relative;
      height: 380px; /* Aumentado para evitar textos cortados - Problema #11 */
      border-radius: var(--radius-lg);
      background-color: var(--color-surface);
      padding: var(--spacing-md);
      box-shadow: var(--shadow-sm);
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
      overflow: hidden;
    }
    
    .chart-container:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-md);
    }
    
    .chart-container h3 {
      font-weight: var(--font-weight-semibold);
      font-size: var(--font-size-lg);
      margin-bottom: var(--spacing-md);
    }
    
    /* Compromissos longos */
    .commitments {
      margin-bottom: var(--spacing-xl);
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      padding: var(--spacing-md);
      box-shadow: var(--shadow-sm);
      margin-top: var(--spacing-2xl); /* Espaço extra no topo para separar do gráfico */
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
    }
    
    .commitments:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-md);
    }
    
    .commitments-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--spacing-md);
      cursor: pointer;
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-md);
      transition: background-color var(--transition-normal);
    }
    
    .commitments-header:hover {
      background-color: var(--color-surface-variant);
    }
    
    .commitments-header h3 {
      font-weight: var(--font-weight-semibold);
      font-size: var(--font-size-lg);
    }
    
    .commitments-content {
      overflow: hidden;
      transition: max-height var(--transition-normal);
      max-height: 0;
    }
    
    .commitment-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      padding: var(--spacing-md);
      border-radius: var(--radius-md);
      margin-bottom: var(--spacing-sm);
      background-color: var(--color-surface-variant);
    }
    
    .commitment-progress {
      width: 100%;
      height: 8px;
      background-color: var(--color-surface);
      border-radius: var(--radius-full);
      overflow: hidden;
    }
    
    .commitment-progress-bar {
      height: 100%;
      border-radius: var(--radius-full);
      transition: width var(--transition-normal);
    }
    
    /* Tabela de transações */
    .transactions-container {
      margin-bottom: var(--spacing-2xl);
    }
    
    .card-transacoes {
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      padding: var(--spacing-lg);
      box-shadow: var(--shadow-sm);
      display: flex;
      flex-direction: column;
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-xl);
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
      overflow-x: auto; /* Evitar que ultrapasse os limites da tela - Problema #7 */
      max-width: 100%; /* Garantir que respeite os limites da tela - Problema #7 */
    }
    
    .card-transacoes:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-md);
    }
    
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-md);
    }
    
    .card-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-semibold);
      margin: 0;
    }
    
    .filters {
      display: flex;
      gap: var(--spacing-md);
      flex-wrap: wrap;
    }
    
    .transactions-table-container {
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      overflow: hidden;
      overflow-x: auto; /* Adicionar scroll horizontal se necessário - Problema #7 */
    }
    
    .transactions-table {
      width: 100%;
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-sm);
      table-layout: fixed; /* Melhorar o layout da tabela - Problema #14 */
    }
    
    .transactions-table th {
      text-align: left;
      padding: var(--spacing-md);
      font-weight: var(--font-weight-medium);
      color: var(--color-on-surface-variant);
      background-color: var(--color-surface);
      position: sticky;
      top: 0;
      z-index: 10;
      white-space: nowrap;
      cursor: pointer;
    }
    
    .transactions-table th.sortable:hover {
      background-color: var(--color-surface-variant);
    }
    
    .transactions-table td {
      padding: var(--spacing-md);
      border-top: 1px solid var(--color-outline);
      white-space: normal; /* Permitir quebra de linha - Problema #14 */
      word-break: break-word; /* Permitir quebra de palavras longas - Problema #14 */
    }
    
    .transactions-table tr:hover {
      background-color: var(--color-surface-variant);
    }
    
    .transaction-icon {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      width: 2.5rem;
      height: 2.5rem;
      border-radius: var(--radius-full);
      background-color: var(--color-surface-variant);
    }
    
    .actions-cell {
      display: flex;
      gap: var(--spacing-xs);
      justify-content: flex-end;
    }
    
    /* Componentes */
    /* Botões */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-xs) var(--spacing-md);
      border-radius: var(--radius-full);
      font-weight: var(--font-weight-medium);
      transition: all var(--transition-normal);
      white-space: nowrap;
      border: none;
      min-height: 36px;
    }
    
    .btn-primary {
      background-color: var(--color-primary);
      color: var(--color-on-primary);
    }
    
    .btn-primary:hover {
      opacity: 0.9;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .btn-primary:active {
      transform: translateY(0);
      box-shadow: none;
    }
    
    .btn-success {
      background-color: var(--color-success);
      color: var(--color-on-success);
    }
    
    .btn-success:hover {
      opacity: 0.9;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .btn-success:active {
      transform: translateY(0);
      box-shadow: none;
    }
    
    .btn-danger {
      background-color: var(--color-error);
      color: var(--color-on-error);
    }
    
    .btn-danger:hover {
      opacity: 0.9;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .btn-danger:active {
      transform: translateY(0);
      box-shadow: none;
    }
    
    .btn-outline {
      border: 1px solid var(--color-outline);
      background-color: transparent;
      color: var(--color-primary);
    }
    
    .btn-outline:hover {
      background-color: var(--color-surface-variant);
      border-color: var(--color-primary);
    }
    
    .btn-icon {
      width: 36px;
      height: 36px;
      padding: 0;
      border-radius: var(--radius-full);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Select personalizado */
    .select-wrapper {
      position: relative;
      display: inline-block;
    }
    
    .select {
      appearance: none;
      -webkit-appearance: none;
      padding: var(--spacing-xs) var(--spacing-xl) var(--spacing-xs) var(--spacing-md);
      border-radius: var(--radius-full);
      border: 1px solid var(--color-outline);
      background-color: var(--color-surface);
      cursor: pointer;
      transition: border-color var(--transition-normal), box-shadow var(--transition-normal);
      font-size: var(--font-size-sm);
    }
    
    .select:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
    }
    
    .select:hover {
      border-color: var(--color-primary);
    }
    
    .select-icon {
      position: absolute;
      right: var(--spacing-md);
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      color: var(--color-on-surface-variant);
    }
    
    /* Cards */
    .card {
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      padding: var(--spacing-md);
      box-shadow: var(--shadow-sm);
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    
    /* KPI Cards */
    .kpi-card {
      display: flex;
      flex-direction: column;
      background-color: var(--color-surface);
      padding: var(--spacing-md);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-sm);
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
    }
    
    .kpi-card:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-md);
    }
    
    .kpi-title {
      font-size: var(--font-size-sm);
      color: var(--color-on-surface-variant);
      margin-bottom: var(--spacing-xs);
      font-weight: var(--font-weight-medium);
    }
    
    .kpi-value {
      font-size: var(--font-size-2xl);
      font-weight: var(--font-weight-semibold);
      margin-bottom: var(--spacing-xs);
    }
    
    .kpi-subtitle {
      font-size: var(--font-size-xs);
      color: var(--color-on-surface-variant);
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
    }
    
    .kpi-income {
      border-left: 4px solid var(--color-income);
    }
    
    .kpi-expense {
      border-left: 4px solid var(--color-expense);
    }
    
    .kpi-balance {
      border-left: 4px solid var(--color-primary);
    }
    
    .kpi-card-invoice {
      border-left: 4px solid var(--color-card-invoice);
    }
    
    /* Insights */
    .insight-banner {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      padding: var(--spacing-md);
      border-radius: var(--radius-lg);
      margin-bottom: var(--spacing-md);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .insight-icon {
      font-size: 1.5rem;
    }
    
    .insight-content {
      flex: 1;
    }
    
    .insight-title {
      font-weight: var(--font-weight-medium);
      margin-bottom: var(--spacing-2xs);
    }
    
    .insight-danger {
      background-color: rgba(255, 59, 48, 0.1);
      border-left: 4px solid var(--color-error);
    }
    
    .insight-warning {
      background-color: rgba(255, 149, 0, 0.1);
      border-left: 4px solid var(--color-warning);
    }
    
    .insight-info {
      background-color: rgba(0, 122, 255, 0.1);
      border-left: 4px solid var(--color-info);
    }
    
    .insight-success {
      background-color: rgba(52, 199, 89, 0.1);
      border-left: 4px solid var(--color-success);
    }
    
    /* Badge */
    .badge {
      display: inline-block;
      padding: var(--spacing-2xs) var(--spacing-xs);
      border-radius: var(--radius-full);
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-medium);
    }
    
    .badge-success {
      background-color: rgba(52, 199, 89, 0.1);
      color: var(--color-success);
    }
    
    .badge-warning {
      background-color: rgba(255, 149, 0, 0.1);
      color: var(--color-warning);
    }
    
    .badge-danger {
      background-color: rgba(255, 59, 48, 0.1);
      color: var(--color-error);
    }
    
    .badge-info {
      background-color: rgba(0, 122, 255, 0.1);
      color: var(--color-info);
    }
    
    /* Modais */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity var(--transition-normal), visibility var(--transition-normal);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    
    .modal-backdrop.active {
      opacity: 1;
      visibility: visible;
    }
    
    .modal {
      width: 90%;
      max-width: 500px;
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      opacity: 0;
      transform: translateY(20px) scale(0.98);
      transition: opacity var(--transition-normal), transform var(--transition-normal);
    }
    
    .modal-backdrop.active .modal {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-md) var(--spacing-lg);
      border-bottom: 1px solid var(--color-outline);
    }
    
    .modal-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-semibold);
    }
    
    .modal-close {
      font-size: var(--font-size-xl);
      color: var(--color-on-surface-variant);
      cursor: pointer;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-full);
      transition: background-color var(--transition-normal);
    }
    
    .modal-close:hover {
      background-color: var(--color-surface-variant);
    }
    
    .modal-body {
      padding: var(--spacing-lg);
      max-height: 70vh;
      overflow-y: auto;
    }
    
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: var(--spacing-md);
      padding: var(--spacing-md) var(--spacing-lg);
      border-top: 1px solid var(--color-outline);
    }
    
    /* Toast */
    .toast-container {
      position: fixed;
      top: var(--spacing-md);
      right: var(--spacing-md);
      z-index: 2000;
    }
    
    .toast {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      background-color: var(--color-surface);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
      margin-bottom: var(--spacing-md);
      box-shadow: var(--shadow-md);
      min-width: 300px;
      max-width: 400px;
      transform: translateX(120%);
      transition: transform var(--transition-normal);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .toast.show {
      transform: translateX(0);
    }
    
    .toast-icon {
      font-size: 1.5rem;
    }
    
    .toast-content {
      flex: 1;
    }
    
    .toast-close {
      font-size: var(--font-size-lg);
      color: var(--color-on-surface-variant);
      cursor: pointer;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-full);
      transition: background-color var(--transition-normal);
    }
    
    .toast-close:hover {
      background-color: var(--color-surface-variant);
    }
    
    .toast-success {
      border-left: 4px solid var(--color-success);
    }
    
    .toast-error {
      border-left: 4px solid var(--color-error);
    }
    
    .toast-warning {
      border-left: 4px solid var(--color-warning);
    }
    
    .toast-info {
      border-left: 4px solid var(--color-info);
    }
    
    /* Inputs */
    .form-group {
      margin-bottom: var(--spacing-md);
    }
    
    .form-label {
      display: block;
      font-size: var(--font-size-sm);
      color: var(--color-on-surface-variant);
      margin-bottom: var(--spacing-xs);
      font-weight: var(--font-weight-medium);
    }
    
    .form-control {
      width: 100%;
      padding: var(--spacing-xs) var(--spacing-md);
      border-radius: var(--radius-md);
      border: 1px solid var(--color-outline);
      background-color: var(--color-surface);
      transition: border-color var(--transition-normal), box-shadow var(--transition-normal);
    }
    
    .form-control:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
    }
    
    .form-control:hover:not(:focus) {
      border-color: var(--color-primary);
    }
    
    /* Radio buttons */
    .radio-group {
      display: flex;
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-md);
      flex-wrap: wrap;
    }
    
    .radio-wrapper {
      position: relative;
    }
    
    .radio {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .radio-label {
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-xs) var(--spacing-md);
      border-radius: var(--radius-full);
      border: 1px solid var(--color-outline);
      cursor: pointer;
      transition: all var(--transition-normal);
    }
    
    .radio:checked + .radio-label {
      border-color: var(--color-primary);
      background-color: rgba(0, 122, 255, 0.1);
    }
    
    .radio-circle {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid var(--color-outline);
      position: relative;
    }
    
    .radio:checked + .radio-label .radio-circle:after {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: var(--color-primary);
    }
    
    /* Checkbox personalizado */
    .checkbox-wrapper {
      position: relative;
      display: inline-block;
    }
    
    .checkbox {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .checkbox-label {
      display: inline-block;
      width: 20px;
      height: 20px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--color-outline);
      background-color: var(--color-surface);
      cursor: pointer;
      transition: all var(--transition-normal);
    }
    
    .checkbox:checked + .checkbox-label {
      background-color: var(--color-primary);
      border-color: var(--color-primary);
    }
    
    .checkbox:checked + .checkbox-label:after {
      content: '';
      position: absolute;
      left: 7px;
      top: 3px;
      width: 6px;
      height: 10px;
      border: solid white;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }
    
    /* Tema Toggle */
    .theme-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: var(--radius-full);
      cursor: pointer;
      background-color: var(--color-surface-variant);
      transition: background-color var(--transition-normal);
    }
    
    .theme-toggle:hover {
      background-color: var(--color-outline);
    }
    
    .theme-toggle .icon-sun,
    .theme-toggle .icon-moon {
      width: 20px;
      height: 20px;
      color: var(--color-on-surface-variant);
    }
    
    /* Esconder o ícone não ativo */
    [data-theme="light"] .theme-toggle .icon-moon {
      display: none;
    }
    
    [data-theme="dark"] .theme-toggle .icon-sun {
      display: none;
    }
    
    /* Investimentos */
    .investment-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: var(--spacing-lg);
      margin-bottom: var(--spacing-xl);
    }
    
    .investment-card {
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      padding: var(--spacing-lg);
      box-shadow: var(--shadow-sm);
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
      display: flex;
      flex-direction: column;
    }
    
    .investment-card:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-md);
    }
    
    .investment-card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: var(--spacing-md);
    }
    
    .investment-card-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-semibold);
      margin: 0;
    }
    
    .investment-card-body {
      flex: 1;
      margin-bottom: var(--spacing-md);
    }
    
    .investment-card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: auto;
    }
    
    .investment-progress {
      margin-top: var(--spacing-md);
    }
    
    .investment-progress-bar {
      height: 8px;
      background-color: var(--color-surface-variant);
      border-radius: var(--radius-full);
      overflow: hidden;
      margin-bottom: var(--spacing-xs);
    }
    
    .investment-progress-fill {
      height: 100%;
      background-color: var(--color-primary);
      border-radius: var(--radius-full);
    }
    
    .investment-progress-text {
      display: flex;
      justify-content: space-between;
      font-size: var(--font-size-sm);
      color: var(--color-on-surface-variant);
    }
    
    .investment-detail {
      margin-bottom: var(--spacing-md);
    }
    
    .investment-detail-header {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-lg);
    }
    
    .investment-detail-stat {
      background-color: var(--color-surface-variant);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
    }
    
    .investment-detail-title {
      font-size: var(--font-size-sm);
      color: var(--color-on-surface-variant);
      margin-bottom: var(--spacing-xs);
    }
    
    .investment-detail-value {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
    }
    
    .investment-history {
      margin-bottom: var(--spacing-lg);
    }
    
    .investment-history-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      margin-bottom: var(--spacing-md);
    }
    
    .investment-history-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: var(--spacing-md);
    }
    
    .investment-history-table th {
      text-align: left;
      padding: var(--spacing-sm);
      font-weight: var(--font-weight-medium);
      color: var(--color-on-surface-variant);
      background-color: var(--color-surface);
      border-bottom: 1px solid var(--color-outline);
    }
    
    .investment-history-table td {
      padding: var(--spacing-sm);
      border-bottom: 1px solid var(--color-outline);
    }
    
    /* Gerenciamento de categorias */
    .categories-container {
      padding: var(--spacing-lg);
    }
    
    .nav-tabs {
      display: flex;
      list-style: none;
      padding: 0;
      margin: 0 0 var(--spacing-lg) 0;
      border-bottom: 1px solid var(--color-outline);
      flex-wrap: wrap; /* Melhorar layout em celulares - Problema #10 */
    }
    
    .nav-item {
      margin-right: var(--spacing-lg);
      margin-bottom: var(--spacing-xs); /* Espaçamento adequado para layout mobile - Problema #10 */
    }
    
    .nav-link {
      display: inline-block;
      padding: var(--spacing-sm) 0;
      border-bottom: 2px solid transparent;
      font-weight: var(--font-weight-medium);
      color: var(--color-on-surface-variant);
      transition: all var(--transition-normal);
    }
    
    .nav-link:hover {
      color: var(--color-primary);
    }
    
    .nav-link.active {
      color: var(--color-primary);
      border-bottom-color: var(--color-primary);
    }
    
    .tab-content {
      padding: var(--spacing-md) 0;
    }
    
    .tab-pane {
      display: none;
    }
    
    .tab-pane.active {
      display: block;
    }
    
    .tab-pane.show {
      animation: fadeIn var(--transition-normal);
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .category-list {
      margin-bottom: var(--spacing-lg);
    }
    
    .category-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-sm);
      border-radius: var(--radius-md);
      transition: background-color var(--transition-normal);
      margin-bottom: var(--spacing-xs);
    }
    
    .category-item:hover {
      background-color: var(--color-surface-variant);
    }
    
    .category-item-content {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
    }
    
    .category-item-icon {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-full);
      background-color: var(--color-surface);
    }
    
    .category-item-actions {
      display: flex;
      gap: var(--spacing-xs);
    }
    
    .add-category-form {
      display: flex;
      align-items: flex-end;
      gap: var(--spacing-sm);
      flex-wrap: wrap; /* Permitir quebra em telas pequenas - Problema #10 */
    }
    
    /* Versão mobile para add-category-form - Problema #10 */
    @media (max-width: 576px) {
      .add-category-form {
        flex-direction: column;
        align-items: stretch;
      }
      
      .add-category-form button {
        margin-top: var(--spacing-sm);
      }
    }
    
    .custom-icon-input {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
    }
    
    .custom-icon-preview {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: var(--color-surface-variant);
      border-radius: var(--radius-full);
    }
    
    /* Responsividade */
    @media (max-width: 992px) {
      .charts-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    
    @media (max-width: 768px) {
      .header {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--spacing-md);
      }
      
      .header-filters, .header-actions {
        width: 100%;
        justify-content: flex-start;
        flex-wrap: wrap;
        gap: var(--spacing-sm);
      }
      
      .transactions-table {
        display: block;
        overflow-x: auto;
      }
      
      .hero-title {
        font-size: var(--font-size-2xl);
      }
      
      .charts-grid {
        grid-template-columns: 1fr;
      }
      
      .investment-grid {
        grid-template-columns: 1fr;
      }
    }
    
    @media (max-width: 576px) {
      .kpi-grid {
        grid-template-columns: 1fr;
      }
      
      .header-filters {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .investment-detail-header {
        grid-template-columns: 1fr;
      }
    }
    
    /* Filtro de tipo de transação - Problema #8 */
    .transaction-type-filter {
      display: flex;
      gap: var(--spacing-xs);
      margin-bottom: var(--spacing-md);
    }
    
    .transaction-type-filter .btn {
      font-size: var(--font-size-sm);
      background-color: var(--color-surface-variant);
      color: var(--color-on-surface);
    }
    
    .transaction-type-filter .btn.active {
      background-color: var(--color-primary);
      color: var(--color-on-primary);
    }
    
    /* Colunas da tabela de transações - Problema #18 */
    .table-column-hide {
      display: none;
    }
  </style>
</head>
<body>
  <!-- SVG Sprite de ícones (HeroIcons) -->
  <svg style="display: none;">
    <!-- Ícones de navegação -->
    <symbol id="icon-home" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
    </symbol>
    <symbol id="icon-plus" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" />
    </symbol>
    <symbol id="icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
    </symbol>
    <symbol id="icon-chart" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z" />
    </symbol>
    <symbol id="icon-credit-card" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z" />
    </symbol>
    
    <!-- Ícones de ações -->
    <symbol id="icon-edit" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
    </symbol>
    <symbol id="icon-trash" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
    </symbol>
    <symbol id="icon-check" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
    </symbol>
    <symbol id="icon-x" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
    </symbol>
    <symbol id="icon-chevron-down" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
    </symbol>
    <symbol id="icon-chevron-up" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" />
    </symbol>
    <symbol id="icon-arrow-left" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
    </symbol>
    
    <!-- Ícones tema claro/escuro -->
    <symbol id="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
    </symbol>
    <symbol id="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
    </symbol>
    
    <!-- Ícones para categorias -->
    <symbol id="icon-shopping" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z" />
    </symbol>
    <symbol id="icon-food" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z" />
    </symbol>
    <symbol id="icon-home-category" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
    </symbol>
    <symbol id="icon-bill" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
    </symbol>
    <symbol id="icon-default" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </symbol>
    <symbol id="icon-money" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </symbol>
    
    <!-- Ícones para alertas -->
    <symbol id="icon-alert" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
    </symbol>
    <symbol id="icon-info" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </symbol>
    <symbol id="icon-settings" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
      <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    </symbol>
    
    <!-- Ícones para ordenação -->
    <symbol id="icon-sort-asc" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" />
    </symbol>
    <symbol id="icon-sort-desc" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
    </symbol>
    
    <!-- Ícone de filtro para tipo de transação -->
    <symbol id="icon-filter" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
    </symbol>
  </svg>

  <div class="container">
    <!-- Header -->
    <header class="header">
      <div class="header-filters">
        <div class="select-date-container">
          <div class="select-wrapper">
            <select id="yearSelect" class="select">
              <option value="2023">2023</option>
              <option value="2024">2024</option>
              <option value="2025" selected>2025</option>
              <option value="2026">2026</option>
              <option value="2027">2027</option>
              <option value="2028">2028</option>
              <option value="2029">2029</option>
              <option value="2030">2030</option>
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
          
          <div class="select-wrapper">
            <select id="monthSelect" class="select">
              <option value="0">Janeiro</option>
              <option value="1">Fevereiro</option>
              <option value="2">Março</option>
              <option value="3">Abril</option>
              <option value="4" selected>Maio</option>
              <option value="5">Junho</option>
              <option value="6">Julho</option>
              <option value="7">Agosto</option>
              <option value="8">Setembro</option>
              <option value="9">Outubro</option>
              <option value="10">Novembro</option>
              <option value="11">Dezembro</option>
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
      </div>
      
      <div class="header-actions">
        <!-- Ajuste 5: Reposicionamento do botão de tema -->
        <div id="themeToggle" class="theme-toggle" role="button" aria-label="Alternar tema">
          <svg class="icon-sun" width="20" height="20">
            <use href="#icon-sun"></use>
          </svg>
          <svg class="icon-moon" width="20" height="20">
            <use href="#icon-moon"></use>
          </svg>
        </div>
        
        <button id="newIncomeBtn" class="btn btn-success">
          Nova Receita
        </button>
        
        <button id="newExpenseBtn" class="btn btn-danger">
          Nova Despesa
        </button>
        
        <button id="cardsBtn" class="btn btn-outline">
          <svg width="16" height="16">
            <use href="#icon-credit-card"></use>
          </svg>
          Cartões
        </button>
        
        <button id="categoriesBtn" class="btn btn-outline">
          <svg width="16" height="16">
            <use href="#icon-settings"></use>
          </svg>
          Categorias
        </button>
        
        <button id="investmentsBtn" class="btn btn-outline">
          <svg width="16" height="16">
            <use href="#icon-chart"></use>
          </svg>
          Investimentos
        </button>
      </div>
    </header>
    
    <!-- Hero Section (AJUSTE 1: Texto alterado) -->
    <section class="hero">
      <h1 class="hero-title">Wagner. Bárbara. Joaquim.</h1>
      <p class="hero-subtitle">Porque o futuro que sonhamos começa com o que fazemos hoje.</p>
    </section>
    
    <!-- KPIs -->
    <div class="kpi-grid">
      <div class="kpi-card kpi-balance">
        <div class="kpi-title">Saldo Real (Caixa)</div>
        <div class="kpi-value" id="balanceValue">R$ 0,00</div>
        <div class="kpi-subtitle">
          <svg width="16" height="16">
            <use href="#icon-info"></use>
          </svg>
          <span>Saldo comprometido: R$ 0,00</span>
        </div>
      </div>
      
      <div class="kpi-card kpi-income">
        <div class="kpi-title">Receitas</div>
        <div class="kpi-value" id="incomeValue">R$ 0,00</div>
        <div class="kpi-subtitle">
          <span id="incomeReceivedValue">R$ 0,00 recebidos</span> /
          <span id="incomePendingValue">R$ 0,00 pendentes</span>
        </div>
      </div>
      
      <div class="kpi-card kpi-expense">
        <div class="kpi-title">Despesas</div>
        <div class="kpi-value" id="expenseValue">R$ 0,00</div>
        <div class="kpi-subtitle">
          <span id="expensePaidValue">R$ 0,00 pagos</span> /
          <span id="expensePendingValue">R$ 0,00 pendentes</span>
        </div>
      </div>
      
      <div class="kpi-card kpi-card-invoice">
        <div class="kpi-title">Fatura do Mês</div>
        <div class="kpi-value" id="invoiceValue">R$ 0,00</div>
        <div class="kpi-subtitle">
          <svg width="16" height="16">
            <use href="#icon-credit-card"></use>
          </svg>
          <span>Vencimento: <span id="invoiceDueDate">15/05/2025</span></span>
        </div>
      </div>
    </div>
    
    <!-- Insights Banner -->
    <div class="insights-banner" id="insightsBanner">
      <!-- Insights serão inseridos aqui dinamicamente -->
    </div>
    
    <!-- AJUSTE 7: Reorganização dos gráficos em grade 2x2 -->
    <section class="charts-container">
      <h2 class="charts-title">Resumo Financeiro</h2>
      
      <!-- Primeira linha: Despesas por Categoria e Limite do Cartão -->
      <div class="charts-grid">
        <div class="chart-container">
          <h3>Despesas por Categoria</h3>
          <canvas id="catPie"></canvas>
        </div>
        
        <div class="chart-container">
          <h3>Limite do Cartão</h3>
          <canvas id="cardArea"></canvas>
        </div>
      </div>
      
      <!-- Segunda linha: Despesas Fixas vs Variáveis e Despesas por Pessoa -->
      <div class="charts-grid">
        <div class="chart-container">
          <h3>Despesas Fixas vs Variáveis</h3>
          <canvas id="fixedVsVariableChart"></canvas>
        </div>
        
        <div class="chart-container">
          <h3>Despesas por Pessoa</h3>
          <canvas id="personAnalysisChart"></canvas>
        </div>
      </div>
    </section>
    
    <!-- Gráfico Anual de Barras -->
    <div class="chart-container" style="margin-bottom: var(--spacing-2xl);">
      <h3>Receitas x Despesas (12 meses)</h3>
      <canvas id="annualBars"></canvas>
    </div>
    
    <!-- Compromissos Longos -->
    <div class="commitments">
      <div class="commitments-header active" id="commitmentsHeader">
        <h3>Compromissos Longos</h3>
      </div>
      
      <div class="commitments-content" id="commitmentsContent" style="max-height: none;">
        <!-- Compromissos serão inseridos aqui dinamicamente -->
      </div>
    </div>
    
    <!-- AJUSTE 8, 10 e 11: Revisão da seção de Transações -->
    <section class="transactions-container">
      <div class="card-transacoes">
        <div class="card-header">
          <h3 class="card-title">Transações</h3>
          
          <!-- Filtro de tipo de transação - Problema #8 -->
          <div class="transaction-type-filter" id="transactionTypeFilter">
            <button class="btn active" data-type="all">Todos</button>
            <button class="btn" data-type="expense">Despesas</button>
            <button class="btn" data-type="income">Receitas</button>
          </div>
          
          <div class="filters transaction-filters" id="transaction-filters">
            <!-- Filtros serão inseridos aqui dinamicamente -->
          </div>
        </div>
        
        <div class="card-body">
          <table class="transactions-table" id="transactionsTable">
            <thead>
              <tr>
                <!-- Problema #18: coluna de ícones removida por padrão, será controlada por JS -->
                <th class="table-column-hide"></th>
                <th class="sortable" data-sort="name">Nome</th>
                <!-- Problema #18: coluna de categoria removida por padrão, será controlada por JS -->
                <th class="sortable table-column-hide" data-sort="category">Categoria</th>
                <!-- AJUSTE 15: Nova coluna de Pessoas -->
                <th class="sortable" data-sort="person">Pessoa</th>
                <th class="sortable" data-sort="date">Data</th>
                <th class="sortable" data-sort="dueDate">Vencimento</th>
                <th class="sortable" data-sort="amount">Valor</th>
                <th class="sortable" data-sort="status">Status</th>
                <th class="sortable" data-sort="paymentMethod">Pagamento</th>
                <!-- Problema #18: Coluna Tipo removida por padrão, será controlada por JS -->
                <th class="sortable table-column-hide" data-sort="isFixed">Tipo</th>
                <th>Pago?</th>
                <th>Ações</th>
              </tr>
            </thead>
            <tbody id="transactionsTableBody">
              <!-- Transações serão inseridas aqui dinamicamente -->
            </tbody>
          </table>
        </div>
      </div>
    </section>
  </div>

  <!-- Modais -->
  <!-- Modal de Nova Receita -->
  <div class="modal-backdrop" id="incomeModal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title">Nova Receita</h2>
        <span class="modal-close" id="closeIncomeModal">
          <svg width="24" height="24">
            <use href="#icon-x"></use>
          </svg>
        </span>
      </div>
      
      <div class="modal-body">
        <form id="incomeForm">
          <div class="form-group">
            <label class="form-label" for="incomeName">Nome</label>
            <input type="text" class="form-control" id="incomeName" placeholder="Nome da receita">
          </div>
          
          <div class="form-group">
            <label class="form-label" for="incomeAmount">Valor</label>
            <input type="number" class="form-control" id="incomeAmount" placeholder="0,00" min="0" step="0.01">
          </div>
          
          <div class="form-group">
            <label class="form-label" for="incomeCategory">Categoria</label>
            <div class="select-wrapper">
              <select class="select" id="incomeCategory">
                <!-- Categorias serão carregadas dinamicamente -->
             </select>
             <svg class="select-icon" width="16" height="16">
               <use href="#icon-chevron-down"></use>
             </svg>
           </div>
         </div>
         
         <div class="form-group">
           <label class="form-label" for="incomeDate">Data de Lançamento</label>
           <input type="date" class="form-control" id="incomeDate">
         </div>
         
         <div class="form-group">
           <label class="form-label" for="incomePaymentMethod">Forma de Recebimento</label>
           <div class="select-wrapper">
             <select class="select" id="incomePaymentMethod">
               <!-- Formas de pagamento serão carregadas dinamicamente -->
             </select>
             <svg class="select-icon" width="16" height="16">
               <use href="#icon-chevron-down"></use>
             </svg>
           </div>
         </div>
         
         <div class="form-group">
           <div class="checkbox-wrapper">
             <input type="checkbox" class="checkbox" id="incomeIsRecurrent">
             <label class="checkbox-label" for="incomeIsRecurrent"></label>
           </div>
           <label class="form-label" for="incomeIsRecurrent" style="display: inline-block; margin-left: 8px;">Receita Recorrente</label>
         </div>
         
         <div class="form-group" id="incomeRecurrenceGroup" style="display: none;">
           <label class="form-label" for="incomeInstallments">Quantidade de Parcelas</label>
           <input type="number" class="form-control" id="incomeInstallments" min="2" value="2">
         </div>

         <div class="form-group" id="incomeStatusGroup">
           <label class="form-label">Status</label>
           <div class="radio-group">
             <div class="radio-wrapper">
               <input type="radio" class="radio" id="incomeStatusReceived" name="incomeStatus" value="received" checked>
               <label class="radio-label" for="incomeStatusReceived">
                 <span class="radio-circle"></span>
                 Recebido
               </label>
             </div>
             
             <div class="radio-wrapper">
               <input type="radio" class="radio" id="incomeStatusPending" name="incomeStatus" value="pending">
               <label class="radio-label" for="incomeStatusPending">
                 <span class="radio-circle"></span>
                 A Receber
               </label>
             </div>
           </div>
         </div>
         
         <div class="form-group">
           <label class="form-label" for="incomeNotes">Observação (opcional)</label>
           <textarea class="form-control" id="incomeNotes" rows="3"></textarea>
         </div>
       </form>
     </div>
     
     <div class="modal-footer">
       <button class="btn btn-outline" id="cancelIncomeBtn">Cancelar</button>
       <button class="btn btn-success" id="saveIncomeBtn">Salvar Receita</button>
     </div>
   </div>
 </div>

 <!-- Modal de Nova Despesa -->
 <div class="modal-backdrop" id="expenseModal">
   <div class="modal">
     <div class="modal-header">
       <h2 class="modal-title">Nova Despesa</h2>
       <span class="modal-close" id="closeExpenseModal">
         <svg width="24" height="24">
           <use href="#icon-x"></use>
         </svg>
       </span>
     </div>
     
     <div class="modal-body">
       <form id="expenseForm">
         <div class="form-group">
           <label class="form-label" for="expenseName">Nome</label>
           <input type="text" class="form-control" id="expenseName" placeholder="Nome da despesa">
         </div>
         
         <div class="form-group">
           <label class="form-label" for="expenseAmount">Valor</label>
           <input type="number" class="form-control" id="expenseAmount" placeholder="0,00" min="0" step="0.01">
         </div>
         
         <div class="form-group">
           <label class="form-label" for="expensePaymentMethod">Forma de Pagamento</label>
           <div class="select-wrapper">
             <select class="select" id="expensePaymentMethod">
               <!-- Formas de pagamento serão carregadas dinamicamente -->
             </select>
             <svg class="select-icon" width="16" height="16">
               <use href="#icon-chevron-down"></use>
             </svg>
           </div>
         </div>
         
         <!-- AJUSTE 13: Reposicionamento do campo Cartão de Crédito -->
         <div class="form-group" id="creditCardGroup" style="display: none;">
           <label class="form-label" for="expenseCreditCard">Cartão de Crédito</label>
           <div class="select-wrapper">
             <select class="select" id="expenseCreditCard">
               <!-- Opções de cartões serão inseridas dinamicamente -->
             </select>
             <svg class="select-icon" width="16" height="16">
               <use href="#icon-chevron-down"></use>
             </svg>
           </div>
         </div>
         
         <div class="form-group">
           <label class="form-label" for="expenseCategory">Categoria</label>
           <div class="select-wrapper">
             <select class="select" id="expenseCategory">
               <!-- Categorias serão carregadas dinamicamente -->
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <!-- Campo Pessoas (já existente) -->
        <div class="form-group">
          <label class="form-label" for="expensePerson">Pessoa</label>
          <div class="select-wrapper">
            <select class="select" id="expensePerson">
              <!-- Pessoas serão carregadas dinamicamente -->
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <!-- AJUSTE 16: Campo obrigatório para marcar despesa como fixa ou variável -->
        <div class="form-group">
          <label class="form-label">Tipo de Despesa</label>
          <div class="radio-group">
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="expenseTypeFixed" name="expenseType" value="fixed" required>
              <label class="radio-label" for="expenseTypeFixed">
                <span class="radio-circle"></span>
                Fixa
              </label>
            </div>
            
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="expenseTypeVariable" name="expenseType" value="variable" required>
              <label class="radio-label" for="expenseTypeVariable">
                <span class="radio-circle"></span>
                Variável
              </label>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label" for="expenseDate">Data de Lançamento</label>
          <input type="date" class="form-control" id="expenseDate">
        </div>
        
        <div class="form-group" id="expenseDueDateGroup">
          <label class="form-label" for="expenseDueDate">Data de Vencimento</label>
          <input type="date" class="form-control" id="expenseDueDate">
        </div>
        
        <div class="form-group">
          <div class="checkbox-wrapper">
            <input type="checkbox" class="checkbox" id="expenseIsRecurrent">
            <label class="checkbox-label" for="expenseIsRecurrent"></label>
          </div>
          <label class="form-label" for="expenseIsRecurrent" style="display: inline-block; margin-left: 8px;">Despesa Recorrente</label>
        </div>
        
        <div class="form-group" id="expenseRecurrenceGroup" style="display: none;">
          <label class="form-label" for="expenseInstallments">Quantidade de Parcelas</label>
          <input type="number" class="form-control" id="expenseInstallments" min="2" value="2">
        </div>
        
        <div class="form-group" id="expenseStatusGroup">
          <label class="form-label">Status</label>
          <div class="radio-group">
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="expenseStatusPaid" name="expenseStatus" value="paid">
              <label class="radio-label" for="expenseStatusPaid">
                <span class="radio-circle"></span>
                Pago
              </label>
            </div>
            
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="expenseStatusPending" name="expenseStatus" value="pending" checked>
              <label class="radio-label" for="expenseStatusPending">
                <span class="radio-circle"></span>
                Pendente
              </label>
            </div>
            
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="expenseStatusScheduled" name="expenseStatus" value="scheduled">
              <label class="radio-label" for="expenseStatusScheduled">
                <span class="radio-circle"></span>
                Agendado
              </label>
            </div>
          </div>
        </div>
        
        <div class="form-group" id="scheduledDateGroup" style="display: none;">
          <label class="form-label" for="expenseScheduledDate">Data de Agendamento</label>
          <input type="date" class="form-control" id="expenseScheduledDate">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="expenseNotes">Observação (opcional)</label>
          <textarea class="form-control" id="expenseNotes" rows="3"></textarea>
        </div>
      </form>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelExpenseBtn">Cancelar</button>
      <button class="btn btn-danger" id="saveExpenseBtn">Salvar Despesa</button>
    </div>
  </div>
 </div>

 <!-- Modal de Edição de Transação -->
 <div class="modal-backdrop" id="editModal">
  <div class="modal">
    <div class="modal-header">
      <h2 class="modal-title" id="editModalTitle">Editar Transação</h2>
      <span class="modal-close" id="closeEditModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <form id="editForm">
        <input type="hidden" id="editTransactionId">
        <input type="hidden" id="editTransactionType">
        
        <div class="form-group">
          <label class="form-label" for="editName">Nome</label>
          <input type="text" class="form-control" id="editName">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="editAmount">Valor</label>
          <input type="number" class="form-control" id="editAmount" min="0" step="0.01">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="editCategory">Categoria</label>
          <div class="select-wrapper">
            <select class="select" id="editCategory">
              <!-- Opções de categorias serão inseridas dinamicamente -->
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <!-- Campo de Pessoa na edição (já existente) -->
        <div class="form-group" id="editPersonGroup">
          <label class="form-label" for="editPerson">Pessoa</label>
          <div class="select-wrapper">
            <select class="select" id="editPerson">
              <!-- Pessoas serão carregadas dinamicamente -->
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <!-- AJUSTE 16: Campo de tipo de despesa (fixa/variável) na edição -->
        <div class="form-group" id="editExpenseTypeGroup" style="display: none;">
          <label class="form-label">Tipo de Despesa</label>
          <div class="radio-group">
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="editExpenseTypeFixed" name="editExpenseType" value="fixed">
              <label class="radio-label" for="editExpenseTypeFixed">
                <span class="radio-circle"></span>
                Fixa
              </label>
            </div>
            
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="editExpenseTypeVariable" name="editExpenseType" value="variable">
              <label class="radio-label" for="editExpenseTypeVariable">
                <span class="radio-circle"></span>
                Variável
              </label>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label" for="editDate">Data de Lançamento</label>
          <input type="date" class="form-control" id="editDate">
        </div>
        
        <div class="form-group" id="editDueDateGroup">
          <label class="form-label" for="editDueDate">Data de Vencimento</label>
          <input type="date" class="form-control" id="editDueDate">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="editPaymentMethod">Forma de Pagamento</label>
          <div class="select-wrapper">
            <select class="select" id="editPaymentMethod">
              <!-- Opções de formas de pagamento serão inseridas dinamicamente -->
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <!-- AJUSTE 13: Reposicionamento do campo Cartão de Crédito -->
        <div class="form-group" id="editCreditCardGroup" style="display: none;">
          <label class="form-label" for="editCreditCard">Cartão de Crédito</label>
          <div class="select-wrapper">
            <select class="select" id="editCreditCard">
              <!-- Opções de cartões serão inseridas dinamicamente -->
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <div class="form-group">
          <div class="checkbox-wrapper">
            <input type="checkbox" class="checkbox" id="editIsRecurrent">
            <label class="checkbox-label" for="editIsRecurrent"></label>
          </div>
          <label class="form-label" for="editIsRecurrent" style="display: inline-block; margin-left: 8px;">Transação Recorrente</label>
        </div>
        
        <div class="form-group" id="editRecurrenceGroup" style="display: none;">
          <label class="form-label" for="editInstallments">Quantidade de Parcelas</label>
          <input type="number" class="form-control" id="editInstallments" min="2" value="2">
        </div>
        
        <div class="form-group">
          <label class="form-label">Status</label>
          <div class="radio-group" id="editStatusGroup">
            <!-- Opções de status serão inseridas dinamicamente -->
          </div>
        </div>
        
        <div class="form-group" id="editScheduledDateGroup" style="display: none;">
          <label class="form-label" for="editScheduledDate">Data de Agendamento</label>
          <input type="date" class="form-control" id="editScheduledDate">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="editNotes">Observação (opcional)</label>
          <textarea class="form-control" id="editNotes" rows="3"></textarea>
        </div>
      </form>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelEditBtn">Cancelar</button>
      <button class="btn btn-primary" id="saveEditBtn">Salvar Alterações</button>
    </div>
  </div>
 </div>

 <!-- Modal de Cartões -->
 <div class="modal-backdrop" id="cardsListModal">
  <div class="modal">
    <div class="modal-header">
      <h2 class="modal-title">Cartões</h2>
      <span class="modal-close" id="closeCardsListModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <div id="cardsList">
        <!-- Cards serão inseridos aqui dinamicamente -->
      </div>
      
      <button class="btn btn-primary" id="newCardBtn" style="margin-top: var(--spacing-md);">
        <svg width="16" height="16">
          <use href="#icon-plus"></use>
        </svg>
        Novo Cartão
      </button>
    </div>
  </div>
 </div>

 <!-- Modal de Novo Cartão -->
 <div class="modal-backdrop" id="newCardModal">
  <div class="modal">
    <div class="modal-header">
      <h2 class="modal-title">Novo Cartão</h2>
      <span class="modal-close" id="closeNewCardModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <form id="cardForm">
        <div class="form-group">
          <label class="form-label" for="cardName">Nome do Cartão</label>
          <input type="text" class="form-control" id="cardName" placeholder="Ex: Nubank">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="cardLimit">Limite Total</label>
          <input type="number" class="form-control" id="cardLimit" placeholder="0,00" min="0" step="0.01">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="cardClosingDay">Dia de Fechamento</label>
          <input type="number" class="form-control" id="cardClosingDay" placeholder="1-31" min="1" max="31">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="cardDueDay">Dia de Vencimento</label>
          <input type="number" class="form-control" id="cardDueDay" placeholder="1-31" min="1" max="31">
        </div>
      </form>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelCardBtn">Cancelar</button>
      <button class="btn btn-primary" id="saveCardBtn">Salvar Cartão</button>
    </div>
  </div>
 </div>

 <!-- Modal de Fatura do Cartão -->
 <div class="modal-backdrop" id="cardInvoiceModal">
  <div class="modal" style="max-width: 700px;">
    <div class="modal-header">
      <h2 class="modal-title" id="cardInvoiceTitle">Fatura do Cartão</h2>
      <span class="modal-close" id="closeCardInvoiceModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <div class="card" style="margin-bottom: var(--spacing-md);">
        <div id="cardInvoiceDetails">
          <!-- Detalhes da fatura serão inseridos aqui dinamicamente -->
        </div>
      </div>
      
      <h3>Despesas desta Fatura</h3>
      <table class="transactions-table" id="cardInvoiceTable">
        <thead>
          <tr>
            <th></th>
            <th>Nome</th>
            <th>Data</th>
            <th>Valor</th>
            <th>Pago?</th>
          </tr>
        </thead>
        <tbody id="cardInvoiceTableBody">
          <!-- Despesas da fatura serão inseridas aqui dinamicamente -->
        </tbody>
      </table>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="backToCardsBtn">Voltar</button>
      <button class="btn btn-primary" id="payInvoiceBtn">Pagar Fatura</button>
    </div>
  </div>
 </div>

 <!-- Modal de Confirmação de Exclusão -->
 <div class="modal-backdrop" id="deleteConfirmModal">
  <div class="modal" style="max-width: 400px;">
    <div class="modal-header">
      <h2 class="modal-title">
        <svg width="24" height="24" style="vertical-align: middle; margin-right: 8px;">
          <use href="#icon-alert"></use>
        </svg>
        Confirmar Exclusão
      </h2>
      <span class="modal-close" id="closeDeleteConfirmModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <p>Você deseja realmente excluir esta transação? Esta ação é irreversível.</p>
      
      <div id="recurrenceDeleteOptions" style="display: none; margin-top: var(--spacing-md);">
        <p><strong>Esta é uma transação recorrente. O que deseja fazer?</strong></p>
        
        <div class="radio-group" style="flex-direction: column; gap: var(--spacing-sm);">
          <div class="radio-wrapper">
            <input type="radio" class="radio" id="deleteSingle" name="deleteOption" value="single" checked>
            <label class="radio-label" for="deleteSingle">
              <span class="radio-circle"></span>
              Excluir apenas esta parcela
            </label>
          </div>
          
          <div class="radio-wrapper">
            <input type="radio" class="radio" id="deleteAllFuture" name="deleteOption" value="future">
            <label class="radio-label" for="deleteAllFuture">
              <span class="radio-circle"></span>
              Excluir todas as parcelas futuras
            </label>
          </div>
        </div>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelDeleteBtn">Cancelar</button>
      <button class="btn btn-danger" id="confirmDeleteBtn">Excluir</button>
    </div>
  </div>
 </div>

 <!-- Modal de Confirmação de Pagamento de Fatura -->
 <div class="modal-backdrop" id="payInvoiceConfirmModal">
  <div class="modal" style="max-width: 400px;">
    <div class="modal-header">
      <h2 class="modal-title">
        <svg width="24" height="24" style="vertical-align: middle; margin-right: 8px;">
          <use href="#icon-credit-card"></use>
        </svg>
        Pagar Fatura do Cartão
      </h2>
      <span class="modal-close" id="closePayInvoiceConfirmModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <p>Confirmar pagamento de todas as despesas desta fatura?</p>
      <p style="margin-top: var(--spacing-xs);">Total: <strong id="invoiceConfirmAmount">R$ 0,00</strong></p>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelPayInvoiceBtn">Cancelar</button>
      <button class="btn btn-primary" id="confirmPayInvoiceBtn">Pagar</button>
    </div>
  </div>
 </div>

 <!-- AJUSTE 3: Modal de Categorias reformulado -->
 <div class="modal-backdrop" id="categoriesModal">
  <div class="modal" style="max-width: 600px;">
    <div class="modal-header">
      <h2 class="modal-title">Gerenciar Categorias</h2>
      <span class="modal-close" id="closeCategoriesModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body categories-container">
      <ul class="nav-tabs" id="categoryTabs" role="tablist">
        <li class="nav-item">
          <a class="nav-link active" id="income-cat-tab" data-toggle="tab" href="#income-cat" role="tab">Receitas</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" id="expense-cat-tab" data-toggle="tab" href="#expense-cat" role="tab">Despesas</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" id="payment-methods-tab" data-toggle="tab" href="#payment-methods" role="tab">Pagamentos</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" id="people-tab" data-toggle="tab" href="#people" role="tab">Pessoas</a>
        </li>
        <!-- AJUSTE 2: Inclusão de gerenciamento de categorias de investimentos -->
        <li class="nav-item">
          <a class="nav-link" id="investment-cat-tab" data-toggle="tab" href="#investment-cat" role="tab">Investimentos</a>
        </li>
      </ul>
      
      <div class="tab-content" id="categoryTabContent">
        <!-- Categorias de Receita -->
        <div class="tab-pane fade show active" id="income-cat" role="tabpanel">
          <div class="category-list" id="incomeCategoriesList">
            <!-- Categorias serão carregadas dinamicamente -->
          </div>
          
          <div class="add-category-form">
            <div class="custom-icon-input">
              <div class="custom-icon-preview" id="newIncomeCategoryIconPreview">
                <svg width="24" height="24">
                  <use href="#icon-money"></use>
                </svg>
              </div>
              <input type="text" class="form-control" id="newIncomeCategoryIconInput" placeholder="Emoji ou ícone">
            </div>
            <input type="text" class="form-control" id="newIncomeCategoryInput" placeholder="Nova categoria">
            <button class="btn btn-primary" id="addIncomeCategoryBtn">Adicionar</button>
          </div>
        </div>
        
        <!-- Categorias de Despesa -->
        <div class="tab-pane fade" id="expense-cat" role="tabpanel">
          <div class="category-list" id="expenseCategoriesList">
            <!-- Categorias serão carregadas dinamicamente -->
          </div>
          
          <div class="add-category-form">
            <div class="custom-icon-input">
              <div class="custom-icon-preview" id="newExpenseCategoryIconPreview">
                <svg width="24" height="24">
                  <use href="#icon-shopping"></use>
                </svg>
              </div>
              <input type="text" class="form-control" id="newExpenseCategoryIconInput" placeholder="Emoji ou ícone">
            </div>
            <input type="text" class="form-control" id="newExpenseCategoryInput" placeholder="Nova categoria">
            <button class="btn btn-primary" id="addExpenseCategoryBtn">Adicionar</button>
          </div>
        </div>
        
        <!-- Formas de Pagamento -->
        <div class="tab-pane fade" id="payment-methods" role="tabpanel">
          <div class="category-list" id="paymentMethodsList">
            <!-- Formas de pagamento serão carregadas dinamicamente -->
          </div>
          
          <div class="add-category-form">
            <div class="custom-icon-input">
              <div class="custom-icon-preview" id="newPaymentMethodIconPreview">
                <svg width="24" height="24">
                  <use href="#icon-money"></use>
                </svg>
              </div>
              <input type="text" class="form-control" id="newPaymentMethodIconInput" placeholder="Emoji ou ícone">
            </div>
            <input type="text" class="form-control" id="newPaymentMethodInput" placeholder="Nova forma de pagamento">
            <button class="btn btn-primary" id="addPaymentMethodBtn">Adicionar</button>
          </div>
        </div>
        
        <!-- Pessoas -->
        <div class="tab-pane fade" id="people" role="tabpanel">
          <div class="category-list" id="peopleList">
            <!-- Pessoas serão carregadas dinamicamente -->
          </div>
          
          <div class="add-category-form">
            <div class="custom-icon-input">
              <div class="custom-icon-preview" id="newPersonIconPreview">
                <svg width="24" height="24">
                  <use href="#icon-default"></use>
                </svg>
              </div>
              <input type="text" class="form-control" id="newPersonIconInput" placeholder="Emoji ou ícone">
            </div>
            <input type="text" class="form-control" id="newPersonInput" placeholder="Nome da pessoa">
            <button class="btn btn-primary" id="addPersonBtn">Adicionar</button>
          </div>
        </div>
        
        <!-- AJUSTE 2: Aba de Categorias de Investimento -->
        <div class="tab-pane fade" id="investment-cat" role="tabpanel">
          <div class="category-list" id="investmentCategoriesList">
            <!-- Categorias de investimento serão carregadas dinamicamente -->
          </div>
          
          <div class="add-category-form">
            <div class="custom-icon-input">
              <div class="custom-icon-preview" id="newInvestmentCategoryIconPreview">
                <svg width="24" height="24">
                  <use href="#icon-chart"></use>
                </svg>
              </div>
              <input type="text" class="form-control" id="newInvestmentCategoryIconInput" placeholder="Emoji ou ícone">
            </div>
            <input type="text" class="form-control" id="newInvestmentCategoryInput" placeholder="Nova categoria de investimento">
            <button class="btn btn-primary" id="addInvestmentCategoryBtn">Adicionar</button>
          </div>
        </div>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="closeCategoriesBtn">Fechar</button>
    </div>
  </div>
 </div>

 <!-- Modal de Edição de Categoria -->
 <div class="modal-backdrop" id="editCategoryModal">
  <div class="modal" style="max-width: 400px;">
    <div class="modal-header">
      <h2 class="modal-title" id="editCategoryTitle">Editar Categoria</h2>
      <span class="modal-close" id="closeEditCategoryModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <form id="editCategoryForm">
        <input type="hidden" id="editCategoryId">
        <input type="hidden" id="editCategoryType">
        
        <div class="form-group">
          <label class="form-label">Ícone</label>
          <div class="custom-icon-input">
            <div class="custom-icon-preview" id="editCategoryIconPreview">
              <svg width="24" height="24">
                <use href="#icon-default"></use>
              </svg>
            </div>
            <input type="text" class="form-control" id="editCategoryIconInput" placeholder="Emoji ou código unicode">
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label" for="editCategoryName">Nome</label>
          <input type="text" class="form-control" id="editCategoryName" placeholder="Nome da categoria">
        </div>
      </form>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelEditCategoryBtn">Cancelar</button>
      <button class="btn btn-primary" id="saveEditCategoryBtn">Salvar</button>
    </div>
  </div>
 </div>

 <!-- AJUSTE 6: Novas Telas de Investimentos -->
 <!-- Modal Principal de Investimentos -->
 <div class="modal-backdrop" id="investmentsModal">
  <div class="modal" style="max-width: 900px;">
    <div class="modal-header">
      <h2 class="modal-title">Investimentos</h2>
      <span class="modal-close" id="closeInvestmentsModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <div class="investment-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--spacing-lg);">
        <h3>Investimentos</h3>
        <button class="btn btn-primary" id="newInvestmentBtn">
          <svg width="16" height="16">
            <use href="#icon-plus"></use>
          </svg>
          Novo Investimento
        </button>
      </div>
      
      <div class="investment-grid" id="investmentsGrid">
        <!-- Cards de investimentos serão inseridos aqui dinamicamente -->
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="closeInvestmentsBtn">Fechar</button>
    </div>
  </div>
 </div>

 <!-- Modal para Detalhe do Investimento -->
 <div class="modal-backdrop" id="investmentDetailModal">
  <div class="modal" style="max-width: 800px;">
    <div class="modal-header">
      <h2 class="modal-title" id="investmentDetailTitle">
        <button class="btn btn-icon btn-outline" id="backToInvestmentsBtn" style="margin-right: var(--spacing-sm);">
          <svg width="16" height="16">
            <use href="#icon-arrow-left"></use>
          </svg>
        </button>
        <span id="investmentDetailName">Nome do Investimento</span>
      </h2>
      <span class="modal-close" id="closeInvestmentDetailModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <div class="investment-detail">
        <div class="investment-detail-header">
          <div class="investment-detail-stat">
            <div class="investment-detail-title">Guardado</div>
            <div class="investment-detail-value" id="investmentDetailSaved">R$ 0,00</div>
          </div>
          
          <div class="investment-detail-stat">
            <div class="investment-detail-title">Meta</div>
            <div class="investment-detail-value" id="investmentDetailGoal">R$ 0,00</div>
          </div>
          
          <div class="investment-detail-stat">
            <div class="investment-detail-title">Progresso</div>
            <div class="investment-detail-value" id="investmentDetailProgress">0%</div>
          </div>
        </div>
        
        <div class="investment-detail-info" style="margin-bottom: var(--spacing-lg);">
          <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: var(--spacing-md);">
            <div>
              <div class="investment-detail-title">Categoria</div>
              <div id="investmentDetailCategory">Viagem</div>
            </div>
            
            <div>
              <div class="investment-detail-title">Criado em</div>
              <div id="investmentDetailCreatedAt">01/01/2025</div>
            </div>
            
            <div>
              <div class="investment-detail-title">Objetivo</div>
              <div id="investmentDetailTarget">Julho de 2026</div>
            </div>
          </div>
          
          <div style="margin-top: var(--spacing-md);">
            <div class="investment-detail-title">Observação</div>
            <div id="investmentDetailNotes">-</div>
          </div>
        </div>
      </div>
      
      <div class="investment-history">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--spacing-md);">
          <h3 class="investment-history-title">Histórico de Aportes</h3>
          <button class="btn btn-primary" id="addInvestmentContributionBtn">
            <svg width="16" height="16">
              <use href="#icon-plus"></use>
            </svg>
            Adicionar novo valor
          </button>
        </div>
        
        <table class="investment-history-table">
          <thead>
            <tr>
              <th>Data</th>
              <th>Valor</th>
              <th>Descrição</th>
              <th>Ações</th>
            </tr>
          </thead>
          <tbody id="investmentHistoryTableBody">
            <!-- Histórico de aportes será inserido aqui dinamicamente -->
          </tbody>
        </table>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-danger" id="deleteInvestmentBtn">Excluir Investimento</button>
      <button class="btn btn-primary" id="editInvestmentBtn">Editar Investimento</button>
    </div>
  </div>
 </div>

 <!-- Modal de Novo Investimento -->
 <div class="modal-backdrop" id="newInvestmentModal">
  <div class="modal">
    <div class="modal-header">
      <h2 class="modal-title">Novo Investimento</h2>
      <span class="modal-close" id="closeNewInvestmentModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <form id="investmentForm">
        <div class="form-group">
          <label class="form-label" for="investmentName">Nome do objetivo</label>
          <input type="text" class="form-control" id="investmentName" placeholder="Ex: Viagem em Família">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="investmentAmount">Valor inicial</label>
          <input type="number" class="form-control" id="investmentAmount" placeholder="0,00" min="0" step="0.01">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="investmentGoal">Meta final (opcional)</label>
          <input type="number" class="form-control" id="investmentGoal" placeholder="0,00" min="0" step="0.01">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="investmentCategory">Tipo/Categoria</label>
          <div class="select-wrapper">
            <select class="select" id="investmentCategory">
              <option value="viagem">Viagem</option>
              <option value="emergencia">Emergência</option>
              <option value="filho">Filho</option>
              <option value="outro">Outro</option>
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label" for="investmentTargetDate">Data-alvo (opcional)</label>
          <input type="date" class="form-control" id="investmentTargetDate">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="investmentNotes">Observações (opcional)</label>
          <textarea class="form-control" id="investmentNotes" rows="3"></textarea>
        </div>
      </form>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelInvestmentBtn">Cancelar</button>
      <button class="btn btn-primary" id="saveInvestmentBtn">Salvar Investimento</button>
    </div>
  </div>
 </div>

 <!-- Modal para Adicionar Aporte -->
 <div class="modal-backdrop" id="newContributionModal">
  <div class="modal" style="max-width: 400px;">
    <div class="modal-header">
      <h2 class="modal-title">Adicionar Novo Valor</h2>
      <span class="modal-close" id="closeNewContributionModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <form id="contributionForm">
        <input type="hidden" id="contributionInvestmentId">
        
        <div class="form-group">
          <label class="form-label" for="contributionAmount">Valor</label>
          <input type="number" class="form-control" id="contributionAmount" placeholder="0,00" min="0" step="0.01" required>
        </div>
        
        <div class="form-group">
          <label class="form-label" for="contributionDate">Data</label>
          <input type="date" class="form-control" id="contributionDate" required>
        </div>
        
        <div class="form-group">
          <label class="form-label" for="contributionDescription">Descrição</label>
          <input type="text" class="form-control" id="contributionDescription" placeholder="Ex: Depósito mensal">
        </div>
      </form>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelContributionBtn">Cancelar</button>
      <button class="btn btn-primary" id="saveContributionBtn">Adicionar</button>
    </div>
  </div>
 </div>

 <!-- Modal para detalhes de contas vencidas -->
 <div class="modal-backdrop" id="overdueDetailsModal">
  <div class="modal" style="max-width: 700px;">
    <div class="modal-header">
      <h2 class="modal-title">
        <svg width="24" height="24" style="vertical-align: middle; margin-right: 8px;">
          <use href="#icon-alert"></use>
        </svg>
        Contas Vencidas
      </h2>
      <span class="modal-close" id="closeOverdueDetailsModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <table class="transactions-table" id="overdueTransactionsTable">
        <thead>
          <tr>
            <th></th>
            <th>Nome</th>
            <th>Categoria</th>
            <th>Vencimento</th>
            <th>Valor</th>
            <th>Ações</th>
          </tr>
        </thead>
        <tbody id="overdueTransactionsTableBody">
          <!-- Contas vencidas serão inseridas aqui dinamicamente -->
        </tbody>
      </table>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="closeOverdueDetailsBtn">Fechar</button>
      <button class="btn btn-primary" id="payAllOverdueBtn">Pagar Todas</button>
    </div>
  </div>
 </div>

 <!-- Toast Container -->
 <div class="toast-container" id="toastContainer">
  <!-- Toasts serão inseridos aqui dinamicamente -->
 </div>

 <script>
  
  // Helpers DOM
  const $ = selector => document.querySelector(selector);
  const $$ = selector => Array.from(document.querySelectorAll(selector));

  // Estado global da aplicação
  const state = {
    year: 2025,
    month: 4, // Maio (0-indexed)
    transactions: [],
    cards: [],
    filteredTransactions: [],
    insights: [],
    sortColumn: 'date', // Coluna padrão para ordenação
    sortDirection: 'desc', // Direção padrão (decrescente para datas)
    filters: {
      category: '',
      status: '',
      paymentMethod: '',
      person: '', // Filtro por pessoa
      type: 'all' // Filtro por tipo (todos, receitas, despesas) - Problema #8
    },
    categories: {
      income: [
        { id: 'salario', name: 'Salário', icon: '💰' },
        { id: 'investimentos', name: 'Investimentos', icon: '📈' },
        { id: 'freelance', name: 'Freelance', icon: '💻' },
        { id: 'presente', name: 'Presente', icon: '🎁' },
        { id: 'outros_income', name: 'Outros', icon: 'ℹ️' }
      ],
      expense: [
        { id: 'alimentacao', name: 'Alimentação', icon: '🍔' },
        { id: 'moradia', name: 'Moradia', icon: '🏠' },
        { id: 'transporte', name: 'Transporte', icon: '🚗' },
        { id: 'saude', name: 'Saúde', icon: '⚕️' },
        { id: 'educacao', name: 'Educação', icon: '📚' },
        { id: 'lazer', name: 'Lazer', icon: '🎮' },
        { id: 'compras', name: 'Compras', icon: '🛍️' },
        { id: 'contas', name: 'Contas e serviços', icon: '📝' },
        { id: 'impostos', name: 'Impostos', icon: '💸' },
        { id: 'outros_expense', name: 'Outros', icon: 'ℹ️' }
      ],
      investment: [ // Categorias de investimento
        { id: 'viagem', name: 'Viagem', icon: '✈️' },
        { id: 'emergencia', name: 'Emergência', icon: '🚨' },
        { id: 'filho', name: 'Filho', icon: '👶' },
        { id: 'tesouro', name: 'Tesouro Direto', icon: '🏛️' },
        { id: 'acoes', name: 'Ações', icon: '📊' },
        { id: 'outro', name: 'Outro', icon: '💰' }
      ]
    },
    paymentMethods: [
      { id: 'dinheiro', name: 'Dinheiro', icon: '💵' },
      { id: 'pix', name: 'Pix', icon: '⚡' },
      { id: 'debito', name: 'Débito', icon: '💳' },
      { id: 'debito_conta', name: 'Débito em Conta', icon: '🏦' },
      { id: 'transferencia', name: 'Transferência Bancária', icon: '🔄' },
      { id: 'boleto', name: 'Boleto', icon: '📄' },
      { id: 'credito', name: 'Crédito', icon: '💳' }
    ],
    people: [ // Lista de pessoas
      { id: 'familia', name: 'Família', icon: '👨‍👩‍👧‍👦' },
      { id: 'eu', name: 'Eu', icon: '👤' },
      { id: 'conjuge', name: 'Cônjuge', icon: '💑' },
      { id: 'filhos', name: 'Filhos', icon: '👶' }
    ],
    investments: [], // Array para investimentos
    investmentContributions: [], // Array para contribuições de investimentos
    currentTransaction: null,
    currentCard: null,
    currentCategory: null,
    currentInvestment: null,
    currentContribution: null,
    themePreference: 'light'
  };

  // Formatadores
  const formatCurrency = value => {
    return new Intl.NumberFormat('pt-BR', {
      style: 'currency',
      currency: 'BRL'
    }).format(value);
  };

  // Função auxiliar para parsing de datas locais
  const parseLocalDateString = (dateInput) => {
    if (dateInput instanceof Date && !isNaN(dateInput)) {
      return dateInput;
    }
    if (typeof dateInput === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(dateInput)) {
      const parts = dateInput.split('-');
      return new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
    }
    return null;
  };

  const formatDate = (date, options = {}) => {
    let dateObj;
    if (!date) return '';
    
    if (typeof date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
      dateObj = parseLocalDateString(date);
    } else {
      dateObj = date instanceof Date ? date : new Date(date);
    }
    
    return dateObj.toLocaleDateString('pt-BR', options);
  };

  // Função para manipular datas sem problemas de fuso horário
  const localDateToISOString = (date) => {
    if (!date) return null;
    const localDate = date instanceof Date ? date : new Date(date);
    // Criar uma string de data no formato ISO, mas mantendo a data local
    return localDate.getFullYear() + '-' + 
           String(localDate.getMonth() + 1).padStart(2, '0') + '-' + 
           String(localDate.getDate()).padStart(2, '0');
  };

  // Função para atualizar cores do tema para os gráficos
  const updateChartColors = () => {
    const isDarkTheme = document.documentElement.getAttribute('data-theme') === 'dark';
    const textColor = isDarkTheme ? 'rgba(245, 245, 247, 1)' : 'rgba(29, 29, 31, 1)';
    const gridColor = isDarkTheme ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
    
    // AJUSTE 22: Usar paleta de cores da Apple
    const appleColors = [
      '#007AFF', // azul
      '#34C759', // verde
      '#FF9500', // laranja
      '#FF3B30', // vermelho
      '#AF52DE', // roxo
      '#5E5CE6', // azul índigo
      '#FF2D55', // rosa
      '#FF9F0A', // amarelo
      '#64D2FF', // azul claro
      '#30B0C7'  // azul esverdeado
    ];
    
    // Atualizar cores padrão do Chart.js
    Chart.defaults.color = textColor;
    Chart.defaults.borderColor = gridColor;
    
    // Atualizar definições de tooltips
    Chart.defaults.plugins.tooltip.backgroundColor = isDarkTheme ? 'rgba(28, 28, 30, 0.95)' : 'rgba(255, 255, 255, 0.95)';
    Chart.defaults.plugins.tooltip.titleColor = textColor;
    Chart.defaults.plugins.tooltip.bodyColor = textColor;
    Chart.defaults.plugins.tooltip.borderColor = isDarkTheme ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
    Chart.defaults.plugins.tooltip.borderWidth = 1;
    
    // Atualizar cada gráfico individualmente
    if (pieChart) {
      pieChart.options.plugins.legend.labels.color = textColor;
      pieChart.options.plugins.tooltip.titleColor = textColor;
      pieChart.options.plugins.tooltip.bodyColor = textColor;
      pieChart.data.datasets[0].borderColor = isDarkTheme ? '#000000' : '#ffffff';
      pieChart.data.datasets[0].backgroundColor = appleColors;
      pieChart.update();
    }
    
    if (barChart) {
      barChart.options.scales.x.ticks.color = textColor;
      barChart.options.scales.x.grid.color = gridColor;
      barChart.options.scales.y.ticks.color = textColor;
      barChart.options.scales.y.grid.color = gridColor;
      barChart.options.plugins.legend.labels.color = textColor;
      barChart.options.plugins.tooltip.titleColor = textColor;
      barChart.options.plugins.tooltip.bodyColor = textColor;
      barChart.data.datasets[0].backgroundColor = appleColors[1]; // verde
      barChart.data.datasets[1].backgroundColor = appleColors[3]; // vermelho
      barChart.update();
    }
    
    if (areaChart) {
      areaChart.options.scales.x.ticks.color = textColor;
      areaChart.options.scales.x.grid.color = gridColor;
      areaChart.options.scales.y.ticks.color = textColor;
      areaChart.options.scales.y.grid.color = gridColor;
      areaChart.options.plugins.legend.labels.color = textColor;
      areaChart.options.plugins.tooltip.titleColor = textColor;
      areaChart.options.plugins.tooltip.bodyColor = textColor;
      areaChart.data.datasets[0].backgroundColor = 'rgba(255, 59, 48, 0.2)';
      areaChart.data.datasets[0].borderColor = appleColors[3];
      areaChart.data.datasets[1].borderColor = appleColors[0];
      areaChart.data.datasets[2].borderColor = appleColors[1];
      areaChart.update();
    }
    
    // AJUSTE 17: Atualizar gráfico de despesas fixas vs variáveis
    if (fixedVsVariableChart) {
      fixedVsVariableChart.options.plugins.legend.labels.color = textColor;
      fixedVsVariableChart.options.plugins.tooltip.titleColor = textColor;
      fixedVsVariableChart.options.plugins.tooltip.bodyColor = textColor;
      fixedVsVariableChart.data.datasets[0].backgroundColor = [appleColors[0], appleColors[2]];
      fixedVsVariableChart.data.datasets[0].borderColor = isDarkTheme ? '#000000' : '#ffffff';
      fixedVsVariableChart.update();
    }
    
    // AJUSTE 20: Atualizar gráfico de despesas por pessoa
    if (personAnalysisChart) {
      personAnalysisChart.options.plugins.legend.labels.color = textColor;
      personAnalysisChart.options.plugins.tooltip.titleColor = textColor;
      personAnalysisChart.options.plugins.tooltip.bodyColor = textColor;
      personAnalysisChart.data.datasets[0].backgroundColor = appleColors;
      personAnalysisChart.data.datasets[0].borderColor = isDarkTheme ? '#000000' : '#ffffff';
      personAnalysisChart.update();
    }
  };

  // Função de tema claro/escuro
  const toggleTheme = () => {
    const currentTheme = document.documentElement.getAttribute('data-theme');
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    
    document.documentElement.setAttribute('data-theme', newTheme);
    state.themePreference = newTheme;
    
    // Armazenar preferência em localStorage
    localStorage.setItem('themePreference', newTheme);
    
    // Atualizar cores de gráficos quando o tema é alterado
    updateChartColors();
  };

  // Verificar a preferência de tema do usuário
  const initTheme = () => {
    const savedTheme = localStorage.getItem('themePreference');
    if (savedTheme) {
      document.documentElement.setAttribute('data-theme', savedTheme);
      state.themePreference = savedTheme;
    } else {
      // Verificar preferência do sistema
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.setAttribute('data-theme', 'dark');
        state.themePreference = 'dark';
      }
    }
    
    // Listener para o botão de alternar tema
    $('#themeToggle').addEventListener('click', toggleTheme);
  };

  // Configuração do Firebase
  const firebaseConfig = {
    apiKey: "AIzaSyDvL_nYWhv_8rPouejiWbDZtDCKHYOQyEY",
    authDomain: "calculadora-da-familia.firebaseapp.com",
    projectId: "calculadora-da-familia",
    storageBucket: "calculadora-da-familia.appspot.com",
    messagingSenderId: "69721783786",
    appId: "1:69721783786:web:c4703b5c182e3681e8c693",
    measurementId: "G-YM5TR661S6"
  };

  // Inicializar Firebase com tratamento de erro
  let db;
  try {
    firebase.initializeApp(firebaseConfig);
    db = firebase.firestore();
    
    // Configurar persistência offline para melhor experiência do usuário
    db.enablePersistence({experimentalForceOwningTab: true})
      .catch(err => {
        if (err.code === 'failed-precondition') {
          console.warn('Múltiplas abas abertas, persistência não suportada. Usando apenas modo online.');
          // Continuar sem persistência
        } else if (err.code === 'unimplemented') {
          console.warn('O navegador não suporta persistência offline. Usando apenas modo online.');
          // Continuar sem persistência
        }
      });
      
    console.log('Firebase inicializado com sucesso');
  } catch (error) {
    console.error('Erro ao inicializar Firebase:', error);
    showToast('Erro de conexão com o Firebase. Tente recarregar a página.', 'error');
    // Inicializar um banco de dados falso para evitar erros
    db = {
      collection: () => ({
        get: () => Promise.resolve({ docs: [], empty: true }),
        doc: () => ({ 
          get: () => Promise.resolve({ exists: false, data: () => ({}) }),
          set: () => Promise.resolve(),
          update: () => Promise.resolve(),
          delete: () => Promise.resolve()
        }),
        add: () => Promise.resolve({ id: 'temp-id' })
      })
    };
  }

  // IDs únicos
  const generateId = () => {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  };

  // Toast notifications
  const showToast = (message, type = 'success') => {
    const toastContainer = $('#toastContainer');
    if (!toastContainer) return; // Safety check
    
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    
    let iconName = '';
    switch (type) {
      case 'success':
        iconName = 'icon-check';
        break;
      case 'error':
        iconName = 'icon-x';
        break;
      case 'warning':
        iconName = 'icon-alert';
        break;
      case 'info':
        iconName = 'icon-info';
        break;
    }
    
    toast.innerHTML = `
      <div class="toast-icon">
        <svg width="24" height="24">
          <use href="#${iconName}"></use>
        </svg>
      </div>
      <div class="toast-content">${message}</div>
      <span class="toast-close">
        <svg width="16" height="16">
          <use href="#icon-x"></use>
        </svg>
      </span>
    `;
    
    toastContainer.appendChild(toast);
    
    // Animação
    setTimeout(() => {
      toast.classList.add('show');
    }, 10);
    
    // Fechar toast ao clicar no X
    toast.querySelector('.toast-close').addEventListener('click', () => {
      toast.classList.remove('show');
      setTimeout(() => {
        if (toast.parentNode) {
          toast.remove();
        }
      }, 300);
    });
    
    // Auto fechar após 5 segundos
    setTimeout(() => {
      if (toast.parentNode) {
        toast.classList.remove('show');
        setTimeout(() => {
          if (toast.parentNode) {
            toast.remove();
          }
        }, 300);
      }
    }, 5000);
  };

  // Funções para manipulação de modais
  const openModal = modalId => {
    const modal = $(`#${modalId}`);
    if (!modal) return; // Safety check
    
    modal.classList.add('active');
    document.body.style.overflow = 'hidden';
  };

  const closeModal = modalId => {
    const modal = $(`#${modalId}`);
    if (!modal) return; // Safety check
    
    modal.classList.remove('active');
    document.body.style.overflow = '';
  };

  const closeAllModals = () => {
    $$('.modal-backdrop').forEach(modal => {
      modal.classList.remove('active');
    });
    document.body.style.overflow = '';
  };

  // Manipulação de date inputs
  const setDateInputValue = (inputId, date) => {
    const input = $(`#${inputId}`);
    if (!input) return; // Safety check

    // Garantir que estamos trabalhando com um objeto Date ou string ISO
    let dateObj;
    if (date instanceof Date) {
      dateObj = date;
    } else if (typeof date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
      dateObj = parseLocalDateString(date);
    } else {
      return; // Não suportado
    }

    // Formato YYYY-MM-DD para inputs de data
    const year = dateObj.getFullYear();
    const month = String(dateObj.getMonth() + 1).padStart(2, '0');
    const day = String(dateObj.getDate()).padStart(2, '0');

    input.value = `${year}-${month}-${day}`;
  };

  const getDateInputValue = inputId => {
    const input = $(`#${inputId}`);
    if (!input || !input.value) return null;

    // Converter o valor do input diretamente para Date
    // O input type="date" retorna YYYY-MM-DD
    return parseLocalDateString(input.value);
  };

  // Função para atualizar as opções de anos até 2030
  const updateYearOptions = () => {
    const yearSelect = $('#yearSelect');
    
    if (yearSelect) {
      yearSelect.innerHTML = '';
      
      for (let year = 2023; year <= 2030; year++) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        option.selected = year === state.year;
        yearSelect.appendChild(option);
      }
    }
  };

  // Função para calcular o melhor dia para compras
  const calcularMelhorDiaCompras = (cartao) => {
    if (!cartao || !cartao.closingDay) return null;
    
    // O melhor dia é sempre o dia seguinte ao fechamento
    let melhorDia = cartao.closingDay + 1;
    
    // Se o fechamento for no dia 31, o melhor dia é o dia 1
    if (melhorDia > 31) {
      melhorDia = 1;
    }
    
    return melhorDia;
  };

  // Função para calcular data de vencimento automático para cartões
  // Problema #1: Corrigir o preenchimento automático do vencimento no Cartão de Crédito
  const calcularVencimentoReal = (dataCompra, cartao) => {
    // Garantir que temos um objeto Date
    const compra = dataCompra instanceof Date ? dataCompra : parseLocalDateString(dataCompra);
    if (!compra || !cartao) return null;
    
    // Calcular data de fechamento para o mês da compra
    const dataFechamento = new Date(
      compra.getFullYear(),
      compra.getMonth(),
      cartao.closingDay
    );
    
    // Se comprou APÓS o fechamento, pula para o próximo mês
    if (compra.getDate() > cartao.closingDay) {
      dataFechamento.setMonth(dataFechamento.getMonth() + 1);
    }
    
    // Calcular data de vencimento
    const dataVencimento = new Date(
      dataFechamento.getFullYear(),
      dataFechamento.getMonth(),
      cartao.dueDay
    );
    
    // Avançar para o mês seguinte se o dia de vencimento for menor que o de fechamento
    if (cartao.dueDay < cartao.closingDay) {
      dataVencimento.setMonth(dataVencimento.getMonth() + 1);
    }
    
    return dataVencimento;
  };

  // Função para calcular o mês de exibição de acordo com a regra de fechamento
  const calcularMesExibicao = (dataCompra, cartao) => {
    // Determinar o mês em que a fatura será paga (mês de exibição)
    const compra = dataCompra instanceof Date ? dataCompra : parseLocalDateString(dataCompra);
    if (!compra || !cartao) return compra.getMonth();
    
    // Data de vencimento
    const vencimento = calcularVencimentoReal(compra, cartao);
    if (!vencimento) return compra.getMonth();
    
    // Retornar o mês da data de vencimento
    return vencimento.getMonth();
  };

  // Função para carregar categorias, métodos de pagamento e pessoas
  const loadCategoriesAndPaymentMethods = async () => {
    try {
      // Carregar categorias
      const categoriesSnapshot = await db.collection('categories').get();
      
      if (!categoriesSnapshot.empty) {
        // Limpar categorias padrão
        state.categories.income = [];
        state.categories.expense = [];
        state.categories.investment = []; // Limpar categorias de investimento
        
        categoriesSnapshot.docs.forEach(doc => {
          const category = { id: doc.id, ...doc.data() };
          // Problema #9: Corrigir nomes de categorias distorcidos
          // Remover sufixos estranhos do nome da categoria
          if (category.name && category.name.includes('_')) {
            category.name = category.name.split('_')[0];
          }
          
          if (category.type === 'income') {
            state.categories.income.push(category);
          } else if (category.type === 'expense') {
            state.categories.expense.push(category);
          } else if (category.type === 'investment') {
            state.categories.investment.push(category);
          }
        });
      } else {
        // Se não houver categorias salvas, salvar as categorias padrão
        const batch = db.batch();
        
        // Salvar categorias de receita
        state.categories.income.forEach(category => {
          const docRef = db.collection('categories').doc(category.id);
          batch.set(docRef, { ...category, type: 'income' });
        });
        
        // Salvar categorias de despesa
        state.categories.expense.forEach(category => {
          const docRef = db.collection('categories').doc(category.id);
          batch.set(docRef, { ...category, type: 'expense' });
        });
        
        // Salvar categorias de investimento
        state.categories.investment.forEach(category => {
          const docRef = db.collection('categories').doc(category.id);
          batch.set(docRef, { ...category, type: 'investment' });
        });
        
        await batch.commit();
      }
      
      // Carregar métodos de pagamento
      const paymentMethodsSnapshot = await db.collection('paymentMethods').get();
      
      if (!paymentMethodsSnapshot.empty) {
        state.paymentMethods = [];
        paymentMethodsSnapshot.docs.forEach(doc => {
          state.paymentMethods.push({ id: doc.id, ...doc.data() });
        });
      } else {
        // Se não houver métodos de pagamento salvos, salvar os padrão
        const batch = db.batch();
        
        state.paymentMethods.forEach(method => {
          const docRef = db.collection('paymentMethods').doc(method.id);
          batch.set(docRef, method);
        });
        
        await batch.commit();
      }
      
      // Carregar pessoas
      const peopleSnapshot = await db.collection('people').get();
      
      if (!peopleSnapshot.empty) {
        state.people = [];
        peopleSnapshot.docs.forEach(doc => {
          state.people.push({ id: doc.id, ...doc.data() });
        });
      } else {
        // Se não houver pessoas salvas, salvar as padrão
        const batch = db.batch();
        
        state.people.forEach(person => {
          const docRef = db.collection('people').doc(person.id);
          batch.set(docRef, person);
        });
        
        await batch.commit();
      }
      
      updateCategorySelects();
      updatePaymentMethodSelects();
      updatePeopleSelects();
      
      // AJUSTE 9: Corrigir bug de categorias - carregar todas imediatamente
      renderCategoriesList();
      renderPaymentMethodsList();
      renderInvestmentCategoriesList();
      updatePeopleList();
      
    } catch (error) {
      console.error('Erro ao carregar categorias e métodos de pagamento:', error);
      showToast('Erro ao carregar categorias. Tente novamente.', 'error');
    }
  };

  // Atualizar selects de categorias
  const updateCategorySelects = () => {
    // Selects de categorias de receita
    const incomeSelects = [
      $('#incomeCategory'),
      $('#editCategory')
    ];
    
    incomeSelects.forEach(select => {
      if (select && select.id === 'editCategory' && select.dataset.type === 'expense') {
        return; // Pular se for select de edição para despesa
      }
      
      if (select) {
        select.innerHTML = '';
        
        state.categories.income.forEach(category => {
          const option = document.createElement('option');
          option.value = category.id;
          option.textContent = `${category.icon || ''} ${category.name}`;
          select.appendChild(option);
        });
      }
    });
    
    // Selects de categorias de despesa
    const expenseSelects = [
      $('#expenseCategory'),
      $('#editCategory')
    ];
    
    expenseSelects.forEach(select => {
      if (select && select.id === 'editCategory' && select.dataset.type === 'income') {
        return; // Pular se for select de edição para receita
      }
      
      if (select) {
        select.innerHTML = '';
        
        state.categories.expense.forEach(category => {
          const option = document.createElement('option');
          option.value = category.id;
          option.textContent = `${category.icon || ''} ${category.name}`;
          select.appendChild(option);
        });
      }
    });
    
    // Selects de categorias de investimento
    const investmentSelects = [
      $('#investmentCategory')
    ];
    
    investmentSelects.forEach(select => {
      if (select) {
        select.innerHTML = '';
        
        state.categories.investment.forEach(category => {
          const option = document.createElement('option');
          option.value = category.id;
          option.textContent = `${category.icon || ''} ${category.name}`;
          select.appendChild(option);
        });
      }
    });
  };

  // Atualizar selects de formas de pagamento
  const updatePaymentMethodSelects = () => {
    const paymentMethodSelects = [
      $('#incomePaymentMethod'),
      $('#expensePaymentMethod'),
      $('#editPaymentMethod')
    ];
    
    paymentMethodSelects.forEach(select => {
      if (select) {
        select.innerHTML = '';
        
        state.paymentMethods.forEach(method => {
          const option = document.createElement('option');
          option.value = method.id;
          option.textContent = `${method.icon || ''} ${method.name}`;
          select.appendChild(option);
        });
      }
    });
  };

  // Atualizar selects de pessoas
  const updatePeopleSelects = () => {
    const peopleSelects = [
      $('#expensePerson'),
      $('#editPerson')
    ];
    
    peopleSelects.forEach(select => {
      if (select) {
        select.innerHTML = '';
        
        // Adicionar opção padrão
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'Selecione...';
        select.appendChild(defaultOption);
        
        state.people.forEach(person => {
          const option = document.createElement('option');
          option.value = person.id;
          option.textContent = `${person.icon || ''} ${person.name}`;
          select.appendChild(option);
        });
      }
    });
  };

  // Função para carregar cartões
  const loadCards = async () => {
    try {
      const snapshot = await db.collection('cards').get();
      
      state.cards = [];
      
      if (!snapshot.empty) {
        snapshot.docs.forEach(doc => {
          const card = { id: doc.id, ...doc.data() };
          // Calcular limite disponível
          if (!card.availableLimit) {
            card.availableLimit = card.limit;
          }
          // Inicializar fatura atual se não existir
          if (!card.currentInvoice) {
            card.currentInvoice = 0;
          }
          state.cards.push(card);
        });
      }
      
      // Atualizar UI
      updateCardsList();
      updateCreditCardSelects();
      updateKPIs();
      
    } catch (error) {
      console.error('Erro ao carregar cartões:', error);
      showToast('Erro ao carregar cartões. Tente novamente.', 'error');
    }
  };

  // Função para adicionar cartão
  const addCard = async (cardData) => {
    try {
      // Criar objeto do cartão
      const card = {
        ...cardData,
        availableLimit: cardData.limit,
        currentInvoice: 0,
        createdAt: new Date().toISOString()
      };
      
      // Salvar no Firestore
      const docRef = await db.collection('cards').add(card);
      
      // Atualizar o ID
      card.id = docRef.id;
      
      // Adicionar ao estado local
      state.cards.push(card);
      
      // Atualizar UI
      updateCardsList();
      updateCreditCardSelects();
      
      showToast('Cartão adicionado com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao adicionar cartão:', error);
      showToast('Erro ao adicionar cartão. Tente novamente.', 'error');
    }
  };

  // Função para atualizar cartão
  const updateCard = async (cardId, updates) => {
    try {
      // Atualizar no Firestore
      await db.collection('cards').doc(cardId).update(updates);
      
      // Atualizar no estado local
      const index = state.cards.findIndex(c => c.id === cardId);
      
      if (index !== -1) {
        state.cards[index] = { ...state.cards[index], ...updates };
      }
      
      // Atualizar UI
      updateCardsList();
      updateCreditCardSelects();
      
      showToast('Cartão atualizado com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao atualizar cartão:', error);
      showToast('Erro ao atualizar cartão. Tente novamente.', 'error');
    }
  };

  // Função para excluir cartão
  const deleteCard = async (cardId) => {
    try {
      // Verificar se há transações vinculadas
      const transactionsWithCard = state.transactions.filter(t => 
        t.type === 'expense' && 
        t.paymentMethod === 'credito' && 
        t.creditCardId === cardId
      );
      
      if (transactionsWithCard.length > 0) {
        if (!confirm(`Este cartão possui ${transactionsWithCard.length} transações vinculadas. Deseja excluir mesmo assim?`)) {
          return;
        }
        
        // Atualizar as transações para remover a referência ao cartão
        const batch = db.batch();
        
        transactionsWithCard.forEach(transaction => {
          const docRef = db.collection('transactions').doc(transaction.id);
          batch.update(docRef, { 
            paymentMethod: 'outros',
            creditCardId: null,
            creditCardName: null
          });
          
          // Atualizar no estado local
          const index = state.transactions.findIndex(t => t.id === transaction.id);
          if (index !== -1) {
            state.transactions[index].paymentMethod = 'outros';
            state.transactions[index].creditCardId = null;
            state.transactions[index].creditCardName = null;
          }
        });
        
        await batch.commit();
      }
      
      // Excluir o cartão
      await db.collection('cards').doc(cardId).delete();
      
      // Remover do estado local
      state.cards = state.cards.filter(c => c.id !== cardId);
      
      // Atualizar UI
      updateCardsList();
      updateCreditCardSelects();
      filterTransactionsByMonth();
      updateKPIs();
      
      showToast('Cartão excluído com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao excluir cartão:', error);
      showToast('Erro ao excluir cartão. Tente novamente.', 'error');
    }
  };

  // Função para pagar fatura do cartão
  const payCardInvoice = async (cardId) => {
    try {
      const card = state.cards.find(c => c.id === cardId);
      
      if (!card) {
        showToast('Cartão não encontrado.', 'error');
        return;
      }
      
      // Encontrar todas as transações da fatura atual
      const today = new Date();
      let closingDate = new Date(today.getFullYear(), today.getMonth(), card.closingDay);
      
      // Se hoje é após o dia de fechamento, a data de fechamento será no próximo mês
      if (today.getDate() > card.closingDay) {
        closingDate.setMonth(closingDate.getMonth() + 1);
      }

      // Data de fechamento anterior
      const previousClosing = new Date(closingDate);
      previousClosing.setMonth(previousClosing.getMonth() - 1);
      
      // Buscar transações do período
      const invoiceTransactions = state.transactions.filter(t => 
        t.type === 'expense' && 
        t.paymentMethod === 'credito' && 
        t.creditCardId === card.id &&
        parseLocalDateString(t.date) >= previousClosing &&
        parseLocalDateString(t.date) < closingDate
      );
      
      if (invoiceTransactions.length === 0) {
        showToast('Não há despesas pendentes para esta fatura.', 'info');
        closeModal('payInvoiceConfirmModal');
        return;
      }
      
      // Marcar todas as transações como pagas
      const batch = db.batch();
      
      invoiceTransactions.forEach(transaction => {
        const docRef = db.collection('transactions').doc(transaction.id);
        batch.update(docRef, { status: 'paid' });
        
        // Atualizar no estado local
        const index = state.transactions.findIndex(t => t.id === transaction.id);
        if (index !== -1) {
          state.transactions[index].status = 'paid';
        }
      });
      
      // Resetar a fatura atual do cartão
      const cardRef = db.collection('cards').doc(cardId);
      batch.update(cardRef, { 
        currentInvoice: 0,
        availableLimit: card.limit // Restaurar o limite disponível
      });
      
      // Atualizar no estado local
      const cardIndex = state.cards.findIndex(c => c.id === cardId);
      if (cardIndex !== -1) {
        state.cards[cardIndex].currentInvoice = 0;
        state.cards[cardIndex].availableLimit = card.limit;
      }
      
      await batch.commit();
      
      // Atualizar UI
      updateCardsList();
      updateTransactionsTable();
      updateKPIs();
      updateCharts();
      
      closeModal('payInvoiceConfirmModal');
      showToast('Fatura paga com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao pagar fatura:', error);
      showToast('Erro ao pagar fatura. Tente novamente.', 'error');
    }
  };

  // Função para atualizar os selects de cartões de crédito
  // Problema #4: Exibir o Limite Disponível ao lançar despesa no cartão
  const updateCreditCardSelects = () => {
    const cardSelects = [
      $('#expenseCreditCard'),
      $('#editCreditCard')
    ];
    
    cardSelects.forEach(select => {
      if (select) {
        select.innerHTML = '';
        
        if (state.cards.length === 0) {
          // Adicionar opção de placeholder se não houver cartões
          const option = document.createElement('option');
          option.value = '';
          option.textContent = 'Nenhum cartão cadastrado';
          option.disabled = true;
          option.selected = true;
          select.appendChild(option);
        } else {
          state.cards.forEach(card => {
            const option = document.createElement('option');
            option.value = card.id;
            // Problema #4: Exibir o Limite Disponível ao lançar despesa no cartão
            option.textContent = `${card.name} (Disp: ${formatCurrency(card.availableLimit)})`;
            select.appendChild(option);
          });
        }
      }
    });
  };

  // AJUSTE 6: Funções para investimentos 
  const loadInvestments = async () => {
    try {
      // Carregar investimentos
      const investmentsSnapshot = await db.collection('investments').get();
      
      state.investments = [];
      
      if (!investmentsSnapshot.empty) {
        investmentsSnapshot.docs.forEach(doc => {
          const investment = { id: doc.id, ...doc.data() };
          state.investments.push(investment);
        });
      }
      
      // Carregar contribuições
      const contributionsSnapshot = await db.collection('investmentContributions').get();
      
      state.investmentContributions = [];
      
      if (!contributionsSnapshot.empty) {
        contributionsSnapshot.docs.forEach(doc => {
          const contribution = { id: doc.id, ...doc.data() };
          state.investmentContributions.push(contribution);
        });
      }
      
      // Renderizar cards de investimentos
      renderInvestmentCards();
      
    } catch (error) {
      console.error('Erro ao carregar investimentos:', error);
      showToast('Erro ao carregar investimentos. Tente novamente.', 'error');
    }
  };

  const renderInvestmentCards = () => {
    const grid = $('#investmentsGrid');
    if (!grid) return;
    
    grid.innerHTML = '';
    
    if (state.investments.length === 0) {
      grid.innerHTML = '<p style="text-align: center; padding: var(--spacing-xl);">Nenhum investimento cadastrado. Clique em "Novo Investimento" para começar.</p>';
      return;
    }
    
    state.investments.forEach(investment => {
      // Calcular valor total das contribuições
      const contributions = state.investmentContributions.filter(c => c.investmentId === investment.id);
      const totalContributed = contributions.reduce((sum, c) => sum + parseFloat(c.amount), 0) + parseFloat(investment.amount || 0);
      
      // Calcular progresso
      const hasGoal = investment.goal && parseFloat(investment.goal) > 0;
      const progress = hasGoal ? (totalContributed / parseFloat(investment.goal)) * 100 : 0;
      
      // Buscar categoria
      const category = state.categories.investment.find(c => c.id === investment.category);
      
      const card = document.createElement('div');
      card.className = 'investment-card';
      card.dataset.id = investment.id;
      
      card.innerHTML = `
        <div class="investment-card-header">
          <h3 class="investment-card-title">${investment.name}</h3>
          <div class="category-badge" style="background-color: var(--color-surface-variant); padding: var(--spacing-2xs) var(--spacing-xs); border-radius: var(--radius-full); font-size: var(--font-size-xs);">
            ${category ? `${category.icon} ${category.name}` : 'Categoria'}
          </div>
        </div>
        
        <div class="investment-card-body">
          <div style="margin-bottom: var(--spacing-xs);">
            <div>Guardado: <strong>${formatCurrency(totalContributed)}</strong></div>
            ${hasGoal ? `<div>Meta: <strong>${formatCurrency(investment.goal)}</strong></div>` : ''}
          </div>
          
          ${hasGoal ? `
          <div class="investment-progress">
            <div class="investment-progress-bar">
              <div class="investment-progress-fill" style="width: ${progress}%;"></div>
            </div>
            <div class="investment-progress-text">
              <span>Progresso: ${progress.toFixed(0)}%</span>
              ${investment.targetDate ? `<span>Até: ${formatDate(investment.targetDate)}</span>` : ''}
            </div>
          </div>
          ` : ''}
        </div>
        
        <div class="investment-card-footer">
          <div style="color: var(--color-on-surface-variant); font-size: var(--font-size-xs);">
            Criado em: ${formatDate(investment.createdAt || new Date())}
          </div>
          <div>
            <button class="btn btn-icon btn-outline edit-investment-btn">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-investment-btn">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        </div>
      `;
      
      grid.appendChild(card);
    });
    
    // Adicionar event listeners
    $$('.investment-card').forEach(card => {
      card.addEventListener('click', (e) => {
        // Ignorar cliques nos botões de edição e exclusão
        if (e.target.closest('.edit-investment-btn') || e.target.closest('.delete-investment-btn')) {
          return;
        }
        
        const id = card.dataset.id;
        openInvestmentDetail(id);
      });
    });
    
    $$('.edit-investment-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const card = e.target.closest('.investment-card');
        const id = card.dataset.id;
        openEditInvestmentModal(id);
      });
    });
    
    $$('.delete-investment-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const card = e.target.closest('.investment-card');
        const id = card.dataset.id;
        if (confirm('Deseja realmente excluir este investimento? Esta ação é irreversível.')) {
          deleteInvestment(id);
        }
      });
    });
  };

  const openInvestmentDetail = (investmentId) => {
    const investment = state.investments.find(i => i.id === investmentId);
    if (!investment) return;
    
    state.currentInvestment = investment;
    
    // Buscar categoria
    const category = state.categories.investment.find(c => c.id === investment.category);
    
    // Calcular valor total das contribuições
    const contributions = state.investmentContributions.filter(c => c.investmentId === investment.id);
    const totalContributed = contributions.reduce((sum, c) => sum + parseFloat(c.amount), 0) + parseFloat(investment.amount || 0);
    
    // Calcular progresso
    const hasGoal = investment.goal && parseFloat(investment.goal) > 0;
    const progress = hasGoal ? (totalContributed / parseFloat(investment.goal)) * 100 : 0;
    
    // Preencher detalhes do investimento
    $('#investmentDetailName').textContent = investment.name;
    $('#investmentDetailSaved').textContent = formatCurrency(totalContributed);
    $('#investmentDetailGoal').textContent = hasGoal ? formatCurrency(investment.goal) : 'Não definido';
    $('#investmentDetailProgress').textContent = hasGoal ? `${progress.toFixed(0)}%` : 'N/A';
    $('#investmentDetailCategory').textContent = category ? `${category.icon} ${category.name}` : 'Não definido';
    $('#investmentDetailCreatedAt').textContent = formatDate(investment.createdAt || new Date());
    $('#investmentDetailTarget').textContent = investment.targetDate ? formatDate(investment.targetDate) : 'Não definido';
    $('#investmentDetailNotes').textContent = investment.notes || 'Sem observações';
    
    // Renderizar histórico de aportes
    renderInvestmentContributions(investmentId);
    
    // Fechar modal principal de investimentos
    closeModal('investmentsModal');
    
    // Abrir modal de detalhes
    openModal('investmentDetailModal');
  };

  const renderInvestmentContributions = (investmentId) => {
    const tableBody = $('#investmentHistoryTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    // Buscar contribuições
    const contributions = state.investmentContributions.filter(c => c.investmentId === investmentId);
    
    // Adicionar valor inicial como primeira "contribuição"
    const investment = state.investments.find(i => i.id === investmentId);
    if (investment && parseFloat(investment.amount) > 0) {
      const initialRow = document.createElement('tr');
      initialRow.innerHTML = `
        <td>${formatDate(investment.createdAt || new Date())}</td>
        <td>${formatCurrency(investment.amount)}</td>
        <td>Depósito inicial</td>
        <td>-</td>
      `;
      tableBody.appendChild(initialRow);
    }
    
    // Ordenar contribuições por data (mais recentes primeiro)
    contributions.sort((a, b) => {
      const dateA = parseLocalDateString(a.date);
      const dateB = parseLocalDateString(b.date);
      return dateB - dateA;
    });
    
    if (contributions.length === 0 && (!investment || parseFloat(investment.amount) <= 0)) {
      tableBody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: var(--spacing-md);">Nenhum aporte realizado.</td></tr>';
      return;
    }
    
    contributions.forEach(contribution => {
      const row = document.createElement('tr');
      row.dataset.id = contribution.id;
      
      row.innerHTML = `
        <td>${formatDate(contribution.date)}</td>
        <td>${formatCurrency(contribution.amount)}</td>
        <td>${contribution.description || '-'}</td>
        <td>
          <div class="actions-cell">
            <button class="btn btn-icon btn-outline edit-contribution-btn">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-contribution-btn">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        </td>
      `;
      
      tableBody.appendChild(row);
    });
    
    // Adicionar event listeners
    $$('.edit-contribution-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const row = e.target.closest('tr');
        const id = row.dataset.id;
        const contribution = state.investmentContributions.find(c => c.id === id);
        if (contribution) {
          openEditContributionModal(contribution);
        }
      });
    });
    
    $$('.delete-contribution-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const row = e.target.closest('tr');
        const id = row.dataset.id;
        if (confirm('Deseja realmente excluir este aporte? Esta ação é irreversível.')) {
          deleteContribution(id);
        }
      });
    });
  };

  const addInvestment = async (investmentData) => {
    try {
      // Criar objeto do investimento
      const investment = {
        ...investmentData,
        createdAt: localDateToISOString(new Date())
      };
      
      // Salvar no Firestore
      const docRef = await db.collection('investments').add(investment);
      
      // Atualizar o ID
      investment.id = docRef.id;
      
      // Adicionar ao estado local
      state.investments.push(investment);
      
      // Atualizar UI
      renderInvestmentCards();
      
      showToast('Investimento adicionado com sucesso!', 'success');
      
      return investment;
      
    } catch (error) {
      console.error('Erro ao adicionar investimento:', error);
      showToast('Erro ao adicionar investimento. Tente novamente.', 'error');
      return null;
    }
  };

  const updateInvestment = async (investmentId, updates) => {
    try {
      // Atualizar no Firestore
      await db.collection('investments').doc(investmentId).update(updates);
      
      // Atualizar no estado local
      const index = state.investments.findIndex(i => i.id === investmentId);
      
      if (index !== -1) {
        state.investments[index] = { ...state.investments[index], ...updates };
      }
      
      // Atualizar UI
      renderInvestmentCards();
      
      showToast('Investimento atualizado com sucesso!', 'success');
      
      return true;
      
    } catch (error) {
      console.error('Erro ao atualizar investimento:', error);
      showToast('Erro ao atualizar investimento. Tente novamente.', 'error');
      return false;
    }
  };

  const deleteInvestment = async (investmentId) => {
    try {
      // Verificar se há contribuições vinculadas
      const contributions = state.investmentContributions.filter(c => c.investmentId === investmentId);
      
      if (contributions.length > 0) {
        // Excluir contribuições
        const batch = db.batch();
        
        contributions.forEach(contribution => {
          const docRef = db.collection('investmentContributions').doc(contribution.id);
          batch.delete(docRef);
        });
        
        await batch.commit();
        
        // Remover do estado local
        state.investmentContributions = state.investmentContributions.filter(c => c.investmentId !== investmentId);
      }
      
      // Excluir o investimento
      await db.collection('investments').doc(investmentId).delete();
      
      // Remover do estado local
      state.investments = state.investments.filter(i => i.id !== investmentId);
      
      // Atualizar UI
      renderInvestmentCards();
      
      // Fechar modal de detalhes se estiver aberto
      if (state.currentInvestment && state.currentInvestment.id === investmentId) {
        closeModal('investmentDetailModal');
        openModal('investmentsModal');
      }
      
      showToast('Investimento excluído com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao excluir investimento:', error);
      showToast('Erro ao excluir investimento. Tente novamente.', 'error');
    }
  };

  const addContribution = async (contributionData) => {
    try {
      // Criar objeto da contribuição
      const contribution = {
        ...contributionData,
        createdAt: localDateToISOString(new Date())
      };
      
      // Salvar no Firestore
      const docRef = await db.collection('investmentContributions').add(contribution);
      
      // Atualizar o ID
      contribution.id = docRef.id;
      
      // Adicionar ao estado local
      state.investmentContributions.push(contribution);
      
      // Atualizar UI
      renderInvestmentContributions(contribution.investmentId);
      
      // Se um detalhe de investimento estiver aberto, atualizar a visualização
      if (state.currentInvestment && state.currentInvestment.id === contribution.investmentId) {
        openInvestmentDetail(contribution.investmentId);
      }
      
      showToast('Aporte adicionado com sucesso!', 'success');
      
      return contribution;
      
    } catch (error) {
      console.error('Erro ao adicionar aporte:', error);
      showToast('Erro ao adicionar aporte. Tente novamente.', 'error');
      return null;
    }
  };

  const updateContribution = async (contributionId, updates) => {
    try {
      // Atualizar no Firestore
      await db.collection('investmentContributions').doc(contributionId).update(updates);
      
      // Atualizar no estado local
      const index = state.investmentContributions.findIndex(c => c.id === contributionId);
      
      if (index !== -1) {
        state.investmentContributions[index] = { ...state.investmentContributions[index], ...updates };
      }
      
      // Atualizar UI
      if (state.currentInvestment) {
        renderInvestmentContributions(state.currentInvestment.id);
        openInvestmentDetail(state.currentInvestment.id);
      }
      
      showToast('Aporte atualizado com sucesso!', 'success');
      
      return true;
      
    } catch (error) {
      console.error('Erro ao atualizar aporte:', error);
      showToast('Erro ao atualizar aporte. Tente novamente.', 'error');
      return false;
    }
  };

  const deleteContribution = async (contributionId) => {
    try {
      const contribution = state.investmentContributions.find(c => c.id === contributionId);
      if (!contribution) return;
      
      // Excluir a contribuição
      await db.collection('investmentContributions').doc(contributionId).delete();
      
      // Remover do estado local
      state.investmentContributions = state.investmentContributions.filter(c => c.id !== contributionId);
      
      // Atualizar UI
      if (state.currentInvestment) {
        renderInvestmentContributions(state.currentInvestment.id);
        openInvestmentDetail(state.currentInvestment.id);
      }
      
      showToast('Aporte excluído com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao excluir aporte:', error);
      showToast('Erro ao excluir aporte. Tente novamente.', 'error');
    }
  };

  const openNewInvestmentModal = () => {
    // Resetar formulário
    $('#investmentForm').reset();
    
    // Definir data padrão (hoje)
    const today = new Date();
    setDateInputValue('investmentTargetDate', today);
    
    // Alterar título e botão
    $('.modal-title', $('#newInvestmentModal')).textContent = 'Novo Investimento';
    $('#saveInvestmentBtn').textContent = 'Salvar Investimento';
    
    // Configurar botão de salvar para adicionar
    $('#saveInvestmentBtn').dataset.action = 'add';
    $('#saveInvestmentBtn').removeAttribute('data-id');
    
    // Abrir modal
    closeModal('investmentsModal');
    openModal('newInvestmentModal');
  };

  const openEditInvestmentModal = (investmentId) => {
    const investment = state.investments.find(i => i.id === investmentId);
    if (!investment) return;
    
    state.currentInvestment = investment;
    
    // Preencher formulário
    $('#investmentName').value = investment.name;
    $('#investmentAmount').value = investment.amount || 0;
    $('#investmentGoal').value = investment.goal || '';
    $('#investmentCategory').value = investment.category || '';
    if (investment.targetDate) {
      setDateInputValue('investmentTargetDate', investment.targetDate);
    }
    $('#investmentNotes').value = investment.notes || '';
    
    // Alterar título e botão
    $('.modal-title', $('#newInvestmentModal')).textContent = 'Editar Investimento';
    $('#saveInvestmentBtn').textContent = 'Atualizar Investimento';
    
    // Configurar botão de salvar para atualizar
    $('#saveInvestmentBtn').dataset.action = 'update';
    $('#saveInvestmentBtn').dataset.id = investment.id;
    
    // Abrir modal
    closeModal('investmentDetailModal');
    openModal('newInvestmentModal');
  };

  const openNewContributionModal = () => {
    // Resetar formulário
    $('#contributionForm').reset();
    
    // Definir data padrão (hoje)
    const today = new Date();
    setDateInputValue('contributionDate', today);
    
    // Definir investimento atual
    $('#contributionInvestmentId').value = state.currentInvestment?.id || '';
    
    // Abrir modal
    openModal('newContributionModal');
  };

  const openEditContributionModal = (contribution) => {
    state.currentContribution = contribution;
    
    // Preencher formulário
    $('#contributionInvestmentId').value = contribution.investmentId;
    $('#contributionAmount').value = contribution.amount;
    $('#contributionDescription').value = contribution.description || '';
    setDateInputValue('contributionDate', contribution.date);
    
    // Alterar título e botão
    $('.modal-title', $('#newContributionModal')).textContent = 'Editar Aporte';
    $('#saveContributionBtn').textContent = 'Atualizar';
    $('#saveContributionBtn').dataset.action = 'update';
    $('#saveContributionBtn').dataset.id = contribution.id;
    
    // Abrir modal
    openModal('newContributionModal');
  };

  // Funções para transações
  const loadTransactions = async () => {
    try {
      const snapshot = await db.collection('transactions').get();
      
      state.transactions = [];
      
      if (!snapshot.empty) {
        snapshot.docs.forEach(doc => {
          const transaction = { id: doc.id, ...doc.data() };
          state.transactions.push(transaction);
        });
      }
      
      // Filtrar por mês atual
      filterTransactionsByMonth();
      
      // Atualizar UI
      updateTransactionsTable();
      updateKPIs();
      updateCharts();
      renderCommitments();
      generateInsights();
      
    } catch (error) {
      console.error('Erro ao carregar transações:', error);
      showToast('Erro ao carregar transações. Tente novamente.', 'error');
    }
  };

  // Filtrar transações por mês/ano corrigido para incluir regra do cartão 
  // Problema #3: Exibir a data correta de vencimento nas transações
  const filterTransactionsByMonth = () => {
    state.filteredTransactions = state.transactions.filter(transaction => {
      const date = parseLocalDateString(transaction.date);
      if (!date) return false;
      
      // Para transações comuns, verificar apenas mês e ano
      if (transaction.type !== 'expense' || transaction.paymentMethod !== 'credito' || !transaction.creditCardId) {
        return date.getMonth() === state.month && date.getFullYear() === state.year;
      }
      
      // Problema #3: Para despesas de cartão de crédito, usar a regra de fechamento para determinar o mês de exibição
      const card = state.cards.find(c => c.id === transaction.creditCardId);
      if (!card) return date.getMonth() === state.month && date.getFullYear() === state.year;
      
      // Calcular a data de vencimento real baseada no cartão
      const vencimento = calcularVencimentoReal(date, card);
      if (!vencimento) return date.getMonth() === state.month && date.getFullYear() === state.year;
      
      // Exibir a transação no mês do vencimento
      return vencimento.getMonth() === state.month && vencimento.getFullYear() === state.year;
    });

    // Ordenar por data (mais recentes primeiro)
    state.filteredTransactions.sort((a, b) => {
      const dateA = parseLocalDateString(a.date);
      const dateB = parseLocalDateString(b.date);
      return dateB - dateA;
    });

    // Atualizar a UI
    updateTransactionsTable();
    updateKPIs();
    updateCharts();
  };

  // Atualizar título do mês/ano
  const updateMonthYearTitle = () => {
    const monthNames = [
      'Janeiro', 'Fevereiro', 'Março', 'Abril',
      'Maio', 'Junho', 'Julho', 'Agosto',
      'Setembro', 'Outubro', 'Novembro', 'Dezembro'
    ];

    // Se houver um elemento para o título
    const titleElement = $('#monthYearTitle');
    if (titleElement) {
      titleElement.textContent = `${monthNames[state.month]} de ${state.year}`;
    }
  };

  // Atualizar KPIs (indicadores chave)
  const updateKPIs = () => {
    // Cálculos para o mês atual filtrado
    const totalIncome = state.filteredTransactions
      .filter(t => t.type === 'income')
      .reduce((sum, t) => sum + parseFloat(t.amount), 0);

    const totalExpense = state.filteredTransactions
      .filter(t => t.type === 'expense')
      .reduce((sum, t) => sum + parseFloat(t.amount), 0);

    const incomeReceived = state.filteredTransactions
      .filter(t => t.type === 'income' && t.status === 'received')
      .reduce((sum, t) => sum + parseFloat(t.amount), 0);

    const incomePending = state.filteredTransactions
      .filter(t => t.type === 'income' && t.status !== 'received')
      .reduce((sum, t) => sum + parseFloat(t.amount), 0);

    const expensePaid = state.filteredTransactions
      .filter(t => t.type === 'expense' && t.status === 'paid')
      .reduce((sum, t) => sum + parseFloat(t.amount), 0);

    const expensePending = state.filteredTransactions
      .filter(t => t.type === 'expense' && t.status !== 'paid')
      .reduce((sum, t) => sum + parseFloat(t.amount), 0);

    // Calcular saldo real e saldo comprometido
    const saldoReal = incomeReceived - expensePaid;
    const saldoComprometido = (totalIncome - totalExpense);

    // Atualizar elementos da UI
    if ($('#incomeValue')) $('#incomeValue').textContent = formatCurrency(totalIncome);
    if ($('#expenseValue')) $('#expenseValue').textContent = formatCurrency(totalExpense);

    // Atualizar o título do KPI
    if ($('#balanceValue')) {
      $('#balanceValue').textContent = formatCurrency(saldoReal);
      const kpiTitle = $('.kpi-balance .kpi-title');
      if (kpiTitle) {
        kpiTitle.textContent = 'Saldo Real (Caixa)';
      }
      
      // Adicionar tooltip para saldo comprometido
      const kpiSubtitle = $('.kpi-balance .kpi-subtitle');
      if (kpiSubtitle) {
        kpiSubtitle.innerHTML = `
          <svg width="16" height="16">
            <use href="#icon-info"></use>
          </svg>
          <span>Saldo comprometido: ${formatCurrency(saldoComprometido)}</span>
        `;
      }
    }
    
    if ($('#incomeReceivedValue')) $('#incomeReceivedValue').textContent = `${formatCurrency(incomeReceived)} recebidos`;
    if ($('#incomePendingValue')) $('#incomePendingValue').textContent = `${formatCurrency(incomePending)} pendentes`;
    
    if ($('#expensePaidValue')) $('#expensePaidValue').textContent = `${formatCurrency(expensePaid)} pagos`;
    if ($('#expensePendingValue')) $('#expensePendingValue').textContent = `${formatCurrency(expensePending)} pendentes`;
    
    // Calcular o total de faturas de cartão de crédito para o mês selecionado
    let monthlyInvoiceTotal = 0;
    const targetYear = state.year;
    const targetMonth = state.month;

    if (state.cards.length > 0) {
      // Filtrar transações do mês atual que são despesas de cartão de crédito
      const creditCardExpenses = state.filteredTransactions.filter(t => 
        t.type === 'expense' && 
        t.paymentMethod === 'credito' && 
        t.status !== 'paid'
      );
      
      // Somar o valor dessas despesas
      monthlyInvoiceTotal = creditCardExpenses.reduce((total, t) => total + parseFloat(t.amount), 0);
      
      // Obter o primeiro cartão para a data de vencimento (ou poderíamos pegar o mais próximo)
      if (state.cards.length > 0) {
        const firstCard = state.cards[0];
        const dueDate = new Date(targetYear, targetMonth, firstCard.dueDay);
        
        if ($('#invoiceDueDate')) {
          $('#invoiceDueDate').textContent = formatDate(dueDate);
        }
      }
    }

    // Atualizar o KPI da Fatura do Mês
    if ($('#invoiceValue')) {
      $('#invoiceValue').textContent = formatCurrency(monthlyInvoiceTotal);
    }
  };

  // Atualizar a lista de cartões
  const updateCardsList = () => {
    const cardsList = $('#cardsList');
    if (!cardsList) return;

    cardsList.innerHTML = '';

    if (state.cards.length === 0) {
      cardsList.innerHTML = '<p style="text-align: center; padding: var(--spacing-md);">Nenhum cartão cadastrado.</p>';
      return;
    }

    // Adicionar sumário de todos os cartões se houver mais de um
    if (state.cards.length > 1) {
      const totalLimit = state.cards.reduce((sum, card) => sum + card.limit, 0);
      const totalAvailable = state.cards.reduce((sum, card) => sum + card.availableLimit, 0);
      const totalInvoice = state.cards.reduce((sum, card) => sum + (card.currentInvoice || 0), 0);
      const limitPercentage = totalLimit > 0 ? ((totalLimit - totalAvailable) / totalLimit) * 100 : 0;

      const summaryElement = document.createElement('div');
      summaryElement.className = 'card';
      summaryElement.style.marginBottom = 'var(--spacing-xl)';
      summaryElement.style.backgroundColor = 'var(--color-surface-variant)';
      summaryElement.style.borderLeft = '4px solid var(--color-primary)';

      summaryElement.innerHTML = `
        <h3 style="margin-bottom: var(--spacing-md);">Resumo de Todos os Cartões</h3>
        
        <div style="margin-bottom: var(--spacing-xs);">
          <div style="display: flex; justify-content: space-between;">
            <span>Limite Total:</span>
            <strong>${formatCurrency(totalLimit)}</strong>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span>Limite Disponível:</span>
            <strong>${formatCurrency(totalAvailable)}</strong>
          </div>
          <div style="display: flex; justify-content: space-between; margin-top: var(--spacing-xs);">
            <span>Fatura Total:</span>
            <strong>${formatCurrency(totalInvoice)}</strong>
          </div>
        </div>
        
        <div class="commitment-progress" style="margin-top: var(--spacing-md);">
          <div class="commitment-progress-bar" style="width: ${limitPercentage}%; background-color: ${limitPercentage > 70 ? 'var(--color-error)' : 'var(--color-primary)'}"></div>
        </div>
      `;

      cardsList.appendChild(summaryElement);
    }

    state.cards.forEach(card => {
      const cardElement = document.createElement('div');
      cardElement.className = 'card';
      cardElement.style.marginBottom = 'var(--spacing-md)';

      // Calcular datas de fechamento e vencimento
      const today = new Date();
      let closingDate = new Date(today.getFullYear(), today.getMonth(), card.closingDay);

      // Se hoje é após o dia de fechamento, a data de fechamento será no próximo mês
      if (today.getDate() > card.closingDay) {
        closingDate.setMonth(closingDate.getMonth() + 1);
      }

      let dueDate = new Date(today.getFullYear(), today.getMonth(), card.dueDay);

      // Se hoje é após o dia de vencimento, a data de vencimento será no próximo mês
      if (today.getDate() > card.dueDay) {
        dueDate.setMonth(dueDate.getMonth() + 1);
      }

      // Calcular a porcentagem do limite utilizado
      // Problema #5: Corrigir o cálculo de limite disponível do cartão
      const limitPercentage = card.limit > 0 ? ((card.limit - card.availableLimit) / card.limit) * 100 : 0;

      // Melhor dia para compras simplificado e correto
      const melhorDiaCompras = calcularMelhorDiaCompras(card);

      cardElement.innerHTML = `
        <div style="display: flex; justify-content: space-between; margin-bottom: var(--spacing-md);">
          <h3>${card.name}</h3>
          <div style="display: flex; gap: var(--spacing-xs);">
            <button class="btn btn-icon btn-outline edit-card-btn" data-id="${card.id}">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-card-btn" data-id="${card.id}">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        </div>
        
        <div style="margin-bottom: var(--spacing-xs);">
          <div style="display: flex; justify-content: space-between;">
            <span>Limite Total:</span>
            <strong>${formatCurrency(card.limit)}</strong>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span>Limite Disponível:</span>
            <strong>${formatCurrency(card.availableLimit)}</strong>
          </div>
        </div>
        
        <div class="commitment-progress" style="margin-bottom: var(--spacing-md);">
          <div class="commitment-progress-bar" style="width: ${limitPercentage}%; background-color: ${limitPercentage > 70 ? 'var(--color-error)' : 'var(--color-primary)'}"></div>
        </div>
        
        <div style="display: flex; justify-content: space-between; margin-bottom: var(--spacing-md);">
          <div>
            <small>Fechamento:</small>
            <div>${card.closingDay} (${formatDate(closingDate)})</div>
          </div>
          <div>
            <small>Vencimento:</small>
            <div>${card.dueDay} (${formatDate(dueDate)})</div>
          </div>
        </div>
        
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <small>Fatura Atual:</small>
            <div>${formatCurrency(card.currentInvoice || 0)}</div>
          </div>
          <button class="btn btn-primary view-invoice-btn" data-id="${card.id}">Ver Fatura</button>
        </div>
        
        <div style="margin-top: var(--spacing-md); font-size: var(--font-size-xs); color: var(--color-info);">
          <strong>Dica:</strong> Melhor dia para compras: dia ${melhorDiaCompras}
        </div>
      `;

      cardsList.appendChild(cardElement);
    });

    // Adicionar event listeners
    $$('.edit-card-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const id = e.currentTarget.dataset.id;
        const card = state.cards.find(c => c.id === id);
        
        if (card) {
          openEditCardModal(card);
        }
      });
    });

    $$('.delete-card-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const id = e.currentTarget.dataset.id;
        deleteCard(id);
      });
    });

    $$('.view-invoice-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const id = e.currentTarget.dataset.id;
        openCardInvoice(id);
      });
    });
  };

  // Abrir o modal de fatura do cartão
  const openCardInvoice = cardId => {
    const card = state.cards.find(c => c.id === cardId);
    if (!card) return;

    state.currentCard = card;

    // Calcular período da fatura
    const today = new Date();
    let closingDate = new Date(today.getFullYear(), today.getMonth(), card.closingDay);

    // Se hoje é após o dia de fechamento, a data de fechamento será no próximo mês
    if (today.getDate() > card.closingDay) {
      closingDate.setMonth(closingDate.getMonth() + 1);
    }

    // Data de fechamento anterior
    const previousClosing = new Date(closingDate);
    previousClosing.setMonth(previousClosing.getMonth() - 1);

    // Data de vencimento
    let dueDate = new Date(closingDate);
    dueDate.setDate(card.dueDay);

    // Título do modal
    $('#cardInvoiceTitle').textContent = `Fatura do Cartão - ${card.name}`;

    // Detalhes da fatura
    $('#cardInvoiceDetails').innerHTML = `
      <div style="display: flex; justify-content: space-between; margin-bottom: var(--spacing-xs);">
        <div>
          <strong>Período:</strong> ${formatDate(previousClosing)} - ${formatDate(closingDate)}
        </div>
        <div>
          <strong>Vencimento:</strong> ${formatDate(dueDate)}
        </div>
      </div>
      <div style="display: flex; justify-content: space-between;">
        <div>
          <strong>Limite Total:</strong> ${formatCurrency(card.limit)}
        </div>
        <div>
          <strong>Limite Disponível:</strong> ${formatCurrency(card.availableLimit)}
        </div>
      </div>
      <div style="margin-top: var(--spacing-xs);">
        <strong>Valor da Fatura:</strong> ${formatCurrency(card.currentInvoice || 0)}
      </div>
    `;

    // Buscar transações do período
    // Problema #6: Corrigir exibição da primeira despesa na fatura do cartão
    const invoiceTransactions = state.transactions.filter(t => 
      t.type === 'expense' && 
      t.paymentMethod === 'credito' && 
      t.creditCardId === card.id &&
      parseLocalDateString(t.date) >= previousClosing &&
      parseLocalDateString(t.date) < closingDate
    );

    // Ordenar por data
    invoiceTransactions.sort((a, b) => {
      const dateA = parseLocalDateString(a.date);
      const dateB = parseLocalDateString(b.date);
      return dateB - dateA;
    });

    // Renderizar tabela
    const tableBody = $('#cardInvoiceTableBody');
    tableBody.innerHTML = '';

    if (invoiceTransactions.length === 0) {
      tableBody.innerHTML = `
        <tr>
          <td colspan="5" style="text-align: center; padding: var(--spacing-xl);">
            Nenhuma despesa para esta fatura.
          </td>
        </tr>
      `;
    } else {
      invoiceTransactions.forEach(transaction => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>
            <div class="transaction-icon" style="background-color: rgba(255, 59, 48, 0.1); color: var(--color-expense);">
              ${transaction.categoryIcon || '📦'}
            </div>
          </td>
          <td>${transaction.name}</td>
          <td>${formatDate(transaction.date)}</td>
          <td>${formatCurrency(transaction.amount)}</td>
          <td>
            <div class="checkbox-wrapper">
              <input type="checkbox" class="checkbox invoice-paid-checkbox" id="invoice-paid-${transaction.id}" 
                    ${transaction.status === 'paid' ? 'checked' : ''}
                    data-id="${transaction.id}">
              <label class="checkbox-label" for="invoice-paid-${transaction.id}"></label>
            </div>
          </td>
        `;
        
        tableBody.appendChild(row);
      });

      // Adicionar event listeners para os checkboxes de pagamento
      $$('.invoice-paid-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', e => {
          const id = e.target.dataset.id;
          const isChecked = e.target.checked;
          
          updateTransaction(id, { status: isChecked ? 'paid' : 'pending' });
        });
      });
    }

    // Configurar o botão de pagar fatura
    $('#invoiceConfirmAmount').textContent = formatCurrency(card.currentInvoice || 0);

    // Exibir o modal
    closeModal('cardsListModal');
    openModal('cardInvoiceModal');
  };

  // Variáveis globais para gráficos
  let pieChart = null;
  let barChart = null;
  let areaChart = null;
  let fixedVsVariableChart = null; // Gráfico de despesas fixas vs variáveis
  let personAnalysisChart = null; // Gráfico de despesas por pessoa

  // AJUSTE 18: Função para criar gráficos aprimorados
  const createCharts = () => {
    // Configurações de cores baseadas no tema atual
    const isDarkTheme = document.documentElement.getAttribute('data-theme') === 'dark';

    const textColor = isDarkTheme ? '#f5f5f7' : '#1d1d1f';
    const gridColor = isDarkTheme ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';

    // AJUSTE 22: Cores da paleta da Apple para gráficos
    const appleColors = [
      '#007AFF', // azul
      '#34C759', // verde
      '#FF9500', // laranja
      '#FF3B30', // vermelho
      '#AF52DE', // roxo
      '#5E5CE6', // azul índigo
      '#FF2D55', // rosa
      '#FF9F0A', // amarelo
      '#64D2FF', // azul claro
      '#30B0C7'  // azul esverdeado
    ];

    // Configurações comuns para todos os gráficos
    Chart.defaults.color = textColor;
    Chart.defaults.borderColor = gridColor;
    Chart.defaults.font.family = "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif";

    // Configurar tema para tooltips
    Chart.defaults.plugins.tooltip.backgroundColor = isDarkTheme ? 'rgba(28, 28, 30, 0.95)' : 'rgba(255, 255, 255, 0.95)';
    Chart.defaults.plugins.tooltip.titleColor = textColor;
    Chart.defaults.plugins.tooltip.bodyColor = textColor;
    Chart.defaults.plugins.tooltip.borderColor = isDarkTheme ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
    Chart.defaults.plugins.tooltip.borderWidth = 1;
    Chart.defaults.plugins.tooltip.padding = 10;
    Chart.defaults.plugins.tooltip.cornerRadius = 6;
    Chart.defaults.plugins.tooltip.boxPadding = 6;

    try {
      // AJUSTE 9: Aumentar o tamanho dos gráficos para evitar texto cortado
      // AJUSTE 18: Gráfico de pizza aprimorado - Despesas por Categoria
      const pieCtx = document.getElementById('catPie');
      if (pieCtx) {
        pieChart = new Chart(pieCtx.getContext('2d'), {
          type: 'doughnut',
          data: {
            labels: [],
            datasets: [{
              data: [],
              backgroundColor: appleColors,
              borderColor: isDarkTheme ? '#000000' : '#ffffff',
              borderWidth: 2,
              hoverOffset: 16,
              borderRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            cutout: '65%',
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 20,
                  usePointStyle: true,
                  pointStyle: 'circle',
                  color: textColor,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const value = context.parsed;
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = Math.round((value / total) * 100);
                    return `${formatCurrency(value)} (${percentage}%)`;
                  }
                },
                titleColor: textColor,
                bodyColor: textColor
              }
            },
            layout: {
              padding: 15
            }
          }
        });
      }

      // AJUSTE 18: Gráfico de barras aprimorado - Receitas x Despesas (12 meses)
      const barCtx = document.getElementById('annualBars');
      if (barCtx) {
        barChart = new Chart(barCtx.getContext('2d'), {
          type: 'bar',
          data: {
            labels: [],
            datasets: [
              {
                label: 'Receitas',
                data: [],
                backgroundColor: appleColors[1], // verde
                borderColor: appleColors[1],
                borderWidth: 1,
                borderRadius: 6,
                barPercentage: 0.7,
                categoryPercentage: 0.8
              },
              {
                label: 'Despesas',
                data: [],
                backgroundColor: appleColors[3], // vermelho
                borderColor: appleColors[3],
                borderWidth: 1,
                borderRadius: 6,
                barPercentage: 0.7,
                categoryPercentage: 0.8
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: 'index',
              intersect: false
            },
            scales: {
              x: {
                grid: {
                  display: false,
                  color: gridColor
                },
                ticks: {
                  color: textColor,
                  font: {
                    size: 12
                  }
                }
              },
              y: {
                beginAtZero: true,
                grid: {
                  color: gridColor
                },
                ticks: {
                  color: textColor,
                  font: {
                    size: 12
                  },
                  callback: function(value) {
                    return formatCurrency(value);
                  }
                }
              }
            },
            plugins: {
              legend: {
                labels: {
                  usePointStyle: true,
                  pointStyle: 'circle',
                  color: textColor,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                titleColor: textColor,
                bodyColor: textColor,
                callbacks: {
                  label: function(context) {
                    return context.dataset.label + ': ' + formatCurrency(context.parsed.y);
                  }
                }
              }
            },
            layout: {
              padding: 10
            }
          }
        });
      }

      // AJUSTE 18: Gráfico de área aprimorado - Limite do Cartão
      const areaCtx = document.getElementById('cardArea');
      if (areaCtx) {
        areaChart = new Chart(areaCtx.getContext('2d'), {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: 'Limite Utilizado',
                data: [],
                fill: true,
                backgroundColor: 'rgba(255, 59, 48, 0.2)',
                borderColor: appleColors[3], // vermelho
                borderWidth: 2,
                tension: 0.4,
                pointRadius: 0
              },
              {
                label: 'Limite Total',
                data: [],
                fill: false,
                borderColor: appleColors[0], // azul
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0
              },
              {
                label: 'Limite Disponível',
                data: [],
                fill: false,
                borderColor: appleColors[1], // verde
                borderWidth: 2,
                pointRadius: 0
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: 'nearest',
              intersect: false,
              axis: 'x'
            },
            scales: {
              x: {
                grid: {
                  display: false,
                  color: gridColor
                },
                ticks: {
                  color: textColor,
                  font: {
                    size: 12
                  },
                  maxRotation: 0,
                  autoSkip: true,
                  maxTicksLimit: 10
                }
              },
              y: {
                beginAtZero: true,
                grid: {
                  color: gridColor
                },
                ticks: {
                  color: textColor,
                  font: {
                    size: 12
                  },
                  callback: function(value) {
                    return formatCurrency(value);
                  }
                }
              }
            },
            plugins: {
              legend: {
                labels: {
                  usePointStyle: true,
                  pointStyle: 'circle',
                  color: textColor,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                titleColor: textColor,
                bodyColor: textColor,
                callbacks: {
                  label: function(context) {
                    return context.dataset.label + ': ' + formatCurrency(context.parsed.y);
                  }
                }
              }
            },
            layout: {
              padding: 10
            }
          }
        });
      }

      // AJUSTE 17: Gráfico aprimorado - Despesas Fixas vs Variáveis
      const fixedVsVariableCtx = document.getElementById('fixedVsVariableChart');
      if (fixedVsVariableCtx) {
        fixedVsVariableChart = new Chart(fixedVsVariableCtx.getContext('2d'), {
          type: 'pie',
          data: {
            labels: ['Despesas Fixas', 'Despesas Variáveis'],
            datasets: [{
              data: [0, 0],
              backgroundColor: [
                appleColors[0], // azul
                appleColors[2]  // laranja
              ],
              borderColor: isDarkTheme ? '#000000' : '#ffffff',
              borderWidth: 2,
              hoverOffset: 16,
              borderRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 20,
                  usePointStyle: true,
                  pointStyle: 'circle',
                  color: textColor,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const value = context.parsed;
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = Math.round((value / total) * 100);
                    return `${formatCurrency(value)} (${percentage}%)`;
                  }
                },
                titleColor: textColor,
                bodyColor: textColor
              }
            },
            layout: {
              padding: 15
            }
          }
        });
      }

      // AJUSTE 20: Gráfico aprimorado - Despesas por Pessoa
      const personAnalysisCtx = document.getElementById('personAnalysisChart');
      if (personAnalysisCtx) {
        personAnalysisChart = new Chart(personAnalysisCtx.getContext('2d'), {
          type: 'pie',
          data: {
            labels: [],
            datasets: [{
              data: [],
              backgroundColor: appleColors,
              borderColor: isDarkTheme ? '#000000' : '#ffffff',
              borderWidth: 2,
              hoverOffset: 16,
              borderRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 20,
                  usePointStyle: true,
                  pointStyle: 'circle',
                  color: textColor,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const value = context.parsed;
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = Math.round((value / total) * 100);
                    return `${formatCurrency(value)} (${percentage}%)`;
                  }
                },
                titleColor: textColor,
                bodyColor: textColor
              }
            },
            layout: {
              padding: 15
            }
          }
        });
      }
    } catch (error) {
      console.error('Erro ao criar gráficos:', error);
    }
  };

  // Atualizar os gráficos com dados recentes
  const updateCharts = () => {
    try {
      // Se os gráficos ainda não foram criados, criar agora
      if (!pieChart || !barChart || !areaChart || !fixedVsVariableChart || !personAnalysisChart) {
        createCharts();
      }

      if (!pieChart || !barChart || !areaChart) {
        console.error('Não foi possível inicializar os gráficos');
        return;
      }

      // Atualizar cores se o tema mudou
      updateChartColors();

      // 1. Atualizar gráfico de pizza - Despesas por categoria
      const categoryTotals = state.filteredTransactions
        .filter(t => t.type === 'expense')
        .reduce((acc, t) => {
          // Problema #9: Corrigir nomes de categorias distorcidos
          const categoryName = t.categoryName || t.category;
          if (!acc[categoryName]) {
            acc[categoryName] = 0;
          }
          acc[categoryName] += parseFloat(t.amount);
          return acc;
        }, {});

      // Converter para arrays para o gráfico
      const categories = Object.keys(categoryTotals);
      const categoryValues = categories.map(c => categoryTotals[c]);

      // Atualizar dados do gráfico de pizza
      pieChart.data.labels = categories;
      pieChart.data.datasets[0].data = categoryValues;
      pieChart.update();

      // 2. Atualizar gráfico de barras - Receitas x Despesas (12 meses)
      const months = [];
      const incomeData = [];
      const expenseData = [];

      // Obter os últimos 12 meses
      const today = new Date();
      for (let i = 11; i >= 0; i--) {
        const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
        const monthName = date.toLocaleString('pt-BR', { month: 'short' });
        const year = date.getFullYear();
        const monthYear = `${monthName}/${year.toString().substr(2, 2)}`;
        
        months.push(monthYear);
        
        // Filtrar transações para este mês
        const monthTransactions = state.transactions.filter(t => {
          const tDate = parseLocalDateString(t.date);
          return tDate && tDate.getMonth() === date.getMonth() && tDate.getFullYear() === date.getFullYear();
        });
        
        // Calcular totais
        const monthlyIncome = monthTransactions
          .filter(t => t.type === 'income')
          .reduce((sum, t) => sum + parseFloat(t.amount), 0);
        
        const monthlyExpense = monthTransactions
          .filter(t => t.type === 'expense')
          .reduce((sum, t) => sum + parseFloat(t.amount), 0);
        
        incomeData.push(monthlyIncome);
        expenseData.push(monthlyExpense);
      }

      // Atualizar dados do gráfico de barras
      barChart.data.labels = months;
      barChart.data.datasets[0].data = incomeData;
      barChart.data.datasets[1].data = expenseData;
      barChart.update();

      // 3. Atualizar gráfico de área - Limite do Cartão
      // Se não houver cartões, mostrar mensagem
      if (state.cards.length === 0) {
        areaChart.data.labels = ['Nenhum cartão cadastrado'];
        areaChart.data.datasets[0].data = [0];
        areaChart.data.datasets[1].data = [0];
        areaChart.data.datasets[2].data = [0];
        areaChart.update();
        return;
      }

      // Calcular o total do limite disponível e utilizado de todos os cartões
      // Problema #5: Corrigir o cálculo de limite disponível do cartão
      const combinedLimit = state.cards.reduce((sum, card) => sum + card.limit, 0);
      const combinedAvailable = state.cards.reduce((sum, card) => sum + card.availableLimit, 0);
      const combinedUsed = combinedLimit - combinedAvailable;

      // Obter os dias do mês atual
      const daysInMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
      const daysLabels = Array.from({ length: daysInMonth }, (_, i) => i + 1);

      // Criar dados para o gráfico
      const limitUsedLine = daysLabels.map(() => combinedUsed);
      const limitTotalLine = daysLabels.map(() => combinedLimit);
      const limitAvailableLine = daysLabels.map(() => combinedAvailable);

      // Atualizar dados do gráfico de área
      areaChart.data.labels = daysLabels;
      areaChart.data.datasets[0].data = limitUsedLine;
      areaChart.data.datasets[1].data = limitTotalLine;
      areaChart.data.datasets[2].data = limitAvailableLine;
      areaChart.update();

      // AJUSTE 17: Atualizar o gráfico de despesas fixas vs variáveis
      if (fixedVsVariableChart) {
        // Calcular despesas fixas e variáveis
        const fixedExpenses = state.filteredTransactions
          .filter(t => t.type === 'expense' && t.isFixed === 'fixed')
          .reduce((sum, t) => sum + parseFloat(t.amount), 0);
        
        const variableExpenses = state.filteredTransactions
          .filter(t => t.type === 'expense' && t.isFixed === 'variable')
          .reduce((sum, t) => sum + parseFloat(t.amount), 0);
        
        // Atualizar dados do gráfico
        fixedVsVariableChart.data.datasets[0].data = [fixedExpenses, variableExpenses];
        fixedVsVariableChart.update();
      }

      // AJUSTE 20: Atualizar o gráfico de despesas por pessoa
      if (personAnalysisChart) {
        // Calcular despesas por pessoa
        const expensesByPerson = {};
        
        // Inicializar com pessoas existentes
        state.people.forEach(person => {
          expensesByPerson[person.id] = 0;
        });
        
        // Adicionar categoria para transações sem pessoa associada
        expensesByPerson['sem_pessoa'] = 0;
        
        // Calcular total de gastos por pessoa
        state.filteredTransactions
          .filter(t => t.type === 'expense')
          .forEach(transaction => {
            const personId = transaction.person || 'sem_pessoa';
            expensesByPerson[personId] = (expensesByPerson[personId] || 0) + parseFloat(transaction.amount);
          });
        
        // Preparar dados para o gráfico
        const personLabels = [];
        const personValues = [];
        
        for (const [personId, total] of Object.entries(expensesByPerson)) {
          // Pular se não tiver gastos
          if (total === 0) continue;
          
          // Encontrar nome da pessoa
          let personName = 'Não categorizado';
          
          if (personId !== 'sem_pessoa') {
            const person = state.people.find(p => p.id === personId);
            if (person) {
              personName = person.name;
            }
          }
          
          personLabels.push(personName);
          personValues.push(total);
        }
        
        // Atualizar dados do gráfico
        personAnalysisChart.data.labels = personLabels;
        personAnalysisChart.data.datasets[0].data = personValues;
        personAnalysisChart.update();
      }
    } catch (error) {
      console.error('Erro ao atualizar gráficos:', error);
    }
  };

  // AJUSTE 14: Função para toggle de compromissos melhorada
  const toggleCommitments = () => {
    const content = $('#commitmentsContent');
    const header = $('#commitmentsHeader');

    if (!content || !header) return;

    if (header.classList.contains('active')) {
      // Fechar
      header.classList.remove('active');
      content.style.maxHeight = '0px';
    } else {
      // Abrir
      header.classList.add('active');
      content.style.maxHeight = content.scrollHeight + 'px';
    }
  };

  // Gerar insights para o usuário
  const generateInsights = () => {
    state.insights = [];

    const today = new Date();

    // Verificar transações vencidas e não pagas
    const overdueTransactions = state.transactions.filter(t => 
      t.type === 'expense' && 
      t.status !== 'paid' && 
      t.dueDate && parseLocalDateString(t.dueDate) < today
    );

    // Corrigir texto de contas vencidas e adicionar modal com detalhes
    if (overdueTransactions.length > 0) {
      // Texto gramaticalmente correto
      const message = overdueTransactions.length === 1 
        ? "Você tem 1 conta vencida." 
        : `Você tem ${overdueTransactions.length} contas vencidas.`;
        
      state.insights.push({
        id: 'overdue',
        level: 'danger',
        icon: 'icon-alert',
        message: message,
        actionText: 'Ver Detalhes',
        action: () => {
          // Problema #12: Corrigir exibição das transações no alerta de contas a vencer
          // Abrir um modal com lista detalhada de contas vencidas
          openOverdueDetailsModal(overdueTransactions);
        }
      });
    }

    // Verificar transações a vencer nos próximos 5 dias
    const nextDueDate = new Date(today);
    nextDueDate.setDate(today.getDate() + 5);

    const upcomingTransactions = state.transactions.filter(t => 
      t.type === 'expense' && 
      t.status !== 'paid' && 
      t.dueDate && parseLocalDateString(t.dueDate) > today && 
      parseLocalDateString(t.dueDate) <= nextDueDate
    );

    if (upcomingTransactions.length > 0) {
      state.insights.push({
        id: 'upcoming',
        level: 'warning',
        icon: 'icon-calendar',
        message: `Você tem ${upcomingTransactions.length} contas a vencer nos próximos 5 dias.`,
        actionText: 'Ver Detalhes',
        action: () => {
          // Problema #12: Abrir modal de transações detalhadas, em vez de mostrar alerta genérico
          openOverdueDetailsModal(upcomingTransactions);
        }
      });
    }

    // Verificar se há cartão com limite quase atingido
    const cardsWithLowLimit = state.cards.filter(card => 
      card.availableLimit < (card.limit * 0.2)
    );

    if (cardsWithLowLimit.length > 0) {
      state.insights.push({
        id: 'low-limit',
        level: 'warning',
        icon: 'icon-credit-card',
        message: `Você está com limite baixo no cartão ${cardsWithLowLimit[0].name}.`,
        actionText: 'Ver Cartão',
        action: () => {
          openCardInvoice(cardsWithLowLimit[0].id);
        }
      });
    }

    // Mostrar insights na UI
    renderInsights();
  };

  // Modal para detalhes de contas vencidas
  // Problema #12: Corrigir exibição das transações no alerta de contas a vencer
  const openOverdueDetailsModal = (overdueTransactions) => {
    const tableBody = $('#overdueTransactionsTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    if (overdueTransactions.length === 0) {
      tableBody.innerHTML = `
        <tr>
          <td colspan="6" style="text-align: center; padding: var(--spacing-xl);">
            Nenhuma conta vencida encontrada.
          </td>
        </tr>
      `;
    } else {
      // Ordenar por data de vencimento (mais antigas primeiro)
      const sortedTransactions = [...overdueTransactions].sort((a, b) => {
        const dateA = parseLocalDateString(a.dueDate);
        const dateB = parseLocalDateString(b.dueDate);
        return dateA - dateB;
      });
      
      sortedTransactions.forEach(transaction => {
        const row = document.createElement('tr');
        const vencimentoDate = parseLocalDateString(transaction.dueDate);
        const today = new Date();
        const diasAtraso = Math.floor((today - vencimentoDate) / (1000 * 60 * 60 * 24));
        
        row.innerHTML = `
          <td>
            <div class="transaction-icon" style="background-color: rgba(255, 59, 48, 0.1); color: var(--color-expense);">
              ${transaction.categoryIcon || '📦'}
            </div>
          </td>
          <td>${transaction.name}</td>
          <td>${transaction.categoryName || transaction.category}</td>
          <td>${formatDate(transaction.dueDate)} <small>(${diasAtraso > 0 ? diasAtraso + ' dias atraso' : 'Hoje'})</small></td>
          <td>${formatCurrency(transaction.amount)}</td>
          <td>
            <button class="btn btn-success mark-paid-btn" data-id="${transaction.id}">
              Marcar Pago
            </button>
          </td>
        `;
        
        tableBody.appendChild(row);
      });
      
      // Adicionar event listeners para os botões de pagamento
      $$('.mark-paid-btn').forEach(btn => {
        btn.addEventListener('click', e => {
          const id = e.currentTarget.dataset.id;
          updateTransactionStatus(id, 'paid');
          e.currentTarget.closest('tr').remove();
          
          // Se não houver mais contas vencidas, fechar o modal
          if (tableBody.children.length === 0) {
            closeModal('overdueDetailsModal');
            generateInsights();
          }
        });
      });
    }
    
    // Configurar botão para pagar todas
    const payAllBtn = $('#payAllOverdueBtn');
    if (payAllBtn) {
      payAllBtn.addEventListener('click', async () => {
        try {
          // Marcar todas as transações como pagas
          const batch = db.batch();
          
          overdueTransactions.forEach(transaction => {
            const docRef = db.collection('transactions').doc(transaction.id);
            batch.update(docRef, { status: 'paid' });
            
            // Atualizar no estado local
            const index = state.transactions.findIndex(t => t.id === transaction.id);
            if (index !== -1) {
              state.transactions[index].status = 'paid';
            }
          });
          
          await batch.commit();
          
          // Atualizar UI
          updateTransactionsTable();
          updateKPIs();
          updateCharts();
          generateInsights();
          
          closeModal('overdueDetailsModal');
          showToast('Todas as contas foram marcadas como pagas!', 'success');
        } catch (error) {
          console.error('Erro ao pagar todas as contas:', error);
          showToast('Erro ao pagar contas. Tente novamente.', 'error');
        }
      });
    }
    
    // Abrir o modal
    openModal('overdueDetailsModal');
  };

  // Renderizar insights na UI
  const renderInsights = () => {
    const container = $('#insightsBanner');
    if (!container) return;

    container.innerHTML = '';

    if (state.insights.length === 0) {
      return;
    }

    state.insights.forEach(insight => {
      const insightElement = document.createElement('div');
      insightElement.className = `insight-banner insight-${insight.level}`;

      insightElement.innerHTML = `
        <div class="insight-icon">
          <svg width="24" height="24">
            <use href="#${insight.icon}"></use>
          </svg>
        </div>
        <div class="insight-content">
          <div class="insight-title">${insight.message}</div>
        </div>
        <button class="btn btn-outline insight-action" data-id="${insight.id}">
          ${insight.actionText}
        </button>
      `;

      container.appendChild(insightElement);
    });

    // Adicionar event listeners
    $$('.insight-action').forEach(btn => {
      btn.addEventListener('click', e => {
        const id = e.currentTarget.dataset.id;
        const insight = state.insights.find(i => i.id === id);
        
        if (insight && insight.action) {
          insight.action();
        }
      });
    });
  };

  // AJUSTE 14: Renderizar compromissos de longo prazo com barras de progresso
  const renderCommitments = () => {
    const content = $('#commitmentsContent');
    if (!content) return;

    content.innerHTML = '';

    // Filtrar transações recorrentes
    const recurrentTransactions = state.transactions.filter(t => 
      t.isRecurrent && 
      t.installments && 
      t.installmentNumber && 
      t.installments > t.installmentNumber
    );

    if (recurrentTransactions.length === 0) {
      content.innerHTML = '<p style="text-align: center; padding: var(--spacing-md);">Nenhum compromisso de longo prazo.</p>';
      return;
    }

    // Agrupar por ID de recorrência
    const groupedByRecurrence = recurrentTransactions.reduce((acc, t) => {
      const key = t.recurrenceId || t.id;

      if (!acc[key]) {
        acc[key] = {
          id: key,
          name: t.name,
          category: t.category,
          categoryName: t.categoryName,
          categoryIcon: t.categoryIcon,
          amount: parseFloat(t.amount),
          installments: t.installments,
          currentInstallment: Math.min(...recurrentTransactions
            .filter(rt => (rt.recurrenceId || rt.id) === key)
            .map(rt => rt.installmentNumber)),
          type: t.type
        };
      }

      return acc;
    }, {});

    // Converter para array e ordenar por progresso
    const commitments = Object.values(groupedByRecurrence)
      .sort((a, b) => (a.currentInstallment / a.installments) - (b.currentInstallment / b.installments));

    // Renderizar cada compromisso
    commitments.forEach(commitment => {
      const progress = (commitment.currentInstallment / commitment.installments) * 100;
      const color = commitment.type === 'income' ? 'var(--color-income)' : 'var(--color-expense)';

      const commitmentElement = document.createElement('div');
      commitmentElement.className = 'commitment-item';

      commitmentElement.innerHTML = `
        <div class="transaction-icon" style="background-color: ${commitment.type === 'income' ? 'rgba(52, 199, 89, 0.1)' : 'rgba(255, 59, 48, 0.1)'}; color: ${color};">
          ${commitment.categoryIcon || (commitment.type === 'income' ? '💰' : '📦')}
        </div>
        <div style="flex: 1;">
          <div style="display: flex; justify-content: space-between;">
            <div>${commitment.name}</div>
            <div>${formatCurrency(commitment.amount)}</div>
          </div>
          <div style="display: flex; justify-content: space-between; font-size: var(--font-size-xs); color: var(--color-on-surface-variant);">
            <div>${commitment.categoryName || commitment.category}</div>
            <div>${commitment.currentInstallment}/${commitment.installments}</div>
          </div>
          <div class="commitment-progress" style="margin-top: var(--spacing-xs);">
            <div class="commitment-progress-bar" style="width: ${progress}%; background-color: ${color};"></div>
          </div>
        </div>
      `;

      content.appendChild(commitmentElement);
    });
  };

  // Função para criar filtros de transações personalizados
  const createTransactionFilters = () => {
    const filtersContainer = $('#transaction-filters');
    if (!filtersContainer) return;

    // Limpar filtros existentes
    filtersContainer.innerHTML = '';

    // Filtro de categoria
    const categorySelect = document.createElement('div');
    categorySelect.className = 'select-wrapper';
    categorySelect.innerHTML = `
      <select id="filter-category" class="select">
        <option value="">Todas as categorias</option>
        <optgroup label="Receitas">
          ${state.categories.income.map(cat => `<option value="${cat.id}">${cat.icon || ''} ${cat.name}</option>`).join('')}
        </optgroup>
        <optgroup label="Despesas">
          ${state.categories.expense.map(cat => `<option value="${cat.id}">${cat.icon || ''} ${cat.name}</option>`).join('')}
        </optgroup>
      </select>
      <svg class="select-icon" width="16" height="16">
        <use href="#icon-chevron-down"></use>
      </svg>
    `;

    // Filtro de status
    const statusSelect = document.createElement('div');
    statusSelect.className = 'select-wrapper';
    statusSelect.innerHTML = `
      <select id="filter-status" class="select">
        <option value="">Todos os status</option>
        <option value="paid">Pagos</option>
        <option value="pending">Pendentes</option>
        <option value="scheduled">Agendados</option>
        <option value="received">Recebidos</option>
      </select>
      <svg class="select-icon" width="16" height="16">
        <use href="#icon-chevron-down"></use>
      </svg>
    `;

    // Filtro de forma de pagamento
    const paymentMethodSelect = document.createElement('div');
    paymentMethodSelect.className = 'select-wrapper';
    paymentMethodSelect.innerHTML = `
      <select id="filter-payment-method" class="select">
        <option value="">Todas as formas de pagamento</option>
        ${state.paymentMethods.map(method => `<option value="${method.id}">${method.icon || ''} ${method.name}</option>`).join('')}
      </select>
      <svg class="select-icon" width="16" height="16">
        <use href="#icon-chevron-down"></use>
      </svg>
    `;

    // AJUSTE 7: Filtro de pessoa
    const personSelect = document.createElement('div');
    personSelect.className = 'select-wrapper';
    personSelect.innerHTML = `
      <select id="filter-person" class="select">
        <option value="">Todas as pessoas</option>
        ${state.people.map(person => `<option value="${person.id}">${person.icon || ''} ${person.name}</option>`).join('')}
      </select>
      <svg class="select-icon" width="16" height="16">
        <use href="#icon-chevron-down"></use>
      </svg>
    `;

    // Adicionar filtros ao container
    filtersContainer.appendChild(categorySelect);
    filtersContainer.appendChild(statusSelect);
    filtersContainer.appendChild(paymentMethodSelect);
    filtersContainer.appendChild(personSelect);

    // Atualizar ao mudar os filtros
    $('#filter-category').addEventListener('change', e => {
      state.filters.category = e.target.value;
      updateTransactionsTable();
    });

    $('#filter-status').addEventListener('change', e => {
      state.filters.status = e.target.value;
      updateTransactionsTable();
    });

    $('#filter-payment-method').addEventListener('change', e => {
      state.filters.paymentMethod = e.target.value;
      updateTransactionsTable();
    });

    $('#filter-person').addEventListener('change', e => {
      state.filters.person = e.target.value;
      updateTransactionsTable();
    });
    
    // Problema #8: Adicionar filtro por tipo de transação
    // Configurar os botões de filtro por tipo
    const typeFilterBtns = $$('#transactionTypeFilter .btn');
    typeFilterBtns.forEach(btn => {
      btn.addEventListener('click', e => {
        // Remover classe active de todos os botões
        typeFilterBtns.forEach(b => b.classList.remove('active'));
        
        // Adicionar classe active ao botão clicado
        e.target.classList.add('active');
        
        // Definir o filtro por tipo
        state.filters.type = e.target.dataset.type;
        
        // Atualizar a tabela
        updateTransactionsTable();
      });
    });
  };

  // AJUSTE 11: Adicionar ordenação aos cabeçalhos da tabela sem setas
  const setupSortableColumns = () => {
    const headers = $$('.sortable');
    
    headers.forEach(header => {
      header.addEventListener('click', () => {
        const column = header.dataset.sort;
        
        // Se já está selecionada, inverter a direção
        if (column === state.sortColumn) {
          state.sortDirection = state.sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          state.sortColumn = column;
          state.sortDirection = 'asc';
        }
        
        // Destacar visual da coluna ordenada
        $$('.sortable').forEach(h => {
          h.classList.remove('sorted-asc', 'sorted-desc');
        });
        
        header.classList.add(`sorted-${state.sortDirection}`);
        
        // Atualizar a tabela
        updateTransactionsTable();
      });
    });
  };

  // AJUSTE 11, 15: Atualizar a tabela de transações com coluna de pessoas
  // Problema #18: Remover colunas desnecessárias da tela de Transações
  const updateTransactionsTable = () => {
    const tableBody = $('#transactionsTableBody');
    if (!tableBody) return;

    // Criar filtros se ainda não existirem
    if (!$('#filter-category')) {
      createTransactionFilters();
    }

    // Configurar colunas ordenáveis se ainda não estiverem
    if (!$('.sortable')?.classList.contains('has-listener')) {
      setupSortableColumns();
      // Adicionar classe para evitar reinicialização
      $$('.sortable').forEach(header => header.classList.add('has-listener'));
    }

    tableBody.innerHTML = '';

    // Aplicar filtros
    let transactions = [...state.filteredTransactions];

    // Problema #8: Filtrar por tipo de transação
    if (state.filters.type && state.filters.type !== 'all') {
      transactions = transactions.filter(t => t.type === state.filters.type);
    }

    if (state.filters.category) {
      transactions = transactions.filter(t => t.category === state.filters.category);
    }

    if (state.filters.status) {
      transactions = transactions.filter(t => t.status === state.filters.status);
    }

    if (state.filters.paymentMethod) {
      transactions = transactions.filter(t => t.paymentMethod === state.filters.paymentMethod);
    }

    // AJUSTE 7: Filtrar por pessoa
    if (state.filters.person) {
      transactions = transactions.filter(t => t.person === state.filters.person);
    }

    // Ordenar transações
    transactions.sort((a, b) => {
      let valueA, valueB;

      // Determinar os valores a comparar com base na coluna
      switch(state.sortColumn) {
        case 'name':
          valueA = a.name.toLowerCase();
          valueB = b.name.toLowerCase();
          break;
        case 'category':
          valueA = (a.categoryName || a.category || '').toLowerCase();
          valueB = (b.categoryName || b.category || '').toLowerCase();
          break;
        case 'person':
          valueA = a.person || '';
          valueB = b.person || '';
          break;
        case 'date':
          valueA = parseLocalDateString(a.date);
          valueB = parseLocalDateString(b.date);
          break;
        case 'dueDate':
          // Se não houver data de vencimento, usar uma data muito antiga ou muito recente
          valueA = a.dueDate ? parseLocalDateString(a.dueDate) : new Date(0);
          valueB = b.dueDate ? parseLocalDateString(b.dueDate) : new Date(0);
          break;
        case 'amount':
          valueA = parseFloat(a.amount);
          valueB = parseFloat(b.amount);
          break;
        case 'status':
          valueA = a.status;
          valueB = b.status;
          break;
        case 'paymentMethod':
          valueA = (a.paymentMethodName || a.paymentMethod || '').toLowerCase();
          valueB = (b.paymentMethodName || b.paymentMethod || '').toLowerCase();
          break;
        case 'isFixed':
          valueA = a.isFixed || '';
          valueB = b.isFixed || '';
          break;
        default:
          valueA = parseLocalDateString(a.date);
          valueB = parseLocalDateString(b.date);
      }

      // Comparar os valores
      let comparison = 0;
      if (valueA < valueB) {
        comparison = -1;
      } else if (valueA > valueB) {
        comparison = 1;
      }

      // Inverter se a direção for descendente
      return state.sortDirection === 'desc' ? -comparison : comparison;
    });

    if (transactions.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = `
        <td colspan="12" style="text-align: center; padding: var(--spacing-xl);">
          Nenhuma transação para este período ou filtro.
        </td>
      `;
      tableBody.appendChild(emptyRow);
      return;
    }

    // Problema #18: Remover colunas desnecessárias
    // Define quais colunas devem estar visíveis ou ocultas
    const iconColumn = $('th:first-child');
    const categoryColumn = $('th[data-sort="category"]');
    const typeColumn = $('th[data-sort="isFixed"]');
    
    if (iconColumn) iconColumn.classList.add('table-column-hide');
    if (categoryColumn) categoryColumn.classList.add('table-column-hide');
    if (typeColumn) typeColumn.classList.add('table-column-hide');

    transactions.forEach(transaction => {
      const row = document.createElement('tr');

      // Determinar cor do ícone
      const iconBgColor = transaction.type === 'income' 
        ? 'rgba(52, 199, 89, 0.1)'
        : 'rgba(255, 59, 48, 0.1)';

      const iconColor = transaction.type === 'income'
        ? 'var(--color-income)'
        : 'var(--color-expense)';

      // Obter nome da categoria
      // Problema #9: Corrigir nomes de categorias distorcidos 
      const categoryName = transaction.categoryName || transaction.category || '-';

      // Formatar status
      let statusText = '';
      let statusClass = '';

      if (transaction.type === 'income') {
        if (transaction.status === 'received') {
          statusText = 'Recebido';
          statusClass = 'badge-success';
        } else {
          statusText = 'A Receber';
          statusClass = 'badge-warning';
        }
      } else {
        if (transaction.status === 'paid') {
          statusText = 'Pago';
          statusClass = 'badge-success';
        } else if (transaction.status === 'scheduled') {
          statusText = 'Agendado';
          statusClass = 'badge-info';
        } else {
          statusText = 'Pendente';
          statusClass = 'badge-warning';
        }
      }

      // Instalamentos, se aplicável
      let installmentText = '';
      if (transaction.isRecurrent && transaction.installments > 1) {
        installmentText = ` (${transaction.installmentNumber || 1}/${transaction.installments})`;
      }

      // AJUSTE 15: Pessoa associada, se houver
      const personInfo = transaction.person ? 
        state.people.find(p => p.id === transaction.person) : null;

      // AJUSTE 16: Tipo de despesa (fixa/variável)
      let typeText = '';
      if (transaction.type === 'expense') {
        typeText = transaction.isFixed === 'fixed' ? 'Fixa' : 'Variável';
      }
      
      // Problema #14: Melhorar a visualização de texto na tela de Transações
      // Problema #3: Exibir a data correta de vencimento nas transações
      let dueDate = transaction.dueDate ? formatDate(transaction.dueDate) : '-';
      
      // Para cartões de crédito, exibir a data de vencimento do cartão
      if (transaction.type === 'expense' && transaction.paymentMethod === 'credito' && transaction.creditCardId) {
        const card = state.cards.find(c => c.id === transaction.creditCardId);
          if (card) {
            const vencimento = calcularVencimentoReal(parseLocalDateString(transaction.date), card);
            if (vencimento) {
              dueDate = formatDate(vencimento);
            }
          }
        }
      }

      row.innerHTML = `
        <td class="table-column-hide">
          <div class="transaction-icon" style="background-color: ${iconBgColor}; color: ${iconColor};">
            ${transaction.categoryIcon || (transaction.type === 'income' ? '💰' : '📦')}
          </div>
        </td>
        <td>${transaction.name}${installmentText}</td>
        <td class="table-column-hide">${categoryName}</td>
        <td>${personInfo ? `${personInfo.icon || ''} ${personInfo.name}` : '-'}</td>
        <td>${formatDate(transaction.date)}</td>
        <td>${dueDate}</td>
        <td style="text-align: right; white-space: nowrap;">${formatCurrency(transaction.amount)}</td>
        <td><span class="badge ${statusClass}">${statusText}</span></td>
        <td>${transaction.paymentMethodName || transaction.paymentMethod || '-'}</td>
        <td class="table-column-hide">${typeText}</td>
        <td>
          <div class="checkbox-wrapper">
            <input type="checkbox" class="checkbox transaction-paid-checkbox" id="transaction-paid-${transaction.id}" 
                  ${transaction.status === 'paid' || transaction.status === 'received' ? 'checked' : ''}
                  data-id="${transaction.id}"
                  data-type="${transaction.type}">
            <label class="checkbox-label" for="transaction-paid-${transaction.id}"></label>
          </div>
        </td>
        <td>
          <div class="actions-cell">
            <button class="btn btn-icon btn-outline edit-transaction-btn" data-id="${transaction.id}">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-transaction-btn" data-id="${transaction.id}">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        </td>
      `;

      tableBody.appendChild(row);
    });

    // Adicionar event listeners para os checkboxes de pagamento
    $$('.transaction-paid-checkbox').forEach(checkbox => {
      checkbox.addEventListener('change', e => {
        const id = e.target.dataset.id;
        const type = e.target.dataset.type;
        const status = e.target.checked 
          ? (type === 'income' ? 'received' : 'paid')
          : (type === 'income' ? 'pending' : 'pending');
        
        updateTransactionStatus(id, status);
      });
    });

    // Adicionar event listeners para os botões de edição
    $$('.edit-transaction-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const id = e.currentTarget.dataset.id;
        const transaction = state.transactions.find(t => t.id === id);
        
        if (transaction) {
          openEditTransactionModal(transaction);
        }
      });
    });

    // Adicionar event listeners para os botões de exclusão
    $$('.delete-transaction-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const id = e.currentTarget.dataset.id;
        const transaction = state.transactions.find(t => t.id === id);
        
        if (transaction) {
          openDeleteConfirmModal(transaction);
        }
      });
    });
  };

  // Funções para manipulação de transações
  const addTransaction = async (transactionData, isRecurrent = false) => {
    try {
      if (isRecurrent && transactionData.installments > 1) {
        // Configurações para recorrência
        const recurrenceId = generateId();
        const baseDate = parseLocalDateString(transactionData.date);
        
        // Problema #13: Corrigir cálculo de despesas parceladas
        // Dividir o valor total pelo número de parcelas
        const singleAmount = parseFloat(transactionData.amount) / parseInt(transactionData.installments);
        
        const batch = db.batch();
        
        // Criar transações recorrentes
        for (let i = 0; i < transactionData.installments; i++) {
          // Calcular data para parcela atual
          const installmentDate = new Date(baseDate);
          installmentDate.setMonth(baseDate.getMonth() + i);
          
          // Calcular data de vencimento para parcela atual
          let installmentDueDate = null;
          if (transactionData.type === 'expense' && transactionData.dueDate) {
            installmentDueDate = new Date(parseLocalDateString(transactionData.dueDate));
            installmentDueDate.setMonth(installmentDueDate.getMonth() + i);
          }
          
          // Criar objeto da transação
          const installment = {
            ...transactionData,
            date: localDateToISOString(installmentDate),
            dueDate: installmentDueDate ? localDateToISOString(installmentDueDate) : null,
            amount: singleAmount.toFixed(2), // Problema #13: Valor corrigido por parcela
            isRecurrent: true,
            recurrenceId: recurrenceId,
            installmentNumber: i + 1,
            createdAt: new Date().toISOString()
          };
          
          // Salvar no Firestore
          const docRef = db.collection('transactions').doc();
          batch.set(docRef, installment);
          
          // Adicionar ao estado local
          const transactionWithId = { id: docRef.id, ...installment };
          state.transactions.push(transactionWithId);
          
          // Atualizar limite disponível do cartão, se for despesa no cartão de crédito
          if (installment.type === 'expense' && installment.paymentMethod === 'credito' && installment.creditCardId) {
            const card = state.cards.find(c => c.id === installment.creditCardId);
            
            if (card) {
              // Problema #5: Corrigir o cálculo de limite disponível do cartão
              // Adicionar o valor da parcela à fatura atual
              const currentInvoice = (card.currentInvoice || 0) + parseFloat(installment.amount);
              // Atualizar limite disponível: Limite Total - Fatura Atual
              const availableLimit = card.limit - currentInvoice;
              
              // Atualizar no Firestore
              const cardRef = db.collection('cards').doc(card.id);
              batch.update(cardRef, { 
                currentInvoice: currentInvoice,
                availableLimit: availableLimit
              });
              
              // Atualizar no estado local
              card.currentInvoice = currentInvoice;
              card.availableLimit = availableLimit;
            }
          }
        }
        
        await batch.commit();
      } else {
        // Transação única (não recorrente)
        const transaction = {
          ...transactionData,
          isRecurrent: false,
          createdAt: new Date().toISOString()
        };
        
        // Salvar no Firestore
        const docRef = await db.collection('transactions').add(transaction);
        
        // Adicionar ao estado local
        const transactionWithId = { id: docRef.id, ...transaction };
        state.transactions.push(transactionWithId);
        
        // Atualizar limite disponível do cartão, se for despesa no cartão de crédito
        if (transaction.type === 'expense' && transaction.paymentMethod === 'credito' && transaction.creditCardId) {
          const card = state.cards.find(c => c.id === transaction.creditCardId);
          
          if (card) {
            // Problema #5: Corrigir o cálculo de limite disponível do cartão
            // Adicionar o valor à fatura atual
            const currentInvoice = (card.currentInvoice || 0) + parseFloat(transaction.amount);
            // Atualizar limite disponível: Limite Total - Fatura Atual
            const availableLimit = card.limit - currentInvoice;
            
            // Atualizar no Firestore
            await db.collection('cards').doc(card.id).update({
              currentInvoice: currentInvoice,
              availableLimit: availableLimit
            });
            
            // Atualizar no estado local
            card.currentInvoice = currentInvoice;
            card.availableLimit = availableLimit;
          }
        }
      }
      
      // Problema #17: Corrigir falha de atualização automática após lançamentos
      // Atualizar a UI
      filterTransactionsByMonth();
      updateKPIs();
      updateCharts();
      renderCommitments();
      generateInsights();
      updateCardsList();
      updateCreditCardSelects();
      
      showToast(
        `${transactionData.type === 'income' ? 'Receita' : 'Despesa'} adicionada com sucesso!`,
        'success'
      );
      
      return true;
    } catch (error) {
      console.error(`Erro ao adicionar ${transactionData.type === 'income' ? 'receita' : 'despesa'}:`, error);
      showToast(`Erro ao adicionar ${transactionData.type === 'income' ? 'receita' : 'despesa'}. Tente novamente.`, 'error');
      return false;
    }
  };

  const updateTransaction = async (transactionId, updates) => {
    try {
      const transaction = state.transactions.find(t => t.id === transactionId);
      if (!transaction) {
        showToast('Transação não encontrada', 'error');
        return false;
      }
      
      // Atualizar no Firestore
      await db.collection('transactions').doc(transactionId).update(updates);
      
      // Atualizar no estado local
      const index = state.transactions.findIndex(t => t.id === transactionId);
      
      if (index !== -1) {
        state.transactions[index] = { ...state.transactions[index], ...updates };
      }
      
      // Problema #17: Corrigir falha de atualização automática após lançamentos
      // Atualizar a UI
      filterTransactionsByMonth();
      updateKPIs();
      updateCharts();
      renderCommitments();
      generateInsights();
      
      return true;
      
    } catch (error) {
      console.error('Erro ao atualizar transação:', error);
      showToast('Erro ao atualizar transação. Tente novamente.', 'error');
      return false;
    }
  };

  // Simplificado para atualizar apenas o status
  const updateTransactionStatus = async (transactionId, status) => {
    try {
      await updateTransaction(transactionId, { status });
      showToast('Status atualizado com sucesso!', 'success');
      return true;
    } catch (error) {
      console.error('Erro ao atualizar status:', error);
      showToast('Erro ao atualizar status. Tente novamente.', 'error');
      return false;
    }
  };

  const deleteTransaction = async (transactionId, deleteOption = 'single') => {
    try {
      const transaction = state.transactions.find(t => t.id === transactionId);
      
      if (!transaction) {
        showToast('Transação não encontrada', 'error');
        return false;
      }
      
      if (transaction.isRecurrent && deleteOption === 'future') {
        // Excluir todas as parcelas futuras (incluindo a atual)
        const recurrenceId = transaction.recurrenceId;
        const installmentNumber = transaction.installmentNumber;
        
        // Identificar parcelas a excluir
        const installmentsToDelete = state.transactions.filter(t => 
          t.recurrenceId === recurrenceId && 
          t.installmentNumber >= installmentNumber
        );
        
        // Criar batch para excluir todas as parcelas
        const batch = db.batch();
        
        for (const installment of installmentsToDelete) {
          const docRef = db.collection('transactions').doc(installment.id);
          batch.delete(docRef);
          
          // Se for despesa de cartão de crédito, atualizar limite disponível
          if (installment.type === 'expense' && installment.paymentMethod === 'credito' && installment.creditCardId) {
            const card = state.cards.find(c => c.id === installment.creditCardId);
            
            if (card && installment.status !== 'paid') {
              // Problema #5: Corrigir o cálculo de limite disponível do cartão
              // Remover o valor da parcela da fatura atual
              const currentInvoice = Math.max(0, (card.currentInvoice || 0) - parseFloat(installment.amount));
              // Atualizar limite disponível: Limite Total - Fatura Atual
              const availableLimit = card.limit - currentInvoice;
              
              // Atualizar card no Firestore
              const cardRef = db.collection('cards').doc(card.id);
              batch.update(cardRef, { 
                currentInvoice: currentInvoice,
                availableLimit: availableLimit
              });
              
              // Atualizar no estado local
              card.currentInvoice = currentInvoice;
              card.availableLimit = availableLimit;
            }
          }
        }
        
        await batch.commit();
        
        // Atualizar estado local
        state.transactions = state.transactions.filter(t => 
          !(t.recurrenceId === recurrenceId && t.installmentNumber >= installmentNumber)
        );
        
      } else {
        // Excluir apenas a transação atual
        await db.collection('transactions').doc(transactionId).delete();
        
        // Se for despesa de cartão de crédito, atualizar limite disponível
        if (transaction.type === 'expense' && transaction.paymentMethod === 'credito' && transaction.creditCardId) {
          const card = state.cards.find(c => c.id === transaction.creditCardId);
          
          if (card && transaction.status !== 'paid') {
            // Problema #5: Corrigir o cálculo de limite disponível do cartão
            // Remover o valor da fatura atual
            const currentInvoice = Math.max(0, (card.currentInvoice || 0) - parseFloat(transaction.amount));
            // Atualizar limite disponível: Limite Total - Fatura Atual
            const availableLimit = card.limit - currentInvoice;
            
            // Atualizar no Firestore
            await db.collection('cards').doc(card.id).update({
              currentInvoice: currentInvoice,
              availableLimit: availableLimit
            });
            
            // Atualizar no estado local
            card.currentInvoice = currentInvoice;
            card.availableLimit = availableLimit;
          }
        }
        
        // Atualizar estado local
        state.transactions = state.transactions.filter(t => t.id !== transactionId);
      }
      
      // Problema #17: Corrigir falha de atualização automática após lançamentos
      // Atualizar a UI
      filterTransactionsByMonth();
      updateKPIs();
      updateCharts();
      renderCommitments();
      generateInsights();
      updateCardsList();
      updateCreditCardSelects();
      
      showToast('Transação excluída com sucesso!', 'success');
      return true;
      
    } catch (error) {
      console.error('Erro ao excluir transação:', error);
      showToast('Erro ao excluir transação. Tente novamente.', 'error');
      return false;
    }
  };

  // AJUSTE 11: Função para abrir modal de edição de transação melhorada
  const openEditTransactionModal = (transaction) => {
    state.currentTransaction = transaction;
    
    // Determinar título do modal
    const modalTitle = transaction.type === 'income' ? 'Editar Receita' : 'Editar Despesa';
    $('#editModalTitle').textContent = modalTitle;
    
    // Preencher campos do formulário
    $('#editTransactionId').value = transaction.id;
    $('#editTransactionType').value = transaction.type;
    $('#editName').value = transaction.name;
    $('#editAmount').value = transaction.amount;
    
    // Configurar o select de categoria com base no tipo
    const categorySelect = $('#editCategory');
    categorySelect.innerHTML = '';
    
    if (transaction.type === 'income') {
      categorySelect.dataset.type = 'income';
      state.categories.income.forEach(category => {
        const option = document.createElement('option');
        option.value = category.id;
        option.textContent = `${category.icon || ''} ${category.name}`;
        option.selected = category.id === transaction.category;
        categorySelect.appendChild(option);
      });
    } else {
      categorySelect.dataset.type = 'expense';
      state.categories.expense.forEach(category => {
        const option = document.createElement('option');
        option.value = category.id;
        option.textContent = `${category.icon || ''} ${category.name}`;
        option.selected = category.id === transaction.category;
        categorySelect.appendChild(option);
      });
    }
    
    // Preencher data de lançamento
    if (transaction.date) {
      setDateInputValue('editDate', transaction.date);
    }
    
    // Preencher data de vencimento (apenas para despesas)
    const dueDateGroup = $('#editDueDateGroup');
    if (transaction.type === 'expense') {
      dueDateGroup.style.display = 'block';
      if (transaction.dueDate) {
        setDateInputValue('editDueDate', transaction.dueDate);
      }
    } else {
      dueDateGroup.style.display = 'none';
    }
    
    // Configurar forma de pagamento
    const paymentMethodSelect = $('#editPaymentMethod');
    paymentMethodSelect.innerHTML = '';
    
    state.paymentMethods.forEach(method => {
      const option = document.createElement('option');
      option.value = method.id;
      option.textContent = `${method.icon || ''} ${method.name}`;
      option.selected = method.id === transaction.paymentMethod;
      paymentMethodSelect.appendChild(option);
    });
    
    // Configurar cartão de crédito (se aplicável)
    const creditCardGroup = $('#editCreditCardGroup');
    if (transaction.type === 'expense' && transaction.paymentMethod === 'credito') {
      creditCardGroup.style.display = 'block';
      
      const creditCardSelect = $('#editCreditCard');
      creditCardSelect.innerHTML = '';
      
      state.cards.forEach(card => {
        const option = document.createElement('option');
        option.value = card.id;
        // Problema #4: Exibir o Limite Disponível ao lançar despesa no cartão
        option.textContent = `${card.name} (Disp: ${formatCurrency(card.availableLimit)})`;
        option.selected = card.id === transaction.creditCardId;
        creditCardSelect.appendChild(option);
      });
    } else {
      creditCardGroup.style.display = 'none';
    }
    
    // Configurar tipo de despesa (fixa/variável)
    const expenseTypeGroup = $('#editExpenseTypeGroup');
    if (transaction.type === 'expense') {
      expenseTypeGroup.style.display = 'block';
      if (transaction.isFixed === 'fixed') {
        $('#editExpenseTypeFixed').checked = true;
      } else {
        $('#editExpenseTypeVariable').checked = true;
      }
    } else {
      expenseTypeGroup.style.display = 'none';
    }
    
    // Configurar pessoa
    const personSelect = $('#editPerson');
    personSelect.value = transaction.person || '';
    
    // Configurar recorrência
    $('#editIsRecurrent').checked = transaction.isRecurrent;
    const recurrenceGroup = $('#editRecurrenceGroup');
    
    if (transaction.isRecurrent) {
      recurrenceGroup.style.display = 'block';
      $('#editInstallments').value = transaction.installments || 2;
    } else {
      recurrenceGroup.style.display = 'none';
    }
    
    // Configurar status
    const statusGroup = $('#editStatusGroup');
    statusGroup.innerHTML = '';
    
    if (transaction.type === 'income') {
      statusGroup.innerHTML = `
        <div class="radio-wrapper">
          <input type="radio" class="radio" id="editStatusReceived" name="editStatus" value="received" ${transaction.status === 'received' ? 'checked' : ''}>
          <label class="radio-label" for="editStatusReceived">
            <span class="radio-circle"></span>
            Recebido
          </label>
        </div>
        
        <div class="radio-wrapper">
          <input type="radio" class="radio" id="editStatusPending" name="editStatus" value="pending" ${transaction.status === 'pending' ? 'checked' : ''}>
          <label class="radio-label" for="editStatusPending">
            <span class="radio-circle"></span>
            A Receber
          </label>
        </div>
      `;
    } else {
      statusGroup.innerHTML = `
        <div class="radio-wrapper">
          <input type="radio" class="radio" id="editStatusPaid" name="editStatus" value="paid" ${transaction.status === 'paid' ? 'checked' : ''}>
          <label class="radio-label" for="editStatusPaid">
            <span class="radio-circle"></span>
            Pago
          </label>
        </div>
        
        <div class="radio-wrapper">
          <input type="radio" class="radio" id="editStatusPending" name="editStatus" value="pending" ${transaction.status === 'pending' ? 'checked' : ''}>
          <label class="radio-label" for="editStatusPending">
            <span class="radio-circle"></span>
            Pendente
          </label>
        </div>
        
        <div class="radio-wrapper">
          <input type="radio" class="radio" id="editStatusScheduled" name="editStatus" value="scheduled" ${transaction.status === 'scheduled' ? 'checked' : ''}>
          <label class="radio-label" for="editStatusScheduled">
            <span class="radio-circle"></span>
            Agendado
          </label>
        </div>
      `;
    }
    
    // Configurar data de agendamento (se aplicável)
    const scheduledDateGroup = $('#editScheduledDateGroup');
    if (transaction.status === 'scheduled') {
      scheduledDateGroup.style.display = 'block';
      if (transaction.scheduledDate) {
        setDateInputValue('editScheduledDate', transaction.scheduledDate);
      }
    } else {
      scheduledDateGroup.style.display = 'none';
    }
    
    // Preencher notas
    $('#editNotes').value = transaction.notes || '';
    
    // Esconder grupo de status para Cartão de Crédito ou despesa recorrente
    // Problema #2: Ocultar e preencher automaticamente o campo Status
    if (transaction.type === 'expense' && 
        (transaction.paymentMethod === 'credito' || transaction.isRecurrent)) {
      $('#editStatusGroup').closest('.form-group').style.display = 'none';
    } else {
      $('#editStatusGroup').closest('.form-group').style.display = 'block';
    }
    
    // Configurar event listeners para status de agendamento
    $$('input[name="editStatus"]').forEach(radio => {
      radio.addEventListener('change', e => {
        if (e.target.value === 'scheduled') {
          scheduledDateGroup.style.display = 'block';
        } else {
          scheduledDateGroup.style.display = 'none';
        }
      });
    });
    
    // Atualizar campos ao alterar forma de pagamento
    $('#editPaymentMethod').addEventListener('change', e => {
      const paymentMethod = e.target.value;
      
      // Problema #16: Corrigir retorno da tela ao mudar a forma de pagamento
      if (paymentMethod === 'credito') {
        creditCardGroup.style.display = 'block';
        
        // Problema #2: Ocultar e preencher automaticamente o campo Status
        if (transaction.type === 'expense') {
          $('#editStatusGroup').closest('.form-group').style.display = 'none';
        }
      } else {
        creditCardGroup.style.display = 'none';
        
        // Problema #16: Corrigir retorno da tela ao mudar a forma de pagamento
        // Restaurar exibição do grupo de status quando não for cartão de crédito
        if (transaction.type === 'expense' && !transaction.isRecurrent) {
          $('#editStatusGroup').closest('.form-group').style.display = 'block';
        }
      }
    });
    
    // Atualizar campos ao alterar recorrência
    $('#editIsRecurrent').addEventListener('change', e => {
      if (e.target.checked) {
        recurrenceGroup.style.display = 'block';
        
        // Problema #2: Ocultar e preencher automaticamente o campo Status
        if (transaction.type === 'expense') {
          $('#editStatusGroup').closest('.form-group').style.display = 'none';
        }
      } else {
        recurrenceGroup.style.display = 'none';
        
        // Restaurar exibição do grupo de status quando não for recorrente e não for cartão
        if (transaction.type === 'expense' && $('#editPaymentMethod').value !== 'credito') {
          $('#editStatusGroup').closest('.form-group').style.display = 'block';
        }
      }
    });
    
    // Abrir o modal
    openModal('editModal');
  };

  // Função para abrir confirmação de exclusão
  const openDeleteConfirmModal = (transaction) => {
    state.currentTransaction = transaction;
    
    // Verificar se é transação recorrente
    const recurrenceOptions = $('#recurrenceDeleteOptions');
    
    if (transaction.isRecurrent && transaction.installments > transaction.installmentNumber) {
      recurrenceOptions.style.display = 'block';
    } else {
      recurrenceOptions.style.display = 'none';
    }
    
    // Abrir o modal
    openModal('deleteConfirmModal');
  };

  // Função para carregar e renderizar categorias
  const renderCategoriesList = () => {
    // Categorias de receita
    const incomeCategoriesList = $('#incomeCategoriesList');
    if (incomeCategoriesList) {
      incomeCategoriesList.innerHTML = '';
      
      state.categories.income.forEach(category => {
        const item = document.createElement('div');
        item.className = 'category-item';
        item.dataset.id = category.id;
        item.dataset.type = 'income';
        
        item.innerHTML = `
          <div class="category-item-content">
            <div class="category-item-icon">
              ${category.icon || '💰'}
            </div>
            <div>${category.name}</div>
          </div>
          <div class="category-item-actions">
            <button class="btn btn-icon btn-outline edit-category-btn">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-category-btn">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        `;
        
        incomeCategoriesList.appendChild(item);
      });
    }
    
    // Categorias de despesa
    const expenseCategoriesList = $('#expenseCategoriesList');
    if (expenseCategoriesList) {
      expenseCategoriesList.innerHTML = '';
      
      state.categories.expense.forEach(category => {
        const item = document.createElement('div');
        item.className = 'category-item';
        item.dataset.id = category.id;
        item.dataset.type = 'expense';
        
        item.innerHTML = `
          <div class="category-item-content">
            <div class="category-item-icon">
              ${category.icon || '📦'}
            </div>
            <div>${category.name}</div>
          </div>
          <div class="category-item-actions">
            <button class="btn btn-icon btn-outline edit-category-btn">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-category-btn">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        `;
        
        expenseCategoriesList.appendChild(item);
      });
    }
    
    // Adicionar event listeners para botões de edição e exclusão
    $$('.edit-category-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        e.stopPropagation();
        const item = e.target.closest('.category-item');
        const id = item.dataset.id;
        const type = item.dataset.type;
        const category = type === 'income' 
          ? state.categories.income.find(c => c.id === id)
          : type === 'expense'
            ? state.categories.expense.find(c => c.id === id)
            : state.categories.investment.find(c => c.id === id);
        
        if (category) {
          openEditCategoryModal(category, type);
        }
      });
    });
    
    $$('.delete-category-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        e.stopPropagation();
        const item = e.target.closest('.category-item');
        const id = item.dataset.id;
        const type = item.dataset.type;
        
        // Verificar se há transações utilizando esta categoria
        const hasTransactions = state.transactions.some(t => t.category === id);
        
        if (hasTransactions) {
          showToast('Não é possível excluir esta categoria pois existem transações vinculadas a ela.', 'error');
          return;
        }
        
        if (confirm('Deseja realmente excluir esta categoria? Esta ação é irreversível.')) {
          deleteCategory(id, type);
        }
      });
    });
  };

  // Renderizar categorias de investimento
  const renderInvestmentCategoriesList = () => {
    const investmentCategoriesList = $('#investmentCategoriesList');
    if (investmentCategoriesList) {
      investmentCategoriesList.innerHTML = '';
      
      state.categories.investment.forEach(category => {
        const item = document.createElement('div');
        item.className = 'category-item';
        item.dataset.id = category.id;
        item.dataset.type = 'investment';
        
        item.innerHTML = `
          <div class="category-item-content">
            <div class="category-item-icon">
              ${category.icon || '📊'}
            </div>
            <div>${category.name}</div>
          </div>
          <div class="category-item-actions">
            <button class="btn btn-icon btn-outline edit-category-btn">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-category-btn">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        `;
        
        investmentCategoriesList.appendChild(item);
      });
      
      // Adicionar event listeners
      const editButtons = investmentCategoriesList.querySelectorAll('.edit-category-btn');
      const deleteButtons = investmentCategoriesList.querySelectorAll('.delete-category-btn');
      
      editButtons.forEach(btn => {
        btn.addEventListener('click', e => {
          e.stopPropagation();
          const item = e.target.closest('.category-item');
          const id = item.dataset.id;
          const type = item.dataset.type;
          const category = state.categories.investment.find(c => c.id === id);
          
          if (category) {
            openEditCategoryModal(category, type);
          }
        });
      });
      
      deleteButtons.forEach(btn => {
        btn.addEventListener('click', e => {
          e.stopPropagation();
          const item = e.target.closest('.category-item');
          const id = item.dataset.id;
          const type = item.dataset.type;
          
          // Verificar se há investimentos utilizando esta categoria
          const hasInvestments = state.investments.some(i => i.category === id);
          
          if (hasInvestments) {
            showToast('Não é possível excluir esta categoria pois existem investimentos vinculados a ela.', 'error');
            return;
          }
          
          if (confirm('Deseja realmente excluir esta categoria? Esta ação é irreversível.')) {
            deleteCategory(id, type);
          }
        });
      });
    }
  };

  // Renderizar formas de pagamento
  const renderPaymentMethodsList = () => {
    const paymentMethodsList = $('#paymentMethodsList');
    if (paymentMethodsList) {
      paymentMethodsList.innerHTML = '';
      
      state.paymentMethods.forEach(method => {
        const item = document.createElement('div');
        item.className = 'category-item';
        item.dataset.id = method.id;
        
        item.innerHTML = `
          <div class="category-item-content">
            <div class="category-item-icon">
              ${method.icon || '💵'}
            </div>
            <div>${method.name}</div>
          </div>
          <div class="category-item-actions">
            <button class="btn btn-icon btn-outline edit-payment-method-btn">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-payment-method-btn">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        `;
        
        paymentMethodsList.appendChild(item);
      });
      
      // Adicionar event listeners
      $$('.edit-payment-method-btn').forEach(btn => {
        btn.addEventListener('click', e => {
          e.stopPropagation();
          const item = e.target.closest('.category-item');
          const id = item.dataset.id;
          const method = state.paymentMethods.find(m => m.id === id);
          
          if (method) {
            openEditPaymentMethodModal(method);
          }
        });
      });
      
      $$('.delete-payment-method-btn').forEach(btn => {
        btn.addEventListener('click', e => {
          e.stopPropagation();
          const item = e.target.closest('.category-item');
          const id = item.dataset.id;
          
          // Verificar se há transações utilizando este método de pagamento
          const hasTransactions = state.transactions.some(t => t.paymentMethod === id);
          
          if (hasTransactions) {
            showToast('Não é possível excluir esta forma de pagamento pois existem transações vinculadas a ela.', 'error');
            return;
          }
          
          if (confirm('Deseja realmente excluir esta forma de pagamento? Esta ação é irreversível.')) {
            deletePaymentMethod(id);
          }
        });
      });
    }
  };

  // Renderizar lista de pessoas
  const updatePeopleList = () => {
    const peopleList = $('#peopleList');
    if (peopleList) {
      peopleList.innerHTML = '';
      
      state.people.forEach(person => {
        const item = document.createElement('div');
        item.className = 'category-item';
        item.dataset.id = person.id;
        
        item.innerHTML = `
          <div class="category-item-content">
            <div class="category-item-icon">
              ${person.icon || '👤'}
            </div>
            <div>${person.name}</div>
          </div>
          <div class="category-item-actions">
            <button class="btn btn-icon btn-outline edit-person-btn">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-person-btn">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        `;
        
        peopleList.appendChild(item);
      });
      
      // Adicionar event listeners
      $$('.edit-person-btn').forEach(btn => {
        btn.addEventListener('click', e => {
          e.stopPropagation();
          const item = e.target.closest('.category-item');
          const id = item.dataset.id;
          const person = state.people.find(p => p.id === id);
          
          if (person) {
            openEditPersonModal(person);
          }
        });
      });
      
      $$('.delete-person-btn').forEach(btn => {
        btn.addEventListener('click', e => {
          e.stopPropagation();
          const item = e.target.closest('.category-item');
          const id = item.dataset.id;
          
          // Verificar se há transações utilizando esta pessoa
          const hasTransactions = state.transactions.some(t => t.person === id);
          
          if (hasTransactions) {
            showToast('Não é possível excluir esta pessoa pois existem transações vinculadas a ela.', 'error');
            return;
          }
          
          if (confirm('Deseja realmente excluir esta pessoa? Esta ação é irreversível.')) {
            deletePerson(id);
          }
        });
      });
    }
  };

  // Funções para abrir modais de edição
  const openEditCategoryModal = (category, type) => {
    state.currentCategory = { ...category, type };
    
    // Preencher campos do formulário
    $('#editCategoryId').value = category.id;
    $('#editCategoryType').value = type;
    $('#editCategoryName').value = category.name;
    $('#editCategoryIconInput').value = category.icon || '';
    
    // Atualizar visualização do ícone
    const iconPreview = $('#editCategoryIconPreview');
    iconPreview.innerHTML = category.icon || `<svg width="24" height="24"><use href="#icon-default"></use></svg>`;
    
    // Atualizar título
    const typeText = type === 'income' ? 'Receita' : type === 'expense' ? 'Despesa' : 'Investimento';
    $('#editCategoryTitle').textContent = `Editar Categoria de ${typeText}`;
    
    // Configurar listener para visualizar ícone ao digitar
    $('#editCategoryIconInput').addEventListener('input', e => {
      const icon = e.target.value || `<svg width="24" height="24"><use href="#icon-default"></use></svg>`;
      iconPreview.innerHTML = icon;
    });
    
    // Abrir o modal
    openModal('editCategoryModal');
  };

  const openEditPaymentMethodModal = (method) => {
    state.currentCategory = { ...method, type: 'payment' };
    
    // Preencher campos do formulário
    $('#editCategoryId').value = method.id;
    $('#editCategoryType').value = 'payment';
    $('#editCategoryName').value = method.name;
    $('#editCategoryIconInput').value = method.icon || '';
    
    // Atualizar visualização do ícone
    const iconPreview = $('#editCategoryIconPreview');
    iconPreview.innerHTML = method.icon || `<svg width="24" height="24"><use href="#icon-default"></use></svg>`;
    
    // Atualizar título
    $('#editCategoryTitle').textContent = 'Editar Forma de Pagamento';
    
    // Configurar listener para visualizar ícone ao digitar
    $('#editCategoryIconInput').addEventListener('input', e => {
      const icon = e.target.value || `<svg width="24" height="24"><use href="#icon-default"></use></svg>`;
      iconPreview.innerHTML = icon;
    });
    
    // Abrir o modal
    openModal('editCategoryModal');
  };

  const openEditPersonModal = (person) => {
    state.currentCategory = { ...person, type: 'person' };
    
    // Preencher campos do formulário
    $('#editCategoryId').value = person.id;
    $('#editCategoryType').value = 'person';
    $('#editCategoryName').value = person.name;
    $('#editCategoryIconInput').value = person.icon || '';
    
    // Atualizar visualização do ícone
    const iconPreview = $('#editCategoryIconPreview');
    iconPreview.innerHTML = person.icon || `<svg width="24" height="24"><use href="#icon-default"></use></svg>`;
    
    // Atualizar título
    $('#editCategoryTitle').textContent = 'Editar Pessoa';
    
    // Configurar listener para visualizar ícone ao digitar
    $('#editCategoryIconInput').addEventListener('input', e => {
      const icon = e.target.value || `<svg width="24" height="24"><use href="#icon-default"></use></svg>`;
      iconPreview.innerHTML = icon;
    });
    
    // Abrir o modal
    openModal('editCategoryModal');
  };

  const openEditCardModal = (card) => {
    state.currentCard = card;
    
    // Preencher campos do formulário
    $('#cardName').value = card.name;
    $('#cardLimit').value = card.limit;
    $('#cardClosingDay').value = card.closingDay;
    $('#cardDueDay').value = card.dueDay;
    
    // Atualizar título
    $('.modal-title', $('#newCardModal')).textContent = 'Editar Cartão';
    $('#saveCardBtn').textContent = 'Atualizar';
    
    // Configurar botão de salvar
    $('#saveCardBtn').dataset.id = card.id;
    $('#saveCardBtn').dataset.action = 'update';
    
    // Fechar o modal de lista de cartões e abrir o de edição
    closeModal('cardsListModal');
    openModal('newCardModal');
  };

  // Funções para manipulação de categorias, formas de pagamento e pessoas
  const addCategory = async (categoryData, type) => {
    try {
      // Criar objeto da categoria
      const category = {
        ...categoryData,
        type, // 'income', 'expense' ou 'investment'
        createdAt: new Date().toISOString()
      };
      
      // Salvar no Firestore
      const docRef = await db.collection('categories').add(category);
      
      // Atualizar o ID
      category.id = docRef.id;
      
      // Adicionar ao estado local
      if (type === 'income') {
        state.categories.income.push(category);
      } else if (type === 'expense') {
        state.categories.expense.push(category);
      } else if (type === 'investment') {
        state.categories.investment.push(category);
      }
      
      // Atualizar UI
      if (type === 'investment') {
        renderInvestmentCategoriesList();
      } else {
        renderCategoriesList();
      }
      updateCategorySelects();
      
      showToast('Categoria adicionada com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao adicionar categoria:', error);
      showToast('Erro ao adicionar categoria. Tente novamente.', 'error');
    }
  };

  const updateCategory = async (categoryId, updates, type) => {
    try {
      // Atualizar no Firestore
      await db.collection('categories').doc(categoryId).update(updates);
      
      // Atualizar no estado local
      if (type === 'income') {
        const index = state.categories.income.findIndex(c => c.id === categoryId);
        if (index !== -1) {
          state.categories.income[index] = { ...state.categories.income[index], ...updates };
        }
      } else if (type === 'expense') {
        const index = state.categories.expense.findIndex(c => c.id === categoryId);
        if (index !== -1) {
          state.categories.expense[index] = { ...state.categories.expense[index], ...updates };
        }
      } else if (type === 'investment') {
        const index = state.categories.investment.findIndex(c => c.id === categoryId);
        if (index !== -1) {
          state.categories.investment[index] = { ...state.categories.investment[index], ...updates };
        }
      }
      
      // Atualizar UI
      if (type === 'investment') {
        renderInvestmentCategoriesList();
      } else {
        renderCategoriesList();
      }
      updateCategorySelects();
      
      // Atualizar categorias nas transações
      const batch = db.batch();
      const transactions = state.transactions.filter(t => t.category === categoryId);
      
      transactions.forEach(transaction => {
        const docRef = db.collection('transactions').doc(transaction.id);
        batch.update(docRef, { 
          categoryName: updates.name,
          categoryIcon: updates.icon
        });
        
        // Atualizar no estado local
        const index = state.transactions.findIndex(t => t.id === transaction.id);
        if (index !== -1) {
          state.transactions[index].categoryName = updates.name;
          state.transactions[index].categoryIcon = updates.icon;
        }
      });
      
      await batch.commit();
      
      // Problema #17: Corrigir falha de atualização automática após lançamentos
      // Atualizar a UI das transações
      filterTransactionsByMonth();
      updateTransactionsTable();
      
      showToast('Categoria atualizada com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao atualizar categoria:', error);
      showToast('Erro ao atualizar categoria. Tente novamente.', 'error');
    }
  };

  const deleteCategory = async (categoryId, type) => {
    try {
      // Excluir do Firestore
      await db.collection('categories').doc(categoryId).delete();
      
      // Remover do estado local
      if (type === 'income') {
        state.categories.income = state.categories.income.filter(c => c.id !== categoryId);
      } else if (type === 'expense') {
        state.categories.expense = state.categories.expense.filter(c => c.id !== categoryId);
      } else if (type === 'investment') {
        state.categories.investment = state.categories.investment.filter(c => c.id !== categoryId);
      }
      
      // Atualizar UI
      if (type === 'investment') {
        renderInvestmentCategoriesList();
      } else {
        renderCategoriesList();
      }
      updateCategorySelects();
      
      showToast('Categoria excluída com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao excluir categoria:', error);
      showToast('Erro ao excluir categoria. Tente novamente.', 'error');
    }
  };

  const addPaymentMethod = async (methodData) => {
    try {
      // Criar objeto da forma de pagamento
      const method = {
        ...methodData,
        createdAt: new Date().toISOString()
      };
      
      // Salvar no Firestore
      const docRef = await db.collection('paymentMethods').add(method);
      
      // Atualizar o ID
      method.id = docRef.id;
      
      // Adicionar ao estado local
      state.paymentMethods.push(method);
      
      // Atualizar UI
      renderPaymentMethodsList();
      updatePaymentMethodSelects();
      
      showToast('Forma de pagamento adicionada com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao adicionar forma de pagamento:', error);
      showToast('Erro ao adicionar forma de pagamento. Tente novamente.', 'error');
    }
  };

  const updatePaymentMethod = async (methodId, updates) => {
    try {
      // Atualizar no Firestore
      await db.collection('paymentMethods').doc(methodId).update(updates);
      
      // Atualizar no estado local
      const index = state.paymentMethods.findIndex(m => m.id === methodId);
      if (index !== -1) {
        state.paymentMethods[index] = { ...state.paymentMethods[index], ...updates };
      }
      
      // Atualizar UI
      renderPaymentMethodsList();
      updatePaymentMethodSelects();
      
      // Atualizar formas de pagamento nas transações
      const batch = db.batch();
      const transactions = state.transactions.filter(t => t.paymentMethod === methodId);
      
      transactions.forEach(transaction => {
        const docRef = db.collection('transactions').doc(transaction.id);
        batch.update(docRef, { 
          paymentMethodName: updates.name,
          paymentMethodIcon: updates.icon
        });
        
        // Atualizar no estado local
        const index = state.transactions.findIndex(t => t.id === transaction.id);
        if (index !== -1) {
          state.transactions[index].paymentMethodName = updates.name;
          state.transactions[index].paymentMethodIcon = updates.icon;
        }
      });
      
      await batch.commit();
      
      // Problema #17: Corrigir falha de atualização automática após lançamentos
      // Atualizar a UI das transações
      filterTransactionsByMonth();
      updateTransactionsTable();
      
      showToast('Forma de pagamento atualizada com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao atualizar forma de pagamento:', error);
      showToast('Erro ao atualizar forma de pagamento. Tente novamente.', 'error');
    }
  };

  const deletePaymentMethod = async (methodId) => {
    try {
      // Excluir do Firestore
      await db.collection('paymentMethods').doc(methodId).delete();
      
      // Remover do estado local
      state.paymentMethods = state.paymentMethods.filter(m => m.id !== methodId);
      
      // Atualizar UI
      renderPaymentMethodsList();
      updatePaymentMethodSelects();
      
      showToast('Forma de pagamento excluída com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao excluir forma de pagamento:', error);
      showToast('Erro ao excluir forma de pagamento. Tente novamente.', 'error');
    }
  };

  const addPerson = async (personData) => {
    try {
      // Criar objeto da pessoa
      const person = {
        ...personData,
        createdAt: new Date().toISOString()
      };
      
      // Salvar no Firestore
      const docRef = await db.collection('people').add(person);
      
      // Atualizar o ID
      person.id = docRef.id;
      
      // Adicionar ao estado local
      state.people.push(person);
      
      // Atualizar UI
      updatePeopleList();
      updatePeopleSelects();
      
      showToast('Pessoa adicionada com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao adicionar pessoa:', error);
      showToast('Erro ao adicionar pessoa. Tente novamente.', 'error');
    }
  };

  const updatePerson = async (personId, updates) => {
    try {
      // Atualizar no Firestore
      await db.collection('people').doc(personId).update(updates);
      
      // Atualizar no estado local
      const index = state.people.findIndex(p => p.id === personId);
      if (index !== -1) {
        state.people[index] = { ...state.people[index], ...updates };
      }
      
      // Atualizar UI
      updatePeopleList();
      updatePeopleSelects();
      
      showToast('Pessoa atualizada com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao atualizar pessoa:', error);
      showToast('Erro ao atualizar pessoa. Tente novamente.', 'error');
    }
  };

  const deletePerson = async (personId) => {
    try {
      // Excluir do Firestore
      await db.collection('people').doc(personId).delete();
      
      // Remover do estado local
      state.people = state.people.filter(p => p.id !== personId);
      
      // Atualizar UI
      updatePeopleList();
      updatePeopleSelects();
      
      showToast('Pessoa excluída com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao excluir pessoa:', error);
      showToast('Erro ao excluir pessoa. Tente novamente.', 'error');
    }
  };

  // Event listeners para o formulário de nova despesa
  const setupExpenseFormListeners = () => {
    const expenseForm = $('#expenseForm');
    if (!expenseForm) return;

    // Alternar visibilidade do campo de cartão de crédito com base na forma de pagamento
    $('#expensePaymentMethod').addEventListener('change', e => {
      const paymentMethod = e.target.value;
      const creditCardGroup = $('#creditCardGroup');
      const dueDateGroup = $('#expenseDueDateGroup');
      const statusGroup = $('#expenseStatusGroup');
      
      if (paymentMethod === 'credito') {
        // Se for cartão de crédito, exibir seleção de cartão
        creditCardGroup.style.display = 'block';
        
        // Problema #1: Corrigir o preenchimento automático do vencimento no Cartão de Crédito
        // Travar e ocultar campo de vencimento, será calculado automaticamente
        dueDateGroup.style.display = 'none';
        
        // Problema #2: Ocultar e preencher automaticamente o campo Status
        // Ocultar opções de status, será definido como Pendente
        statusGroup.closest('.form-group').style.display = 'none';
        
        // Pré-selecionar o status Pendente
        $('#expenseStatusPending').checked = true;
        
        // Preencher vencimento com base no cartão selecionado
        updateDueDateFromCard();
      } else {
        // Se não for cartão, ocultar seleção de cartão
        creditCardGroup.style.display = 'none';
        
        // Exibir campo de vencimento novamente
        dueDateGroup.style.display = 'block';
        
        // Problema #16: Corrigir retorno da tela ao mudar a forma de pagamento
        // Se não for uma despesa recorrente, exibir opções de status
        if (!$('#expenseIsRecurrent').checked) {
          statusGroup.closest('.form-group').style.display = 'block';
        }
      }
    });

    // Ao mudar cartão selecionado, atualizar vencimento
    $('#expenseCreditCard').addEventListener('change', updateDueDateFromCard);

    // Função para atualizar vencimento com base no cartão selecionado
    function updateDueDateFromCard() {
      const cardId = $('#expenseCreditCard').value;
      const dateInput = $('#expenseDate').value;
      
      if (cardId && dateInput) {
        const date = parseLocalDateString(dateInput);
        const card = state.cards.find(c => c.id === cardId);
        
        if (card && date) {
          // Problema #1: Corrigir o preenchimento automático do vencimento no Cartão de Crédito
          const vencimento = calcularVencimentoReal(date, card);
          if (vencimento) {
            setDateInputValue('expenseDueDate', vencimento);
          }
        }
      }
    }

    // Atualizar vencimento quando a data de lançamento mudar e forma de pagamento for cartão
    $('#expenseDate').addEventListener('change', () => {
      if ($('#expensePaymentMethod').value === 'credito') {
        updateDueDateFromCard();
      }
    });

    // Alternar visibilidade do grupo de recorrência com base no checkbox
    $('#expenseIsRecurrent').addEventListener('change', e => {
      const recurrenceGroup = $('#expenseRecurrenceGroup');
      const statusGroup = $('#expenseStatusGroup');
      
      if (e.target.checked) {
        recurrenceGroup.style.display = 'block';
        
        // Problema #2: Ocultar e preencher automaticamente o campo Status
        // Ocultar opções de status, será definido como Pendente
        statusGroup.closest('.form-group').style.display = 'none';
        
        // Pré-selecionar o status Pendente
        $('#expenseStatusPending').checked = true;
      } else {
        recurrenceGroup.style.display = 'none';
        
        // Problema #16: Corrigir retorno da tela ao mudar a forma de pagamento
        // Se não for cartão de crédito, exibir opções de status
        if ($('#expensePaymentMethod').value !== 'credito') {
          statusGroup.closest('.form-group').style.display = 'block';
        }
      }
    });

    // Alternar visibilidade do grupo de data de agendamento com base no status
    $$('input[name="expenseStatus"]').forEach(radio => {
      radio.addEventListener('change', e => {
        const scheduledDateGroup = $('#scheduledDateGroup');
        
        if (e.target.value === 'scheduled') {
          scheduledDateGroup.style.display = 'block';
        } else {
          scheduledDateGroup.style.display = 'none';
        }
      });
    });

    // Botão para salvar despesa
    $('#saveExpenseBtn').addEventListener('click', async () => {
      // Validar campos obrigatórios
      const name = $('#expenseName').value.trim();
      const amount = $('#expenseAmount').value;
      const category = $('#expenseCategory').value;
      const date = getDateInputValue('expenseDate');
      const paymentMethod = $('#expensePaymentMethod').value;
      const person = $('#expensePerson').value; // Pode ser vazio
      const isFixed = $('input[name="expenseType"]:checked')?.value || 'variable'; // Padrão: variável
      
      if (!name || !amount || !category || !date || !paymentMethod || !isFixed) {
        showToast('Preencha todos os campos obrigatórios.', 'error');
        return;
      }
      
      // Verificar valor positivo
      if (parseFloat(amount) <= 0) {
        showToast('O valor deve ser maior que zero.', 'error');
        return;
      }
      
      // Obter demais valores
      let dueDate = getDateInputValue('expenseDueDate');
      const isRecurrent = $('#expenseIsRecurrent').checked;
      const installments = isRecurrent ? parseInt($('#expenseInstallments').value) : 1;
      const notes = $('#expenseNotes').value.trim();
      
      // Problema #2: Ocultar e preencher automaticamente o campo Status
      // Definir status automaticamente para cartão de crédito ou despesa recorrente
      let status;
      if (paymentMethod === 'credito' || isRecurrent) {
        status = 'pending';
      } else {
        status = $('input[name="expenseStatus"]:checked')?.value || 'pending';
      }
      
      let scheduledDate = null;
      if (status === 'scheduled') {
        scheduledDate = getDateInputValue('expenseScheduledDate');
        if (!scheduledDate) {
          showToast('Defina a data de agendamento.', 'error');
          return;
        }
      }
      
      // Determinar informações adicionais para cartão de crédito
      let creditCardId = null;
      let creditCardName = null;
      
      if (paymentMethod === 'credito') {
        creditCardId = $('#expenseCreditCard').value;
        
        if (!creditCardId) {
          showToast('Selecione um cartão de crédito.', 'error');
          return;
        }
        
        const card = state.cards.find(c => c.id === creditCardId);
        if (card) {
          creditCardName = card.name;
          
          // Problema #1: Corrigir o preenchimento automático do vencimento no Cartão de Crédito
      // Calcular data de vencimento automaticamente
      dueDate = calcularVencimentoReal(date, card);
      
      // Forçar preenchimento mesmo que o campo esteja oculto
      if (dueDate) {
        setDateInputValue('expenseDueDate', dueDate);
      }
    }
  }
  
  // Obter informações da categoria selecionada
  const categoryObj = state.categories.expense.find(c => c.id === category);
  const categoryName = categoryObj ? categoryObj.name : '';
  const categoryIcon = categoryObj ? categoryObj.icon : '';
  
  // Obter nome do método de pagamento
  const paymentMethodObj = state.paymentMethods.find(m => m.id === paymentMethod);
  const paymentMethodName = paymentMethodObj ? paymentMethodObj.name : '';
  const paymentMethodIcon = paymentMethodObj ? paymentMethodObj.icon : '';
  
  // Obter nome da pessoa (se houver)
  let personName = '';
  let personIcon = '';
  if (person) {
    const personObj = state.people.find(p => p.id === person);
    if (personObj) {
      personName = personObj.name;
      personIcon = personObj.icon;
    }
  }
  
  // Criar objeto da despesa
  const expenseData = {
    type: 'expense',
    name,
    amount,
    category,
    categoryName,
    categoryIcon,
    date: localDateToISOString(date),
    dueDate: dueDate ? localDateToISOString(dueDate) : null,
    paymentMethod,
    paymentMethodName,
    paymentMethodIcon,
    status,
    isFixed,
    person,
    personName,
    personIcon,
    creditCardId,
    creditCardName,
    notes,
    scheduledDate: scheduledDate ? localDateToISOString(scheduledDate) : null
  };
  
  // Salvar despesa (recorrente ou não)
  const success = await addTransaction(expenseData, isRecurrent, installments);
  
  if (success) {
    expenseForm.reset();
    closeModal('expenseModal');
  }
});
  };

  // Event listeners para o formulário de nova receita
  const setupIncomeFormListeners = () => {
    const incomeForm = $('#incomeForm');
    if (!incomeForm) return;

    // Alternar visibilidade do grupo de recorrência com base no checkbox
    $('#incomeIsRecurrent').addEventListener('change', e => {
      const recurrenceGroup = $('#incomeRecurrenceGroup');
      const statusGroup = $('#incomeStatusGroup');
      
      if (e.target.checked) {
        recurrenceGroup.style.display = 'block';
        
        // Problema #2: Ocultar e preencher automaticamente o campo Status
        // Ocultar opções de status, será definido como Pendente
        statusGroup.closest('.form-group').style.display = 'none';
        
        // Pré-selecionar o status Pendente
        $('#incomeStatusPending').checked = true;
      } else {
        recurrenceGroup.style.display = 'none';
        statusGroup.closest('.form-group').style.display = 'block';
      }
    });

    // Botão para salvar receita
    $('#saveIncomeBtn').addEventListener('click', async () => {
      // Validar campos obrigatórios
      const name = $('#incomeName').value.trim();
      const amount = $('#incomeAmount').value;
      const category = $('#incomeCategory').value;
      const date = getDateInputValue('incomeDate');
      const paymentMethod = $('#incomePaymentMethod').value;
      
      if (!name || !amount || !category || !date || !paymentMethod) {
        showToast('Preencha todos os campos obrigatórios.', 'error');
        return;
      }
      
      // Verificar valor positivo
      if (parseFloat(amount) <= 0) {
        showToast('O valor deve ser maior que zero.', 'error');
        return;
      }
      
      // Obter demais valores
      const isRecurrent = $('#incomeIsRecurrent').checked;
      const installments = isRecurrent ? parseInt($('#incomeInstallments').value) : 1;
      const notes = $('#incomeNotes').value.trim();
      
      // Problema #2: Ocultar e preencher automaticamente o campo Status
      // Definir status automaticamente para receita recorrente
      let status;
      if (isRecurrent) {
        status = 'pending';
      } else {
        status = $('input[name="incomeStatus"]:checked')?.value || 'pending';
      }
      
      // Obter informações da categoria selecionada
      const categoryObj = state.categories.income.find(c => c.id === category);
      const categoryName = categoryObj ? categoryObj.name : '';
      const categoryIcon = categoryObj ? categoryObj.icon : '';
      
      // Obter nome do método de pagamento
      const paymentMethodObj = state.paymentMethods.find(m => m.id === paymentMethod);
      const paymentMethodName = paymentMethodObj ? paymentMethodObj.name : '';
      const paymentMethodIcon = paymentMethodObj ? paymentMethodObj.icon : '';
      
      // Criar objeto da receita
      const incomeData = {
        type: 'income',
        name,
        amount,
        category,
        categoryName,
        categoryIcon,
        date: localDateToISOString(date),
        paymentMethod,
        paymentMethodName,
        paymentMethodIcon,
        status,
        notes
      };
      
      // Salvar receita (recorrente ou não)
      const success = await addTransaction(incomeData, isRecurrent, installments);
      
      if (success) {
        incomeForm.reset();
        closeModal('incomeModal');
      }
    });
  };

  // Event listeners para o formulário de edição de transação
  const setupEditTransactionFormListeners = () => {
    const editForm = $('#editForm');
    if (!editForm) return;

    // Botão para salvar alterações
    $('#saveEditBtn').addEventListener('click', async () => {
      const transactionId = $('#editTransactionId').value;
      const transactionType = $('#editTransactionType').value;
      
      if (!transactionId) {
        showToast('ID da transação não encontrado.', 'error');
        return;
      }
      
      // Validar campos obrigatórios
      const name = $('#editName').value.trim();
      const amount = $('#editAmount').value;
      const category = $('#editCategory').value;
      const date = getDateInputValue('editDate');
      const paymentMethod = $('#editPaymentMethod').value;
      
      if (!name || !amount || !category || !date || !paymentMethod) {
        showToast('Preencha todos os campos obrigatórios.', 'error');
        return;
      }
      
      // Verificar valor positivo
      if (parseFloat(amount) <= 0) {
        showToast('O valor deve ser maior que zero.', 'error');
        return;
      }
      
      // Preparar objeto com as atualizações
      const updates = {
        name,
        amount,
        category,
        date: localDateToISOString(date),
        paymentMethod,
        notes: $('#editNotes').value.trim()
      };
      
      // Adicionar campos específicos com base no tipo de transação
      if (transactionType === 'expense') {
        // Configurar data de vencimento para despesas
        const dueDate = getDateInputValue('editDueDate');
        if (dueDate) {
          updates.dueDate = localDateToISOString(dueDate);
        }
        
        // Configurar tipo de despesa (fixa/variável)
        const isFixed = $('input[name="editExpenseType"]:checked')?.value || 'variable';
        updates.isFixed = isFixed;
        
        // Problema #2: Status automático para cartão de crédito ou despesa recorrente
        if (paymentMethod === 'credito' || $('#editIsRecurrent').checked) {
          updates.status = 'pending';
        } else {
          updates.status = $('input[name="editStatus"]:checked')?.value || 'pending';
        }
        
        // Configurar pessoa (se houver)
        const person = $('#editPerson').value;
        updates.person = person;
        
        if (person) {
          const personObj = state.people.find(p => p.id === person);
          if (personObj) {
            updates.personName = personObj.name;
            updates.personIcon = personObj.icon;
          }
        } else {
          updates.personName = '';
          updates.personIcon = '';
        }
        
        // Configurar cartão de crédito (se aplicável)
        if (paymentMethod === 'credito') {
          const creditCardId = $('#editCreditCard').value;
          updates.creditCardId = creditCardId;
          
          if (creditCardId) {
            const card = state.cards.find(c => c.id === creditCardId);
            if (card) {
              updates.creditCardName = card.name;
              
              // Problema #1: Corrigir o preenchimento automático do vencimento no Cartão de Crédito
              const vencimento = calcularVencimentoReal(date, card);
              if (vencimento) {
                updates.dueDate = localDateToISOString(vencimento);
              }
            }
          }
        } else {
          updates.creditCardId = null;
          updates.creditCardName = null;
        }
      } else {
        // Atualizar status para receitas
        updates.status = $('input[name="editStatus"]:checked')?.value || 'pending';
      }
      
      // Adicionar informações da categoria
      const categoryObj = transactionType === 'income'
        ? state.categories.income.find(c => c.id === category)
        : state.categories.expense.find(c => c.id === category);
      
      if (categoryObj) {
        updates.categoryName = categoryObj.name;
        updates.categoryIcon = categoryObj.icon;
      }
      
      // Adicionar informações do método de pagamento
      const paymentMethodObj = state.paymentMethods.find(m => m.id === paymentMethod);
      if (paymentMethodObj) {
        updates.paymentMethodName = paymentMethodObj.name;
        updates.paymentMethodIcon = paymentMethodObj.icon;
      }
      
      // Adicionar data de agendamento (se aplicável)
      if (updates.status === 'scheduled') {
        const scheduledDate = getDateInputValue('editScheduledDate');
        if (scheduledDate) {
          updates.scheduledDate = localDateToISOString(scheduledDate);
        }
      } else {
        updates.scheduledDate = null;
      }
      
      // Atualizar transação
      const success = await updateTransaction(transactionId, updates);
      
      if (success) {
        closeModal('editModal');
      }
    });
  };

  // Configurar event listeners para confirmação de exclusão
  const setupDeleteConfirmationListeners = () => {
    $('#confirmDeleteBtn').addEventListener('click', async () => {
      const transaction = state.currentTransaction;
      
      if (!transaction) {
        showToast('Transação não encontrada.', 'error');
        closeModal('deleteConfirmModal');
        return;
      }
      
      // Verificar opção de exclusão para transações recorrentes
      let deleteOption = 'single';
      
      if (transaction.isRecurrent && transaction.installments > transaction.installmentNumber) {
        deleteOption = $('input[name="deleteOption"]:checked')?.value || 'single';
      }
      
      // Realizar exclusão
      const success = await deleteTransaction(transaction.id, deleteOption);
      
      if (success) {
        closeModal('deleteConfirmModal');
      }
    });
  };

  // Configurar event listeners para pagamento de fatura
  const setupPayInvoiceListeners = () => {
    $('#confirmPayInvoiceBtn').addEventListener('click', async () => {
      const card = state.currentCard;
      
      if (!card) {
        showToast('Cartão não encontrado.', 'error');
        closeModal('payInvoiceConfirmModal');
        return;
      }
      
      await payCardInvoice(card.id);
    });
  };

  // Event listeners para o formulário de novo cartão
  const setupCardFormListeners = () => {
    // Botão para salvar cartão
    $('#saveCardBtn').addEventListener('click', async () => {
      // Validar campos obrigatórios
      const name = $('#cardName').value.trim();
      const limit = parseFloat($('#cardLimit').value);
      const closingDay = parseInt($('#cardClosingDay').value);
      const dueDay = parseInt($('#cardDueDay').value);
      
      if (!name || isNaN(limit) || isNaN(closingDay) || isNaN(dueDay)) {
        showToast('Preencha todos os campos corretamente.', 'error');
        return;
      }
      
      // Validar valores
      if (limit <= 0) {
        showToast('O limite deve ser maior que zero.', 'error');
        return;
      }
      
      if (closingDay < 1 || closingDay > 31 || dueDay < 1 || dueDay > 31) {
        showToast('Os dias devem estar entre 1 e 31.', 'error');
        return;
      }
      
      // Verificar se é edição ou adição
      const action = $('#saveCardBtn').dataset.action;
      const cardId = $('#saveCardBtn').dataset.id;
      
      const cardData = {
        name,
        limit,
        closingDay,
        dueDay
      };
      
      if (action === 'update' && cardId) {
        // Atualizar cartão existente
        await updateCard(cardId, cardData);
        closeModal('newCardModal');
      } else {
        // Adicionar novo cartão
        await addCard(cardData);
        closeModal('newCardModal');
      }
    });
  };

  // Event listeners para o formulário de nova categoria ou edição
  const setupCategoryFormListeners = () => {
    // Botão para salvar categoria ou forma de pagamento
    $('#saveEditCategoryBtn').addEventListener('click', async () => {
      if (!state.currentCategory) {
        showToast('Categoria não encontrada.', 'error');
        closeModal('editCategoryModal');
        return;
      }
      
      const id = state.currentCategory.id;
      const type = state.currentCategory.type;
      const name = $('#editCategoryName').value.trim();
      const icon = $('#editCategoryIconInput').value.trim();
      
      if (!name) {
        showToast('O nome é obrigatório.', 'error');
        return;
      }
      
      const updates = {
        name,
        icon: icon || (type === 'income' ? '💰' : type === 'expense' ? '📦' : type === 'investment' ? '📊' : '💵')
      };
      
      if (type === 'income' || type === 'expense' || type === 'investment') {
        await updateCategory(id, updates, type);
      } else if (type === 'payment') {
        await updatePaymentMethod(id, updates);
      } else if (type === 'person') {
        await updatePerson(id, updates);
      }
      
      closeModal('editCategoryModal');
    });
  };

  // Event listeners para o formulário de novo investimento
  const setupInvestmentFormListeners = () => {
    // Botão para salvar investimento
    $('#saveInvestmentBtn').addEventListener('click', async () => {
      // Validar campos obrigatórios
      const name = $('#investmentName').value.trim();
      const amount = parseFloat($('#investmentAmount').value || 0);
      const category = $('#investmentCategory').value;
      
      if (!name || !category) {
        showToast('Preencha os campos obrigatórios.', 'error');
        return;
      }
      
      // Preparar objeto do investimento
      const investmentData = {
        name,
        amount: amount.toString(),
        goal: $('#investmentGoal').value || null,
        category,
        targetDate: getDateInputValue('investmentTargetDate') ? localDateToISOString(getDateInputValue('investmentTargetDate')) : null,
        notes: $('#investmentNotes').value.trim()
      };
      
      // Verificar se é edição ou adição
      const action = $('#saveInvestmentBtn').dataset.action;
      const id = $('#saveInvestmentBtn').dataset.id;
      
      if (action === 'update' && id) {
        // Atualizar investimento existente
        await updateInvestment(id, investmentData);
        closeModal('newInvestmentModal');
        openInvestmentDetail(id);
      } else {
        // Adicionar novo investimento
        const newInvestment = await addInvestment(investmentData);
        closeModal('newInvestmentModal');
        if (newInvestment) {
          openInvestmentDetail(newInvestment.id);
        }
      }
    });
  };

  // Event listeners para formulário de contribuição de investimento
  const setupContributionFormListeners = () => {
    // Botão para salvar contribuição
    $('#saveContributionBtn').addEventListener('click', async () => {
      // Validar campos obrigatórios
      const investmentId = $('#contributionInvestmentId').value;
      const amount = parseFloat($('#contributionAmount').value);
      const date = getDateInputValue('contributionDate');
      
      if (!investmentId || isNaN(amount) || amount <= 0 || !date) {
        showToast('Preencha todos os campos corretamente.', 'error');
        return;
      }
      
      // Preparar objeto da contribuição
      const contributionData = {
        investmentId,
        amount: amount.toString(),
        date: localDateToISOString(date),
        description: $('#contributionDescription').value.trim()
      };
      
      // Verificar se é edição ou adição
      const action = $('#saveContributionBtn').dataset.action;
      const id = $('#saveContributionBtn').dataset.id;
      
      if (action === 'update' && id) {
        // Atualizar contribuição existente
        await updateContribution(id, contributionData);
      } else {
        // Adicionar nova contribuição
        await addContribution(contributionData);
      }
      
      closeModal('newContributionModal');
    });
  };

  // Funções para adicionar novas categorias e formas de pagamento
  const setupAddCategoryListeners = () => {
    // Adicionar nova categoria de receita
    $('#addIncomeCategoryBtn').addEventListener('click', async () => {
      const name = $('#newIncomeCategoryInput').value.trim();
      const icon = $('#newIncomeCategoryIconInput').value.trim();
      
      if (!name) {
        showToast('O nome é obrigatório.', 'error');
        return;
      }
      
      const categoryData = {
        name,
        icon: icon || '💰' // Ícone padrão
      };
      
      await addCategory(categoryData, 'income');
      
      // Limpar campos
      $('#newIncomeCategoryInput').value = '';
      $('#newIncomeCategoryIconInput').value = '';
    });
    
    // Adicionar nova categoria de despesa
    $('#addExpenseCategoryBtn').addEventListener('click', async () => {
      const name = $('#newExpenseCategoryInput').value.trim();
      const icon = $('#newExpenseCategoryIconInput').value.trim();
      
      if (!name) {
        showToast('O nome é obrigatório.', 'error');
        return;
      }
      
      const categoryData = {
        name,
        icon: icon || '📦' // Ícone padrão
      };
      
      await addCategory(categoryData, 'expense');
      
      // Limpar campos
      $('#newExpenseCategoryInput').value = '';
      $('#newExpenseCategoryIconInput').value = '';
    });
    
    // Adicionar nova categoria de investimento
    $('#addInvestmentCategoryBtn').addEventListener('click', async () => {
      const name = $('#newInvestmentCategoryInput').value.trim();
      const icon = $('#newInvestmentCategoryIconInput').value.trim();
      
      if (!name) {
        showToast('O nome é obrigatório.', 'error');
        return;
      }
      
      const categoryData = {
        name,
        icon: icon || '📊' // Ícone padrão
      };
      
      await addCategory(categoryData, 'investment');
      
      // Limpar campos
      $('#newInvestmentCategoryInput').value = '';
      $('#newInvestmentCategoryIconInput').value = '';
    });
    
    // Adicionar nova forma de pagamento
    $('#addPaymentMethodBtn').addEventListener('click', async () => {
      const name = $('#newPaymentMethodInput').value.trim();
      const icon = $('#newPaymentMethodIconInput').value.trim();
      
      if (!name) {
        showToast('O nome é obrigatório.', 'error');
        return;
      }
      
      const methodData = {
        name,
        icon: icon || '💵' // Ícone padrão
      };
      
      await addPaymentMethod(methodData);
      
      // Limpar campos
      $('#newPaymentMethodInput').value = '';
      $('#newPaymentMethodIconInput').value = '';
    });
    
    // Adicionar nova pessoa
    $('#addPersonBtn').addEventListener('click', async () => {
      const name = $('#newPersonInput').value.trim();
      const icon = $('#newPersonIconInput').value.trim();
      
      if (!name) {
        showToast('O nome é obrigatório.', 'error');
        return;
      }
      
      const personData = {
        name,
        icon: icon || '👤' // Ícone padrão
      };
      
      await addPerson(personData);
      
      // Limpar campos
      $('#newPersonInput').value = '';
      $('#newPersonIconInput').value = '';
    });
  };

  // Configurar navegação por abas
  const setupTabNavigation = () => {
    const tabs = $$('[data-toggle="tab"]');
    
    tabs.forEach(tab => {
      tab.addEventListener('click', e => {
        e.preventDefault();
        
        // Remover classe ativa de todas as abas
        $$('.nav-link').forEach(t => {
          t.classList.remove('active');
        });
        
        // Adicionar classe ativa à aba clicada
        tab.classList.add('active');
        
        // Esconder todos os painéis
        $$('.tab-pane').forEach(p => {
          p.classList.remove('active', 'show');
        });
        
        // Mostrar o painel correspondente
        const targetId = tab.getAttribute('href');
        const targetPane = $(targetId);
        
        if (targetPane) {
          targetPane.classList.add('active', 'show');
        }
      });
    });
  };

  // Inicialização geral
  const initApp = async () => {
    try {
      // Inicializar tema
      initTheme();
      
      // Definir datas padrão
      const today = new Date();
      setDateInputValue('expenseDate', today);
      setDateInputValue('expenseDueDate', today);
      setDateInputValue('incomeDate', today);
      
      // Inicializar selects de mês e ano
      updateYearOptions();
      $('#monthSelect').value = state.month.toString();
      updateMonthYearTitle();
      
      // Inicializar Chart.js
      createCharts();
      
      // Carregar dados do Firebase
      await loadCategoriesAndPaymentMethods();
      await loadCards();
      await loadTransactions();
      await loadInvestments();
      
      // Configurar event listeners
      setupExpenseFormListeners();
      setupIncomeFormListeners();
      setupEditTransactionFormListeners();
      setupDeleteConfirmationListeners();
      setupPayInvoiceListeners();
      setupCardFormListeners();
      setupCategoryFormListeners();
      setupInvestmentFormListeners();
      setupContributionFormListeners();
      setupAddCategoryListeners();
      setupTabNavigation();
      
      // Listener para alternar compromissos
      $('#commitmentsHeader').addEventListener('click', toggleCommitments);
      
      // Listeners para os botões da barra superior
      $('#newExpenseBtn').addEventListener('click', () => openModal('expenseModal'));
      $('#newIncomeBtn').addEventListener('click', () => openModal('incomeModal'));
      $('#cardsBtn').addEventListener('click', () => openModal('cardsListModal'));
      $('#categoriesBtn').addEventListener('click', () => openModal('categoriesModal'));
      $('#investmentsBtn').addEventListener('click', () => openModal('investmentsModal'));
      
      // Listeners para os botões do modal de cartões
      $('#newCardBtn').addEventListener('click', () => {
        closeModal('cardsListModal');
        
        // Resetar formulário
        $('#cardForm').reset();
        
        // Alterar título
        $('.modal-title', $('#newCardModal')).textContent = 'Novo Cartão';
        $('#saveCardBtn').textContent = 'Salvar Cartão';
        
        // Remover ação e ID
        $('#saveCardBtn').removeAttribute('data-action');
        $('#saveCardBtn').removeAttribute('data-id');
        
        openModal('newCardModal');
      });
      
      // Listeners para o modal de investimentos
      $('#newInvestmentBtn').addEventListener('click', openNewInvestmentModal);
      $('#backToInvestmentsBtn').addEventListener('click', () => {
        closeModal('investmentDetailModal');
        openModal('investmentsModal');
      });
      $('#editInvestmentBtn').addEventListener('click', () => {
        if (state.currentInvestment) {
          openEditInvestmentModal(state.currentInvestment.id);
        }
      });
      $('#deleteInvestmentBtn').addEventListener('click', () => {
        if (state.currentInvestment && confirm('Deseja realmente excluir este investimento e todas as suas contribuições? Esta ação é irreversível.')) {
          deleteInvestment(state.currentInvestment.id);
        }
      });
      $('#addInvestmentContributionBtn').addEventListener('click', openNewContributionModal);
      
      // Listeners para alterar o mês e ano
      $('#monthSelect').addEventListener('change', e => {
        state.month = parseInt(e.target.value);
        updateMonthYearTitle();
        filterTransactionsByMonth();
      });
      
      $('#yearSelect').addEventListener('change', e => {
        state.year = parseInt(e.target.value);
        updateMonthYearTitle();
        filterTransactionsByMonth();
      });
      
      // Listeners para todos os botões de fechar modal
      $$('.modal-close, .btn[id^="close"], .btn[id^="cancel"]').forEach(btn => {
        btn.addEventListener('click', () => {
          const modal = btn.closest('.modal-backdrop');
          if (modal) {
            closeModal(modal.id);
          }
        });
      });
      
      // Listeners para botões específicos de navegação em modais
      $('#backToCardsBtn').addEventListener('click', () => {
        closeModal('cardInvoiceModal');
        openModal('cardsListModal');
      });
      
      // Listeners para filtro de tipo de transação - Problema #8
      $$('#transactionTypeFilter .btn').forEach(btn => {
        btn.addEventListener('click', e => {
          $$('#transactionTypeFilter .btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          state.filters.type = btn.dataset.type;
          updateTransactionsTable();
        });
      });
      
      // Problema #17: Corrigir falha de atualização automática após lançamentos
      // Configurar listener para atualização de dados em tempo real
      db.collection('transactions').onSnapshot(snapshot => {
        snapshot.docChanges().forEach(change => {
          // Sincronizar modificações em tempo real
          if (change.type === 'added' || change.type === 'modified') {
            // Atualizar dados e UI
            loadTransactions();
          }
        });
      });
      
      // Listener para mudança de tema do sistema
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        if (localStorage.getItem('themePreference')) return; // Ignorar se houver preferência explícita
        
        document.documentElement.setAttribute('data-theme', e.matches ? 'dark' : 'light');
        state.themePreference = e.matches ? 'dark' : 'light';
        updateChartColors();
      });
      
      console.log('Aplicação inicializada com sucesso');
      
    } catch (error) {
      console.error('Erro ao inicializar aplicação:', error);
      showToast('Erro ao inicializar aplicação. Tente recarregar a página.', 'error');
    }
  };

  // Iniciar a aplicação quando o DOM estiver pronto
  document.addEventListener('DOMContentLoaded', initApp);
  
  // Exportar funções para uso em outros arquivos
  window.app = {
    state,
    formatCurrency,
    formatDate,
    openModal,
    closeModal,
    closeAllModals,
    showToast,
    toggleTheme,
    updateTransactionsTable,
    updateKPIs,
    updateCharts,
    filterTransactionsByMonth
  };

})();
</script>
</body>
</html>
