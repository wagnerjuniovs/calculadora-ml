<!DOCTYPE html>
<html lang="pt-BR" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Gestão Financeira da Família - Controle financeiro simplificado">
  <title>Gestão Financeira da Família</title>
  
  <!-- Fonte Inter via Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Font Awesome para ícones -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <!-- ApexCharts para gráficos -->
  <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
  
  <!-- Scripts CDN: Firebase v9 compat -->
  <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-auth-compat.js"></script>
  
  <style>
    /* ---------- DESIGN TOKENS ---------- */
    :root {
      /* Cores base - Proposta Clean & Elegante */
      --color-background: #F5F5F7; /* Fundo estilo Apple */
      --color-surface: #FFFFFF;    /* Branco puro para cards */
      --color-surface-hover: #F0F0F5; /* Hover suave - ajustado */
      --color-surface-variant: #E9E9EB; /* Variante de superfície - ajustado */
      --color-on-surface: #1D1D1F;    /* Texto preto em superfícies claras - Apple Black */
      --color-on-surface-variant: #6E6E73; /* Texto secundário estilo Apple - Apple Gray */
      --color-on-surface-muted: #8A8A8E; /* Texto terciário - Apple Gray (mais claro) */
      --color-on-surface-disabled: #AEAEB2; /* Texto desabilitado */
      --color-outline: #D1D1D6;       /* Bordas estilo iOS - ajustado */
      --color-divider: #E5E5EA;       /* Divisores estilo iOS */
      
      /* Cores semânticas - Estilo iOS */
      --color-primary: #007AFF; /* iOS Blue */
      --color-primary-dark: #0062CC; /* iOS Blue dark */
      --color-primary-light: #47A9FF; /* iOS Blue light */
      --color-primary-bg: #EBF5FF; /* Azul muito claro para backgrounds - ajustado */
      
      --color-on-primary: #FFFFFF;
      --color-success: #34C759; /* iOS Green */
      --color-success-light: #E8F8EE; /* Fundo verde claro */
      --color-warning: #FF9500; /* iOS Orange */
      --color-warning-light: #FFF7EC; /* Fundo laranja claro */
      --color-error: #FF3B30; /* iOS Red */
      --color-error-light: #FFEEEC; /* Fundo vermelho claro */
      --color-info: #5AC8FA; /* iOS Light Blue */
      --color-info-light: #ECF8FE; /* Fundo azul claro */
      
      /* Cores para receitas e despesas */
      --color-income: var(--color-success); 
      --color-expense: var(--color-error); 
      --color-card-invoice: #AF52DE; /* iOS Purple */
      
      /* Paleta de cores para gráficos distribuídos */
      --chart-color-1: #007AFF;
      --chart-color-2: #34C759;
      --chart-color-3: #FF9500;
      --chart-color-4: #AF52DE;
      --chart-color-5: #FF2D55;
      --chart-color-6: #5AC8FA;
      --chart-color-7: #FFCC00; /* iOS Yellow */
      --chart-color-8: #8E8E93; /* iOS Gray */

      /* Tipografia */
      --font-sans: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      --font-display: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      
      --font-size-xs: 0.75rem;   /* 12px */
      --font-size-sm: 0.875rem;  /* 14px */
      --font-size-md: 1rem;      /* 16px */
      --font-size-lg: 1.125rem;  /* 18px */
      --font-size-xl: 1.25rem;   /* 20px */
      --font-size-2xl: 1.5rem;   /* 24px */
      --font-size-3xl: 1.75rem;  /* 28px */
      --font-size-4xl: 2rem;     /* 32px */
      
      --font-weight-light: 300;
      --font-weight-regular: 400;
      --font-weight-medium: 500;
      --font-weight-semibold: 600;
      --font-weight-bold: 700;
      
      --line-height-tight: 1.2;
      --line-height-normal: 1.5; /* Ajustado para melhor legibilidade */
      --line-height-relaxed: 1.7;
      
      /* Espaçamento */
      --spacing-1: 0.25rem;  /* 4px */
      --spacing-2: 0.5rem;   /* 8px */
      --spacing-3: 0.75rem;  /* 12px */
      --spacing-4: 1rem;     /* 16px */
      --spacing-5: 1.25rem;  /* 20px */
      --spacing-6: 1.5rem;   /* 24px */
      --spacing-8: 2rem;     /* 32px */
      --spacing-10: 2.5rem;  /* 40px */
      --spacing-12: 3rem;    /* 48px */
      --spacing-16: 4rem;    /* 64px */
      
      /* Bordas e raios */
      --radius-sm: 0.25rem;     /* 4px */
      --radius-md: 0.5rem;      /* 8px */
      --radius-lg: 0.625rem;    /* 10px - Ajustado para Apple like */
      --radius-xl: 0.875rem;    /* 14px - Ajustado para Apple like */
      --radius-2xl: 1.25rem;    /* 20px */
      --radius-full: 9999px;    /* Circular */
      
      /* Sombras */
      --shadow-sm: 0px 1px 2px rgba(0, 0, 0, 0.04);
      --shadow-md: 0px 2px 6px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0px 5px 12px rgba(0, 0, 0, 0.07);
      --shadow-xl: 0px 10px 20px rgba(0, 0, 0, 0.08);
      
      /* Transições */
      --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-normal: 250ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-slow: 350ms cubic-bezier(0.4, 0, 0.2, 1);
      
      /* Z-index levels */
      --z-index-dropdown: 10;
      --z-index-sticky: 20;
      --z-index-fixed: 30;
      --z-index-modal-backdrop: 40;
      --z-index-modal: 50;
      --z-index-popover: 60;
      --z-index-tooltip: 70;
    }
    
    /* Dark mode overrides - Estilo iOS Dark Mode */
    [data-theme="dark"] {
      --color-background: #000000;      /* iOS Dark Mode Background */
      --color-surface: #1C1C1E;         /* iOS Dark Gray */
      --color-surface-hover: #2C2C2E;   /* Hover em dark mode */
      --color-surface-variant: #262628; /* iOS Secondary Dark Gray - ajustado */
      
      --color-on-surface: #FFFFFF;      /* Texto branco */
      --color-on-surface-variant: #A1A1A6; /* iOS Gray 5 - ajustado para mais contraste */
      --color-on-surface-muted: #8E8E93;   /* iOS Gray 4 - ajustado para mais contraste */
      --color-on-surface-disabled: #636366; /* iOS Gray 3 */
      
      --color-divider: #38383A;         /* iOS Gray Divider Dark Mode */
      --color-outline: #48484A;         /* iOS Gray Outline Dark Mode */
      
      --color-primary: #0A84FF;         /* iOS Blue Dark Mode */
      --color-primary-dark: #007AFF;    /* iOS Blue */
      --color-primary-light: #409CFF;   /* Lighter Blue */
      --color-primary-bg: #1A2B38;      /* Dark Background - ajustado para azul escuro */
      
      --color-success: #30D158;         /* iOS Green Dark Mode */
      --color-success-light: #1C2A22;   /* Verde escuro para fundo */
      --color-warning: #FF9F0A;         /* iOS Orange Dark Mode */
      --color-warning-light: #2C2622;   /* Laranja escuro para fundo */
      --color-error: #FF453A;           /* iOS Red Dark Mode */
      --color-error-light: #2C211F;     /* Vermelho escuro para fundo */
      --color-info: #64D2FF;            /* iOS Light Blue Dark Mode */
      --color-info-light: #1C2A2F;      /* Azul escuro para fundo */
      
      --color-income: var(--color-success); 
      --color-expense: var(--color-error);
      --color-card-invoice: #BF5AF2;    /* iOS Purple Dark Mode */
      
      /* Paleta de cores para gráficos distribuídos - Dark Mode */
      --chart-color-1: #0A84FF;
      --chart-color-2: #30D158;
      --chart-color-3: #FF9F0A;
      --chart-color-4: #BF5AF2;
      --chart-color-5: #FF375F;
      --chart-color-6: #64D2FF;
      --chart-color-7: #FFD60A; /* iOS Yellow Dark */
      --chart-color-8: #8E8E93; /* iOS Gray */

      /* Ajuste de sombras para dark mode */
      --shadow-sm: 0px 1px 2px rgba(0, 0, 0, 0.3);
      --shadow-md: 0px 2px 6px rgba(0, 0, 0, 0.35);
      --shadow-lg: 0px 5px 12px rgba(0, 0, 0, 0.4);
      --shadow-xl: 0px 10px 20px rgba(0, 0, 0, 0.45);
    }
    
    /* ---------- BASE STYLES ---------- */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    html {
      font-size: 16px;
      scroll-behavior: smooth;
    }
    
    body {
      font-family: var(--font-sans);
      font-size: var(--font-size-md);
      line-height: var(--line-height-normal);
      color: var(--color-on-surface);
      background-color: var(--color-background);
      transition: background-color var(--transition-normal), color var(--transition-normal);
      overflow-x: hidden;
    }
    
    h1, h2, h3, h4, h5, h6 {
      font-family: var(--font-display);
      font-weight: var(--font-weight-semibold);
      line-height: var(--line-height-tight);
      color: var(--color-on-surface); /* Garante que títulos sempre usem a cor principal do texto */
      margin-bottom: var(--spacing-4);
    }
    
    h1 { font-size: var(--font-size-4xl); letter-spacing: -0.02em; }
    h2 { font-size: var(--font-size-3xl); letter-spacing: -0.02em; }
    h3 { font-size: var(--font-size-2xl); letter-spacing: -0.01em; }
    h4 { font-size: var(--font-size-xl); }
    h5 { font-size: var(--font-size-lg); }
    h6 { font-size: var(--font-size-md); }
    
    p {
      margin-bottom: var(--spacing-4);
      color: var(--color-on-surface-variant); /* Padrão para parágrafos */
    }
    body p, body div { /* Garante que elementos filhos diretos herdem a cor do body se não especificado */
        color: inherit; 
    }

    a {
      color: var(--color-primary);
      text-decoration: none;
      transition: color var(--transition-fast);
    }
    
    a:hover {
      color: var(--color-primary-dark);
      text-decoration: underline;
    }
    
    img, svg {
      display: block;
      max-width: 100%;
      height: auto;
    }
    
    /* Form elements */
    input,
    select,
    textarea,
    button {
      font-family: var(--font-sans);
      font-size: var(--font-size-md);
      color: var(--color-on-surface);
    }
    
    input,
    select,
    textarea {
      width: 100%;
      padding: var(--spacing-3) var(--spacing-4); /* Ajustado para mais padding */
      background-color: var(--color-surface-variant); /* Usar surface-variant para inputs */
      border: 1px solid var(--color-outline);
      border-radius: var(--radius-lg);
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast), background-color var(--transition-fast);
    }
    
    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--color-primary) 20%, transparent); /* Estilo Apple Focus Ring */
      background-color: var(--color-surface); /* Clareia no foco */
    }
    
    input[type="date"] {
      /* padding-right: var(--spacing-8); Estilo padrão do browser para date é melhor */
    }
    
    select {
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%236E6E73'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right var(--spacing-3) center;
      background-size: 16px; /* Ajustado */
      padding-right: var(--spacing-8);
    }
    [data-theme="dark"] select {
       background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%23A1A1A6'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3E%3C/svg%3E");
    }
    
    input[disabled],
    select[disabled],
    textarea[disabled] {
      background-color: var(--color-surface-variant);
      border-color: var(--color-outline);
      color: var(--color-on-surface-disabled);
      opacity: 0.7;
      cursor: not-allowed;
    }
    
    textarea {
      min-height: 120px; /* Aumentado */
      resize: vertical;
    }
    
    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-2);
      padding: var(--spacing-2) var(--spacing-4);
      border-radius: var(--radius-lg);
      font-weight: var(--font-weight-medium);
      text-align: center;
      cursor: pointer;
      transition: all var(--transition-fast);
      white-space: nowrap;
      text-decoration: none;
      line-height: 1.5;
      min-height: 40px; /* Altura mínima para toque */
      border: 1px solid transparent; /* Borda para consistência de tamanho */
    }
    
    .btn-primary {
      background-color: var(--color-primary);
      color: var(--color-on-primary);
      border-color: var(--color-primary);
    }
    
    .btn-primary:hover {
      background-color: var(--color-primary-dark);
      border-color: var(--color-primary-dark);
    }
    
    .btn-success {
      background-color: var(--color-success);
      color: var(--color-on-primary);
      border-color: var(--color-success);
    }
    
    .btn-success:hover {
      background-color: color-mix(in srgb, var(--color-success) 90%, black);
      border-color: color-mix(in srgb, var(--color-success) 90%, black);
    }
    
    .btn-error, .btn-danger {
      background-color: var(--color-error);
      color: var(--color-on-primary);
      border-color: var(--color-error);
    }
    
    .btn-error:hover, .btn-danger:hover {
      background-color: color-mix(in srgb, var(--color-error) 90%, black);
      border-color: color-mix(in srgb, var(--color-error) 90%, black);
    }
    
    .btn-outline {
      background-color: transparent;
      color: var(--color-primary);
      border: 1px solid var(--color-primary);
    }
    
    .btn-outline:hover {
      background-color: var(--color-primary-bg);
      color: var(--color-primary-dark);
      border-color: var(--color-primary-dark);
    }
    [data-theme="dark"] .btn-outline {
        color: var(--color-primary); /* Garante que a cor primária seja usada para o texto */
        border-color: var(--color-primary);
    }
    [data-theme="dark"] .btn-outline:hover {
        background-color: color-mix(in srgb, var(--color-primary) 15%, transparent);
        border-color: var(--color-primary-light);
        color: var(--color-primary-light);
    }
    
    .btn-ghost {
      background-color: transparent;
      color: var(--color-primary);
      border: none;
    }
    
    .btn-ghost:hover {
      background-color: var(--color-primary-bg);
    }
    
    .btn-icon {
      width: 40px; /* Aumentado */
      height: 40px; /* Aumentado */
      padding: 0;
      border-radius: var(--radius-full);
    }
    
    .btn-sm {
      padding: var(--spacing-1) var(--spacing-3);
      font-size: var(--font-size-sm);
      min-height: 32px; /* Ajustado */
    }
    
    .btn-lg {
      padding: var(--spacing-3) var(--spacing-6);
      font-size: var(--font-size-lg);
      min-height: 48px; /* Ajustado */
    }
    
    /* ---------- LAYOUT ---------- */
    .container {
      width: 100%;
      max-width: 1200px; /* Aumentado para mais espaço */
      margin: 0 auto;
      padding: 0 var(--spacing-6); /* Aumentado */
    }
    
    .row {
      display: flex;
      flex-wrap: wrap;
      margin: 0 calc(var(--spacing-4) * -1);
    }
    
    .col { flex: 1 0 0%; padding: 0 var(--spacing-4); }
    .col-auto { flex: 0 0 auto; width: auto; padding: 0 var(--spacing-4); }
    .col-12 { flex: 0 0 auto; width: 100%; padding: 0 var(--spacing-4); }
    .col-6 { flex: 0 0 auto; width: 50%; padding: 0 var(--spacing-4); }
    .col-4 { flex: 0 0 auto; width: 33.33333%; padding: 0 var(--spacing-4); }
    .col-3 { flex: 0 0 auto; width: 25%; padding: 0 var(--spacing-4); }
    
    @media (max-width: 768px) {
      .col-md-12 { flex: 0 0 auto; width: 100%; }
      .col-md-6 { flex: 0 0 auto; width: 50%; }
    }
    
    @media (max-width: 576px) {
      .col-sm-12 { flex: 0 0 auto; width: 100%; }
    }
    
    .grid { display: grid; gap: var(--spacing-6); }
    .grid-cols-1 { grid-template-columns: repeat(1, 1fr); }
    .grid-cols-2 { grid-template-columns: repeat(2, 1fr); }
    .grid-cols-3 { grid-template-columns: repeat(3, 1fr); }
    .grid-cols-4 { grid-template-columns: repeat(4, 1fr); }
    
    @media (max-width: 1024px) {
      .lg-grid-cols-2 { grid-template-columns: repeat(2, 1fr); }
    }
    
    @media (max-width: 768px) {
      .md-grid-cols-2 { grid-template-columns: repeat(2, 1fr); }
      .md-grid-cols-1 { grid-template-columns: repeat(1, 1fr); }
    }
    
    @media (max-width: 576px) {
      .sm-grid-cols-1 { grid-template-columns: repeat(1, 1fr); }
    }
    
    .flex { display: flex; }
    .flex-col { flex-direction: column; }
    .items-center { align-items: center; }
    .items-start { align-items: flex-start; }
    .items-end { align-items: flex-end; }
    .justify-center { justify-content: center; }
    .justify-between { justify-content: space-between; }
    .justify-end { justify-content: flex-end; }
    .flex-wrap { flex-wrap: wrap; }
    
    .gap-1 { gap: var(--spacing-1); }
    .gap-2 { gap: var(--spacing-2); }
    .gap-3 { gap: var(--spacing-3); }
    .gap-4 { gap: var(--spacing-4); }
    .gap-6 { gap: var(--spacing-6); }
    .gap-8 { gap: var(--spacing-8); }
    
    /* ---------- COMPONENTS ---------- */
    
    /* Header - Estilo iOS/macOS */
    .header {
      background-color: color-mix(in srgb, var(--color-surface) 80%, transparent); /* Efeito translúcido */
      border-bottom: 1px solid var(--color-divider);
      padding: var(--spacing-3) 0; /* Ajustado */
      position: sticky;
      top: 0;
      z-index: var(--z-index-sticky);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      transition: all var(--transition-normal);
    }
    
    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: var(--spacing-4);
    }
    
    .header-filters {
      display: flex;
      gap: var(--spacing-3);
      align-items: center;
    }
    
    .header-filters .filter-select {
      min-width: 130px; /* Aumentado */
      background-color: var(--color-surface-variant);
      border-radius: var(--radius-lg);
    }
    
    .header-actions {
      display: flex;
      gap: var(--spacing-2); /* Diminuído para caber mais */
      align-items: center;
    }
    
    @media (max-width: 1024px) { /* Ajustado breakpoint */
      .header-container {
        flex-direction: column;
        gap: var(--spacing-4);
      }
      .header-actions {
        flex-wrap: wrap;
        justify-content: center;
      }
    }
    
    @media (max-width: 768px) {
      .header-filters {
        flex-direction: column;
        align-items: stretch;
        width: 100%;
      }
    }
    
    /* Hero */
    .hero {
      padding: var(--spacing-10) 0 var(--spacing-8); /* Ajustado */
      text-align: center;
    }
    
    .hero-title {
      font-size: var(--font-size-4xl);
      color: var(--color-on-surface);
      margin-bottom: var(--spacing-2);
      letter-spacing: -0.02em;
    }
    
    .hero-subtitle {
      font-size: var(--font-size-lg);
      color: var(--color-on-surface-variant);
      max-width: 700px;
      margin: 0 auto var(--spacing-6);
    }
    
    /* Cards */
    .card {
      background-color: var(--color-surface);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-md);
      overflow: hidden;
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
      height: 100%;
    }
    
    .card:hover {
      transform: translateY(-3px); /* Aumentado */
      box-shadow: var(--shadow-lg);
    }
    
    .card-header {
      padding: var(--spacing-5) var(--spacing-6); /* Ajustado */
      border-bottom: 1px solid var(--color-divider);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .card-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-semibold);
      margin: 0;
      color: var(--color-on-surface);
    }
    
    .card-body {
      padding: var(--spacing-5) var(--spacing-6); /* Ajustado */
      color: var(--color-on-surface-variant);
    }
    .card-body > *:last-child {
        margin-bottom: 0;
    }
    
    .card-footer {
      padding: var(--spacing-5) var(--spacing-6); /* Ajustado */
      border-top: 1px solid var(--color-divider);
      display: flex;
      justify-content: flex-end;
      gap: var(--spacing-3); /* Ajustado */
    }
    
    /* KPI cards */
    .kpi-grid {
      margin-bottom: var(--spacing-8);
    }
    
    .kpi-card {
      background-color: var(--color-surface);
      border-radius: var(--radius-xl);
      padding: var(--spacing-5) var(--spacing-6); /* Ajustado */
      height: 100%;
      box-shadow: var(--shadow-md);
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
      display: flex;
      flex-direction: column;
      border-top: 5px solid var(--color-primary); /* Aumentado */
    }
    
    .kpi-card:hover {
      transform: translateY(-3px); /* Aumentado */
      box-shadow: var(--shadow-lg);
    }
    
    .kpi-income { border-top-color: var(--color-income); }
    .kpi-expense { border-top-color: var(--color-expense); }
    .kpi-balance { border-top-color: var(--color-primary); }
    .kpi-card-invoice { border-top-color: var(--color-card-invoice); }
    
    .kpi-title {
      font-family: var(--font-sans);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-semibold);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--color-on-surface-variant);
      margin-bottom: var(--spacing-2);
    }
    
    .kpi-value {
      font-family: var(--font-display);
      font-size: var(--font-size-3xl);
      font-weight: var(--font-weight-bold);
      color: var(--color-on-surface); /* Garante cor principal */
      margin-bottom: var(--spacing-2);
    }
    
    .kpi-subtitle {
      font-size: var(--font-size-sm);
      color: var(--color-on-surface-muted);
      display: flex;
      align-items: center;
      gap: var(--spacing-1);
      margin-top: auto;
      padding-top: var(--spacing-2);
    }
    .kpi-subtitle span { /* Garante que o span no subtitle também use a cor muted */
        color: var(--color-on-surface-muted);
    }
    
    /* Charts container */
    .chart-container {
      background-color: var(--color-surface);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-md);
      padding: var(--spacing-5) var(--spacing-6); /* Ajustado */
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    .chart-header {
      margin-bottom: var(--spacing-4);
    }
    
    .chart-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      margin: 0;
      color: var(--color-on-surface);
    }
    
    .chart-wrapper {
      flex: 1;
      min-height: 300px;
      position: relative;
    }
    
    .chart-legend {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: var(--spacing-3);
      margin-top: var(--spacing-4);
    }
    
    .chart-legend-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-2);
      font-size: var(--font-size-sm);
      cursor: pointer;
      padding: var(--spacing-1) var(--spacing-3);
      border-radius: var(--radius-full);
      background-color: var(--color-surface-variant);
      color: var(--color-on-surface-variant); /* Adicionado */
      transition: opacity var(--transition-fast), background-color var(--transition-fast);
      white-space: nowrap;
    }
    
    .chart-legend-item:hover {
      background-color: var(--color-surface-hover);
    }

    .chart-legend-item.inactive {
      opacity: 0.6; /* Aumentado para melhor visibilidade */
    }
    
    .chart-legend-color {
      width: 12px;
      height: 12px;
      border-radius: var(--radius-sm);
      flex-shrink: 0;
    }
    
    /* Donut chart center text */
    .limit-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    
    .limit-display {
      text-align: center;
      width: 120px; /* Aumentado */
      height: 120px; /* Aumentado */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .limit-value {
      font-size: var(--font-size-3xl); /* Aumentado */
      font-weight: var(--font-weight-bold);
      color: var(--color-on-surface);
      line-height: 1;
      margin-bottom: var(--spacing-1);
    }
    
    .limit-label {
      font-size: var(--font-size-sm); /* Aumentado */
      color: var(--color-on-surface-variant);
    }
    
    /* Insights */
    .insights-container {
      margin-bottom: var(--spacing-8);
    }
    
    .insight-banner {
      display: flex;
      align-items: center;
      gap: var(--spacing-4);
      padding: var(--spacing-4) var(--spacing-5); /* Ajustado */
      border-radius: var(--radius-xl);
      background-color: var(--color-surface);
      box-shadow: var(--shadow-sm);
      margin-bottom: var(--spacing-4);
      border-left: 5px solid var(--color-primary); /* Aumentado */
      transition: transform var(--transition-fast), box-shadow var(--transition-fast);
    }
    
    .insight-banner:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    
    .insight-danger { border-left-color: var(--color-error); background-color: var(--color-error-light); }
    .insight-warning { border-left-color: var(--color-warning); background-color: var(--color-warning-light); }
    .insight-success { border-left-color: var(--color-success); background-color: var(--color-success-light); }
    .insight-info { border-left-color: var(--color-info); background-color: var(--color-info-light); }
    
    .insight-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      font-size: 20px;
      color: var(--color-on-surface);
      flex-shrink: 0;
    }
    .insight-danger .insight-icon { color: var(--color-error); }
    .insight-warning .insight-icon { color: var(--color-warning); }
    .insight-success .insight-icon { color: var(--color-success); }
    .insight-info .insight-icon { color: var(--color-info); }

    .insight-content { flex: 1; }
    
    .insight-title {
      font-size: var(--font-size-md); /* Ajustado */
      font-weight: var(--font-weight-medium); /* Ajustado */
      margin: 0;
      color: var(--color-on-surface);
    }
    
    .insight-text { /* Não usado no HTML atual, mas mantido */
      color: var(--color-on-surface-variant);
    }
    
    /* Commitments */
    .commitments {
      background-color: var(--color-surface);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-md);
      overflow: hidden;
      margin-bottom: var(--spacing-8);
    }
    
    .commitments-header {
      padding: var(--spacing-5) var(--spacing-6); /* Ajustado */
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      transition: background-color var(--transition-fast);
    }
    
    .commitments-header:hover {
      background-color: var(--color-surface-hover);
    }
    
    .commitments-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-semibold);
      margin: 0;
      color: var(--color-on-surface);
    }
    #commitmentToggleIcon {
        color: var(--color-on-surface-variant);
        transition: transform var(--transition-normal);
    }
    .commitments-header:hover #commitmentToggleIcon {
        color: var(--color-on-surface);
    }
    
    .commitments-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height var(--transition-slow) ease-in-out; /* Ajustado */
    }
    
    .commitments-content.expanded {
      max-height: 1000px; /* Suficiente para conteúdo grande */
    }
    
    .commitment-list {
      padding: 0 var(--spacing-6) var(--spacing-6);
    }
    
    .commitment-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-4);
      padding: var(--spacing-4);
      border-radius: var(--radius-lg);
      background-color: var(--color-surface-variant);
      margin-bottom: var(--spacing-3); /* Ajustado */
    }
    
    .commitment-icon {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-full);
      color: var(--color-on-primary);
      flex-shrink: 0;
      font-size: var(--font-size-lg);
    }
    
    /* .commitment-content dentro do item, não o expansível */
    .commitment-item .commitment-content {
      flex: 1;
      max-height: none; /* Reseta max-height para este contexto */
    }
    
    .commitment-info {
      display: flex;
      justify-content: space-between;
      align-items: center; /* Alinhado */
      margin-bottom: var(--spacing-1); /* Ajustado */
    }
    
    .commitment-name {
      font-weight: var(--font-weight-medium);
      color: var(--color-on-surface);
    }
    
    .commitment-amount {
      font-weight: var(--font-weight-semibold);
      color: var(--color-on-surface);
    }
    
    .commitment-details {
      display: flex;
      justify-content: space-between;
      font-size: var(--font-size-sm);
      color: var(--color-on-surface-muted);
      margin-bottom: var(--spacing-2);
    }
    
    .commitment-progress {
      height: 8px;
      background-color: var(--color-surface); /* Fundo mais claro que o item */
      border-radius: var(--radius-full);
      overflow: hidden;
    }
    [data-theme="dark"] .commitment-progress {
        background-color: var(--color-background); /* No dark, usar um fundo mais escuro */
    }
    
    .commitment-progress-bar {
      height: 100%;
      border-radius: var(--radius-full);
      transition: width var(--transition-normal);
    }
    
    /* Transactions */
    .transactions-container {
      margin-bottom: var(--spacing-8);
    }
    
    .transactions-card {
      background-color: var(--color-surface);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-md);
      overflow: hidden;
    }
    
    .transactions-header {
      padding: var(--spacing-5) var(--spacing-6); /* Ajustado */
      border-bottom: 1px solid var(--color-divider);
    }
    
    .transactions-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-semibold);
      margin: 0 0 var(--spacing-4);
      color: var(--color-on-surface);
    }
    
    .transactions-filters {
      display: flex;
      flex-wrap: wrap;
      gap: var(--spacing-3); /* Ajustado */
    }
    .transactions-filters .select-wrapper select { /* Específico para filtros */
        min-width: 150px;
        font-size: var(--font-size-sm);
    }
    
    .transactions-table-container {
      overflow-x: auto;
    }
    
    .transactions-table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
    }
    
    .transactions-table th,
    .transactions-table td {
      padding: var(--spacing-3) var(--spacing-4); /* Ajustado */
      text-align: left;
      border-bottom: 1px solid var(--color-divider);
      white-space: nowrap; /* Evitar quebra de linha em células */
    }
    
    .transactions-table th {
      background-color: var(--color-surface-variant);
      font-weight: var(--font-weight-semibold);
      color: var(--color-on-surface-variant);
      position: sticky;
      top: 0; /* Para fixar o header da tabela ao rolar dentro do container */
      z-index: 1; /* Para sobrepor o conteúdo da tabela */
      cursor: pointer;
      transition: background-color var(--transition-fast);
    }
    
    .transactions-table th:hover {
      background-color: var(--color-divider);
    }
    
    .transactions-table th.sorted-asc::after {
      content: " \2191"; /* Seta para cima */
      margin-left: var(--spacing-1);
    }
    
    .transactions-table th.sorted-desc::after {
      content: " \2193"; /* Seta para baixo */
      margin-left: var(--spacing-1);
    }
    
    .transactions-table tr:hover {
      background-color: var(--color-surface-hover);
    }
    
    .transactions-table td {
      vertical-align: middle;
      color: var(--color-on-surface);
    }
    .transactions-table td:nth-child(2), /* Pessoa */
    .transactions-table td:nth-child(6), /* Status */
    .transactions-table td:nth-child(7)  /* Pagamento */
    {
        color: var(--color-on-surface-variant); /* Colunas com texto secundário */
    }
    .transactions-table td:nth-child(5) { /* Valor */
        font-weight: var(--font-weight-medium);
    }

    
    .transaction-name-cell {
      display: flex;
      align-items: center;
      gap: var(--spacing-3); /* Aumentado */
      font-weight: var(--font-weight-medium);
    }
    
    .transaction-icon {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-md); /* Ajustado */
      background-color: var(--color-surface-variant);
      color: var(--color-primary); /* Cor padrão, será sobrescrita no JS */
      flex-shrink: 0;
      font-size: var(--font-size-lg);
    }
    
    .transaction-actions {
      display: flex;
      gap: var(--spacing-2); /* Aumentado */
      justify-content: flex-end;
    }
    
    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: var(--spacing-1) var(--spacing-2); /* Ajustado */
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-semibold); /* Aumentado */
      text-transform: capitalize; /* Melhor que uppercase para status */
      letter-spacing: 0.02em; /* Ajustado */
      border-radius: var(--radius-md); /* Ajustado */
      white-space: nowrap;
    }
    
    .badge-success { background-color: var(--color-success-light); color: var(--color-success); }
    .badge-warning { background-color: var(--color-warning-light); color: var(--color-warning); }
    .badge-danger { background-color: var(--color-error-light); color: var(--color-error); }
    .badge-info { background-color: var(--color-info-light); color: var(--color-info); }
    
    /* Checkbox and Radio - Estilos base. Ajustes específicos para modal abaixo. */
    .form-check { /* Wrapper genérico para checkbox/radio se usado fora de modal-form-group */
      display: flex;
      align-items: center;
      gap: var(--spacing-2);
      margin-bottom: var(--spacing-2); /* Menor margem se usado em lista */
      cursor: pointer;
    }
    
    .form-check input[type="checkbox"],
    .form-check input[type="radio"] {
      width: 20px; /* Aumentado */
      height: 20px; /* Aumentado */
      margin: 0;
      cursor: pointer;
      accent-color: var(--color-primary);
      flex-shrink: 0;
    }
    
    .form-check-label {
      font-size: var(--font-size-md);
      cursor: pointer;
      color: var(--color-on-surface);
    }
    
    /* Theme toggle */
    .theme-toggle {
      background-color: transparent;
      border: none;
      width: 40px; /* Consistente com .btn-icon */
      height: 40px; /* Consistente com .btn-icon */
      border-radius: var(--radius-full);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--color-on-surface-variant);
      cursor: pointer;
      transition: background-color var(--transition-fast), color var(--transition-fast);
      font-size: var(--font-size-lg);
    }
    
    .theme-toggle:hover {
      background-color: var(--color-surface-variant);
      color: var(--color-on-surface);
    }
    
    [data-theme="light"] .fa-moon { display: none; }
    [data-theme="dark"] .fa-sun { display: none; }
    
    /* Modal backdrop and content */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.3); /* Mais suave */
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      display: none; /* Controlado por JS */
      align-items: center;
      justify-content: center;
      z-index: var(--z-index-modal-backdrop);
      opacity: 0; /* Para transição */
      transition: opacity var(--transition-normal);
    }
    
    .modal-backdrop.active {
      display: flex;
      opacity: 1;
    }
    
    .modal {
      width: 90%;
      max-width: 500px;
      background-color: var(--color-surface);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-xl);
      display: flex;
      flex-direction: column;
      max-height: 90vh;
      transform: scale(0.95); /* Para transição */
      opacity: 0; /* Para transição */
      transition: transform var(--transition-normal) ease-out, opacity var(--transition-normal) ease-out;
    }
    .modal-backdrop.active .modal {
        transform: scale(1);
        opacity: 1;
    }
    
    /* @keyframes modal-slide-in - Removido em favor de transform:scale */
    
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--spacing-5) var(--spacing-6); /* Ajustado */
      border-bottom: 1px solid var(--color-divider);
    }
    
    .modal-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-semibold);
      margin: 0;
      color: var(--color-on-surface);
    }
    
    .modal-close {
      background: transparent;
      border: none;
      font-size: 1.25rem; /* Ajustado */
      cursor: pointer;
      color: var(--color-on-surface-muted); /* Mais suave */
      transition: color var(--transition-fast), background-color var(--transition-fast);
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-full);
    }
    
    .modal-close:hover {
      color: var(--color-on-surface);
      background-color: var(--color-surface-hover);
    }
    
    .modal-body {
      padding: var(--spacing-6); /* Aumentado */
      overflow-y: auto;
      flex-grow: 1; /* Para ocupar espaço disponível */
    }
    /* Estilos para formulários dentro de modais */
    .modal-body .form-group {
      margin-bottom: var(--spacing-5); /* Mais espaçamento entre campos */
    }
    .modal-body .form-group:last-child {
      margin-bottom: 0;
    }

    .modal-body .form-label {
      display: block;
      font-weight: var(--font-weight-medium);
      color: var(--color-on-surface);
      margin-bottom: var(--spacing-2);
      font-size: var(--font-size-sm);
    }

    .modal-body .radio-group,
    .modal-body .checkbox-wrapper { /* Antigo .form-check */
      margin-top: var(--spacing-2);
      display: flex;
      gap: var(--spacing-4); /* Espaçamento entre radios */
      flex-wrap: wrap;
      align-items: center; /* Alinhar itens no checkbox-wrapper */
    }
    .modal-body .checkbox-wrapper {
        gap: var(--spacing-2); /* Menor gap para label do checkbox */
    }


    .modal-body .radio-wrapper { /* Wrapper individual para cada radio+label */
      display: flex;
      align-items: center;
      gap: var(--spacing-2);
    }

    .modal-body .radio-label,
    .modal-body .checkbox-label {
      font-size: var(--font-size-md);
      color: var(--color-on-surface);
      cursor: pointer;
    }

    .modal-body input[type="checkbox"],
    .modal-body input[type="radio"] {
      width: 18px;
      height: 18px;
      accent-color: var(--color-primary);
      flex-shrink: 0;
    }
    
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: var(--spacing-3); /* Ajustado */
      padding: var(--spacing-5) var(--spacing-6); /* Ajustado */
      border-top: 1px solid var(--color-divider);
      background-color: var(--color-surface-variant); /* Fundo sutil */
    }
    [data-theme="dark"] .modal-footer {
        background-color: var(--color-surface); /* No dark, o surface já é escuro */
    }
    
    /* Toast notifications */
    .toast-container {
      position: fixed;
      top: var(--spacing-4);
      right: var(--spacing-4);
      z-index: var(--z-index-tooltip);
      display: flex;
      flex-direction: column;
      gap: var(--spacing-3); /* Ajustado */
      max-width: 350px; /* Aumentado */
    }
    
    .toast {
      background-color: var(--color-surface);
      border-radius: var(--radius-lg); /* Consistente */
      padding: var(--spacing-3) var(--spacing-4); /* Ajustado */
      box-shadow: var(--shadow-lg);
      display: flex;
      align-items: center;
      gap: var(--spacing-3); /* Ajustado */
      opacity: 0;
      transform: translateX(100%);
      transition: opacity 0.3s ease-out, transform 0.3s ease-out;
      border-left: 5px solid var(--color-primary); /* Aumentado */
      color: var(--color-on-surface);
    }
    .toast.show {
        opacity: 1;
        transform: translateX(0);
    }
    
    /* @keyframes toast-in - Removido em favor de transition */
    
    .toast-success { border-left-color: var(--color-success); }
    .toast-error { border-left-color: var(--color-error); }
    .toast-warning { border-left-color: var(--color-warning); }
    .toast-info { border-left-color: var(--color-info); }
    
    .toast-icon {
      font-size: 1.5rem; /* Aumentado */
      flex-shrink: 0;
    }
    .toast-success .toast-icon { color: var(--color-success); }
    .toast-error .toast-icon { color: var(--color-error); }
    .toast-warning .toast-icon { color: var(--color-warning); }
    .toast-info .toast-icon { color: var(--color-info); }

    .toast-content {
      flex: 1;
      font-size: var(--font-size-sm);
    }
    
    .toast-close {
      background: transparent;
      border: none;
      color: var(--color-on-surface-muted);
      cursor: pointer;
      font-size: 1rem;
      padding: var(--spacing-1);
      margin-left: var(--spacing-2);
    }
    .toast-close:hover {
        color: var(--color-on-surface);
    }
    
    /* Select wrapper - já bem definido, talvez não precise de .select-wrapper::after global */
    .select-wrapper {
      position: relative;
      display: block; /* Para ocupar a largura total no form-group */
    }
    
    /* .select-wrapper select { padding-right: 2.5rem; } - Já definido em input, select, textarea */
    
    /* .select-wrapper::after { ... } - Removido se o estilo de select global for suficiente */
    
    /* Modal de Categorias - Estilos específicos */
    .categories-container .nav-tabs {
      display: flex;
      border-bottom: 1px solid var(--color-divider);
      margin-bottom: var(--spacing-4);
    }
    .categories-container .nav-item {
      list-style: none;
    }
    .categories-container .nav-link {
      padding: var(--spacing-3) var(--spacing-4);
      color: var(--color-on-surface-variant);
      border-bottom: 3px solid transparent;
      margin-bottom: -1px; 
      cursor: pointer;
      font-weight: var(--font-weight-medium);
      transition: color var(--transition-fast), border-color var(--transition-fast);
      display: block;
    }
    .categories-container .nav-link:hover {
      color: var(--color-on-surface);
    }
    .categories-container .nav-link.active {
      color: var(--color-primary);
      border-bottom-color: var(--color-primary);
    }
    .categories-container .tab-content { 
      padding-top: var(--spacing-2);
    }
    .categories-container .tab-pane {
      display: none; /* Controlado por JS/classe active */
    }
    .categories-container .tab-pane.fade.show.active {
      display: block;
    }

    .category-list {
      max-height: 250px; 
      overflow-y: auto;
      margin-bottom: var(--spacing-4);
      padding-right: var(--spacing-2); /* Espaço para scrollbar */
    }
    .category-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-3);
      background-color: var(--color-surface-variant);
      border-radius: var(--radius-lg);
      margin-bottom: var(--spacing-2);
      color: var(--color-on-surface);
    }
    .category-item-content {
      display: flex;
      align-items: center;
      gap: var(--spacing-3);
    }
    .category-item-icon { 
      font-size: var(--font-size-lg); 
      width: 24px; text-align: center;
    }
    .category-item-actions {
      display: flex;
      gap: var(--spacing-1);
    }

    .add-category-form {
      display: flex;
      gap: var(--spacing-2);
      align-items: stretch; /* Para inputs terem mesma altura */
      margin-top: var(--spacing-4);
      padding-top: var(--spacing-4);
      border-top: 1px solid var(--color-divider);
    }
    .add-category-form .custom-icon-input {
        flex-shrink: 0;
    }
    .add-category-form input[type="text"] {
      flex-grow: 1;
    }
    .add-category-form .btn {
        flex-shrink: 0;
    }

    .custom-icon-input { 
      display: flex;
      align-items: center;
      gap: var(--spacing-2);
      padding: 0 var(--spacing-3); /* Padding interno */
      background-color: var(--color-surface);
      border: 1px solid var(--color-outline);
      border-radius: var(--radius-lg);
      height: 40px; /* Mesma altura dos botões e inputs */
    }
    .custom-icon-preview { 
      font-size: var(--font-size-lg);
      line-height: 1;
    }
    .custom-icon-input input { 
      border: none; 
      padding: 0; 
      box-shadow: none; 
      background: transparent;
      width: 80px; /* Largura para o input de emoji */
    }
    .custom-icon-input input:focus {
        box-shadow: none;
    }

    /* Utility classes */
    .mt-1 { margin-top: var(--spacing-1); }
    .mt-2 { margin-top: var(--spacing-2); }
    .mt-4 { margin-top: var(--spacing-4); }
    .mt-6 { margin-top: var(--spacing-6); }
    .mt-8 { margin-top: var(--spacing-8); }
    
    .mb-1 { margin-bottom: var(--spacing-1); }
    .mb-2 { margin-bottom: var(--spacing-2); }
    .mb-4 { margin-bottom: var(--spacing-4); }
    .mb-6 { margin-bottom: var(--spacing-6); }
    .mb-8 { margin-bottom: var(--spacing-8); }
    
    .mx-auto { margin-left: auto; margin-right: auto; }
    
    .text-center { text-align: center; }
    .text-left { text-align: left; }
    .text-right { text-align: right; }
    
    .w-full { width: 100%; }
    .h-full { height: 100%; }
    
    .text-sm { font-size: var(--font-size-sm); }
    .text-lg { font-size: var(--font-size-lg); }
    .text-xl { font-size: var(--font-size-xl); }
    
    .font-medium { font-weight: var(--font-weight-medium); }
    .font-semibold { font-weight: var(--font-weight-semibold); }
    .font-bold { font-weight: var(--font-weight-bold); }
    
    .text-primary { color: var(--color-primary); }
    .text-success { color: var(--color-success); }
    .text-warning { color: var(--color-warning); }
    .text-error { color: var(--color-error); }
    .text-muted { color: var(--color-on-surface-muted); }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .hide-on-mobile { display: none; }
      .container { padding: 0 var(--spacing-4); }
      .header-actions .btn span { display: none; } /* Esconde texto dos botões, mantém ícone */
      .header-actions .btn { padding: 0; width: 40px; height: 40px; } /* Torna botões apenas ícones */
      .header-actions .btn i { margin-right: 0; }
      .transactions-table th, .transactions-table td { padding: var(--spacing-2) var(--spacing-3); }
      .transactions-table th:nth-child(2), /* Pessoa */
      .transactions-table td:nth-child(2),
      .transactions-table th:nth-child(7), /* Pagamento */
      .transactions-table td:nth-child(7) {
          display: none; /* Esconde colunas menos críticas */
      }
    }
    @media (max-width: 480px) {
        .hero-title { font-size: var(--font-size-3xl); }
        .hero-subtitle { font-size: var(--font-size-md); }
        .kpi-value { font-size: var(--font-size-2xl); }
        .modal { max-width: 100%; width: 95%; border-radius: var(--radius-lg); }
        .modal-body .radio-group { flex-direction: column; align-items: flex-start; gap: var(--spacing-3); }
        .add-category-form { flex-direction: column; align-items: stretch; }
    }

  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <div class="container">
      <div class="header-container">
        <div class="header-filters">
          <div class="select-wrapper">
            <select id="yearSelect" class="filter-select">
              <!-- Options will be populated by JS -->
            </select>
          </div>
          
          <div class="select-wrapper">
            <select id="monthSelect" class="filter-select">
              <option value="0">Janeiro</option>
              <option value="1">Fevereiro</option>
              <option value="2">Março</option>
              <option value="3">Abril</option>
              <option value="4">Maio</option>
              <option value="5">Junho</option>
              <option value="6">Julho</option>
              <option value="7">Agosto</option>
              <option value="8">Setembro</option>
              <option value="9">Outubro</option>
              <option value="10">Novembro</option>
              <option value="11">Dezembro</option>
            </select>
          </div>
        </div>
        
        <div class="header-actions">
          <button id="newIncomeBtn" class="btn btn-success">
            <i class="fas fa-plus"></i>
            <span>Nova Receita</span>
          </button>
          
          <button id="newExpenseBtn" class="btn btn-error">
            <i class="fas fa-minus"></i>
            <span>Nova Despesa</span>
          </button>
          
          <button id="cardsBtn" class="btn btn-outline">
            <i class="fas fa-credit-card"></i>
            <span>Cartões</span>
          </button>
          
          <button id="categoriesBtn" class="btn btn-outline">
            <i class="fas fa-tag"></i>
            <span>Categorias</span>
          </button>
          
          <button id="investmentsBtn" class="btn btn-outline">
            <i class="fas fa-chart-line"></i>
            <span>Investimentos</span>
          </button>

          <button id="themeToggle" class="theme-toggle" aria-label="Alternar tema">
            <i class="fas fa-sun"></i>
            <i class="fas fa-moon"></i>
          </button>
        </div>
      </div>
    </div>
  </header>
  
  <!-- Hero -->
  <section class="hero">
    <div class="container">
      <h1 class="hero-title">Wagner. Bárbara. Joaquim.</h1>
      <p class="hero-subtitle">Porque o futuro que sonhamos começa com o que fazemos hoje.</p>
    </div>
  </section>
  
  <main class="container">
    <!-- KPI Cards -->
    <div class="grid grid-cols-4 md-grid-cols-2 sm-grid-cols-1 kpi-grid">
      <div class="kpi-card kpi-balance">
        <div class="kpi-title">Saldo Real (Caixa)</div>
        <div class="kpi-value" id="balanceValue">R$ 0,00</div>
        <div class="kpi-subtitle">
          <i class="fas fa-info-circle text-primary"></i>
          <span>Saldo comprometido: R$ 0,00</span>
        </div>
      </div>
      
      <div class="kpi-card kpi-income">
        <div class="kpi-title">Receitas</div>
        <div class="kpi-value" id="incomeValue">R$ 0,00</div>
        <div class="kpi-subtitle">
          <span id="incomeReceivedValue">R$ 0,00 recebidos</span> /
          <span id="incomePendingValue">R$ 0,00 pendentes</span>
        </div>
      </div>
      
      <div class="kpi-card kpi-expense">
        <div class="kpi-title">Despesas</div>
        <div class="kpi-value" id="expenseValue">R$ 0,00</div>
        <div class="kpi-subtitle">
          <span id="expensePaidValue">R$ 0,00 pagos</span> /
          <span id="expensePendingValue">R$ 0,00 pendentes</span>
        </div>
      </div>
      
      <div class="kpi-card kpi-card-invoice">
        <div class="kpi-title">Fatura do Mês</div>
        <div class="kpi-value" id="invoiceValue">R$ 0,00</div>
        <div class="kpi-subtitle">
          <i class="fas fa-credit-card"></i>
          <span>Vencimento: <span id="invoiceDueDate">--/--/----</span></span>
        </div>
      </div>
    </div>
    
    <!-- Insights -->
    <div class="insights-container" id="insightsBannerContainer">
      <!-- Insights serão inseridos aqui dinamicamente -->
    </div>
    
    <!-- Charts -->
    <section class="mb-8">
      <h2 class="mb-6 text-2xl font-semibold text-on-surface">Resumo Financeiro</h2>
      
      <div class="grid grid-cols-2 md-grid-cols-1 gap-6 mb-6">
        <!-- Despesas por Categoria -->
        <div class="chart-container">
          <div class="chart-header">
            <h3 class="chart-title">Despesas por Categoria</h3>
          </div>
          <div class="chart-wrapper">
            <div id="categoryExpensesChart"></div>
          </div>
        </div>
        
        <!-- Uso do Limite (Cartões) -->
        <div class="chart-container">
          <div class="chart-header">
            <h3 class="chart-title">Uso do Limite (Cartões)</h3>
          </div>
          <div class="chart-wrapper">
            <div id="cardUsageDonutChart"></div>
            <div class="limit-container">
              <div class="limit-display">
                <div class="limit-value">0%</div>
                <div class="limit-label">utilizado</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="grid grid-cols-2 md-grid-cols-1 gap-6 mb-6">
        <!-- Despesas Fixas vs Variáveis -->
        <div class="chart-container">
          <div class="chart-header">
            <h3 class="chart-title">Despesas Fixas vs Variáveis</h3>
          </div>
          <div class="chart-wrapper">
            <div id="fixedVsVariableChart"></div>
          </div>
          <div class="chart-legend">
            <div class="chart-legend-item">
              <div class="chart-legend-color" style="background-color: var(--chart-color-2);"></div>
              <span>Fixas</span>
            </div>
            <div class="chart-legend-item">
              <div class="chart-legend-color" style="background-color: var(--chart-color-4);"></div>
              <span>Variáveis</span>
            </div>
          </div>
        </div>
        
        <!-- Despesas por Pessoa -->
        <div class="chart-container">
          <div class="chart-header">
            <h3 class="chart-title">Despesas por Pessoa</h3>
          </div>
          <div class="chart-wrapper">
            <div id="personAnalysisChart"></div>
          </div>
        </div>
      </div>
      
      <!-- Receitas x Despesas (12 meses) -->
      <div class="chart-container mb-8">
        <div class="chart-header">
          <h3 class="chart-title">Receitas x Despesas (12 meses)</h3>
        </div>
        <div class="chart-wrapper">
          <div id="annualBarsChart"></div>
        </div>
        <div class="chart-legend">
          <div class="chart-legend-item">
            <div class="chart-legend-color" style="background-color: var(--color-income);"></div>
            <span>Receitas</span>
          </div>
          <div class="chart-legend-item">
            <div class="chart-legend-color" style="background-color: var(--color-expense);"></div>
            <span>Despesas</span>
          </div>
          <div class="chart-legend-item">
            <div class="chart-legend-color" style="background-color: var(--color-primary);"></div>
            <span>Saldo</span>
          </div>
        </div>
      </div>
    </section>
    
    <!-- Compromissos -->
    <div class="commitments mb-8">
      <div class="commitments-header" id="commitmentsHeader">
        <h3 class="commitments-title">Compromissos Longos</h3>
        <i class="fas fa-chevron-down" id="commitmentToggleIcon"></i>
      </div>
      <div class="commitments-content" id="commitmentsContent">
        <!-- Compromissos serão inseridos aqui dinamicamente -->
      </div>
    </div>
    
    <!-- Transações -->
    <section class="transactions-container">
      <div class="transactions-card">
        <div class="transactions-header">
          <h3 class="transactions-title">Transações</h3>
          
          <div class="transactions-filters" id="transaction-filters">
            <!-- Filtros serão inseridos aqui dinamicamente -->
          </div>
        </div>
        
        <div class="transactions-table-container">
          <table class="transactions-table" id="transactionsTable">
            <thead>
              <tr>
                <th class="sortable" data-sort="name">Nome</th>
                <th class="sortable" data-sort="person">Pessoa</th>
                <th class="sortable" data-sort="date">Data</th>
                <th class="sortable" data-sort="dueDate">Vencimento</th>
                <th class="sortable" data-sort="amount" style="text-align: right;">Valor</th>
                <th class="sortable" data-sort="status" style="text-align: center;">Status</th>
                <th class="sortable" data-sort="paymentMethod">Pagamento</th>
                <th style="text-align: center;">Pago?</th>
                <th style="text-align: right;">Ações</th>
              </tr>
            </thead>
            <tbody id="transactionsTableBody">
              <!-- Transações serão inseridas aqui dinamicamente -->
            </tbody>
          </table>
        </div>
      </div>
    </section>
  </main>
  
  <!-- Modal de Nova Receita -->
  <div class="modal-backdrop" id="incomeModal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title">Nova Receita</h2>
        <button class="modal-close" id="closeIncomeModal" aria-label="Fechar">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-body">
        <form id="incomeForm">
          <div class="form-group">
            <label class="form-label" for="incomeName">Nome da Receita</label>
            <input type="text" id="incomeName" placeholder="Ex: Salário Mensal">
          </div>
          <div class="form-group">
            <label class="form-label" for="incomeAmount">Valor</label>
            <input type="number" id="incomeAmount" placeholder="0,00" min="0" step="0.01">
          </div>
          <div class="form-group">
            <label class="form-label" for="incomeCategory">Categoria</label>
            <div class="select-wrapper">
              <select id="incomeCategory"></select>
            </div>
          </div>
          <div class="form-group">
            <label class="form-label" for="incomeDate">Data de Lançamento</label>
            <input type="date" id="incomeDate">
          </div>
          <div class="form-group">
            <label class="form-label" for="incomePaymentMethod">Forma de Recebimento</label>
            <div class="select-wrapper">
              <select id="incomePaymentMethod"></select>
            </div>
          </div>
          <div class="form-group">
            <div class="checkbox-wrapper">
              <input type="checkbox" id="incomeIsRecurrent">
              <label class="checkbox-label" for="incomeIsRecurrent">Receita Recorrente</label>
            </div>
          </div>
          <div class="form-group" id="incomeRecurrenceGroup" style="display: none;">
            <label class="form-label" for="incomeInstallments">Quantidade de Parcelas</label>
            <input type="number" id="incomeInstallments" min="2" value="2">
          </div>
          <div class="form-group" id="incomeStatusGroup">
            <label class="form-label">Status</label>
            <div class="radio-group">
              <div class="radio-wrapper">
                <input type="radio" id="incomeStatusReceived" name="incomeStatus" value="received" checked>
                <label class="radio-label" for="incomeStatusReceived">Recebido</label>
              </div>
              <div class="radio-wrapper">
                <input type="radio" id="incomeStatusPending" name="incomeStatus" value="pending">
                <label class="radio-label" for="incomeStatusPending">A Receber</label>
              </div>
            </div>
          </div>
          <div class="form-group">
            <label class="form-label" for="incomeNotes">Observação (opcional)</label>
            <textarea id="incomeNotes" rows="3" placeholder="Algum detalhe adicional..."></textarea>
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline" id="cancelIncomeBtn">Cancelar</button>
        <button type="button" class="btn btn-success" id="saveIncomeBtn">Salvar Receita</button>
      </div>
    </div>
  </div>

 <!-- Modal de Nova Despesa -->
 <div class="modal-backdrop" id="expenseModal">
   <div class="modal">
     <div class="modal-header">
       <h2 class="modal-title">Nova Despesa</h2>
       <button class="modal-close" id="closeExpenseModal" aria-label="Fechar">
         <i class="fas fa-times"></i>
       </button>
     </div>
     <div class="modal-body">
       <form id="expenseForm">
         <div class="form-group">
           <label class="form-label" for="expenseName">Nome da Despesa</label>
           <input type="text" id="expenseName" placeholder="Ex: Supermercado">
         </div>
         <div class="form-group">
           <label class="form-label" for="expenseAmount">Valor</label>
           <input type="number" id="expenseAmount" placeholder="0,00" min="0" step="0.01">
         </div>
         <div class="form-group">
           <label class="form-label" for="expensePaymentMethod">Forma de Pagamento</label>
           <div class="select-wrapper">
             <select id="expensePaymentMethod"></select>
           </div>
         </div>
         <div class="form-group" id="creditCardGroup" style="display: none;">
           <label class="form-label" for="expenseCreditCard">Cartão de Crédito</label>
           <div class="select-wrapper">
             <select id="expenseCreditCard"></select>
           </div>
         </div>
         <div class="form-group">
           <label class="form-label" for="expenseCategory">Categoria</label>
           <div class="select-wrapper">
             <select id="expenseCategory"></select>
           </div>
         </div>
         <div class="form-group">
           <label class="form-label" for="expensePerson">Pessoa</label>
           <div class="select-wrapper">
             <select id="expensePerson"></select>
           </div>
         </div>
         <div class="form-group">
           <label class="form-label">Tipo de Despesa</label>
           <div class="radio-group">
             <div class="radio-wrapper">
               <input type="radio" id="expenseTypeFixed" name="expenseType" value="fixed" required>
               <label class="radio-label" for="expenseTypeFixed">Fixa</label>
             </div>
             <div class="radio-wrapper">
               <input type="radio" id="expenseTypeVariable" name="expenseType" value="variable" required checked>
               <label class="radio-label" for="expenseTypeVariable">Variável</label>
             </div>
           </div>
         </div>
         <div class="form-group">
           <label class="form-label" for="expenseDate">Data de Lançamento</label>
           <input type="date" id="expenseDate">
         </div>
         <div class="form-group" id="expenseDueDateGroup">
           <label class="form-label" for="expenseDueDate">Data de Vencimento</label>
           <input type="date" id="expenseDueDate">
         </div>
         <div class="form-group">
            <div class="checkbox-wrapper">
              <input type="checkbox" id="expenseIsRecurrent">
              <label class="checkbox-label" for="expenseIsRecurrent">Despesa Recorrente/Parcelada</label>
            </div>
         </div>
         <div class="form-group" id="expenseRecurrenceGroup" style="display: none;">
           <label class="form-label" for="expenseInstallments">Quantidade de Parcelas</label>
           <input type="number" id="expenseInstallments" min="2" value="2">
         </div>
         <div class="form-group" id="expenseStatusGroup">
           <label class="form-label">Status</label>
           <div class="radio-group">
             <div class="radio-wrapper">
               <input type="radio" id="expenseStatusPaid" name="expenseStatus" value="paid">
               <label class="radio-label" for="expenseStatusPaid">Pago</label>
             </div>
             <div class="radio-wrapper">
               <input type="radio" id="expenseStatusPending" name="expenseStatus" value="pending" checked>
               <label class="radio-label" for="expenseStatusPending">Pendente</label>
             </div>
             <div class="radio-wrapper">
               <input type="radio" id="expenseStatusScheduled" name="expenseStatus" value="scheduled">
               <label class="radio-label" for="expenseStatusScheduled">Agendado</label>
             </div>
           </div>
         </div>
         <div class="form-group" id="scheduledDateGroup" style="display: none;">
           <label class="form-label" for="expenseScheduledDate">Data de Agendamento</label>
           <input type="date" id="expenseScheduledDate">
         </div>
         <div class="form-group">
           <label class="form-label" for="expenseNotes">Observação (opcional)</label>
           <textarea id="expenseNotes" rows="3" placeholder="Algum detalhe adicional..."></textarea>
         </div>
       </form>
     </div>
     <div class="modal-footer">
       <button type="button" class="btn btn-outline" id="cancelExpenseBtn">Cancelar</button>
       <button type="button" class="btn btn-danger" id="saveExpenseBtn">Salvar Despesa</button>
     </div>
   </div>
 </div>

 <!-- Modal de Edição de Transação -->
 <div class="modal-backdrop" id="editModal">
  <div class="modal">
    <div class="modal-header">
      <h2 class="modal-title" id="editModalTitle">Editar Transação</h2>
      <button class="modal-close" id="closeEditModal" aria-label="Fechar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <form id="editForm">
        <input type="hidden" id="editTransactionId">
        <input type="hidden" id="editTransactionType">
        <div class="form-group">
          <label class="form-label" for="editName">Nome</label>
          <input type="text" id="editName">
        </div>
        <div class="form-group">
          <label class="form-label" for="editAmount">Valor</label>
          <input type="number" id="editAmount" min="0" step="0.01">
        </div>
        <div class="form-group">
          <label class="form-label" for="editCategory">Categoria</label>
          <div class="select-wrapper">
            <select id="editCategory" data-type=""></select>
          </div>
        </div>
        <div class="form-group" id="editPersonGroup">
          <label class="form-label" for="editPerson">Pessoa</label>
          <div class="select-wrapper">
            <select id="editPerson"></select>
          </div>
        </div>
        <div class="form-group" id="editExpenseTypeGroup" style="display: none;">
          <label class="form-label">Tipo de Despesa</label>
          <div class="radio-group">
            <div class="radio-wrapper">
              <input type="radio" id="editExpenseTypeFixed" name="editExpenseType" value="fixed">
              <label class="radio-label" for="editExpenseTypeFixed">Fixa</label>
            </div>
            <div class="radio-wrapper">
              <input type="radio" id="editExpenseTypeVariable" name="editExpenseType" value="variable">
              <label class="radio-label" for="editExpenseTypeVariable">Variável</label>
            </div>
          </div>
        </div>
        <div class="form-group">
          <label class="form-label" for="editDate">Data de Lançamento</label>
          <input type="date" id="editDate">
        </div>
        <div class="form-group" id="editDueDateGroup">
          <label class="form-label" for="editDueDate">Data de Vencimento</label>
          <input type="date" id="editDueDate">
        </div>
        <div class="form-group">
          <label class="form-label" for="editPaymentMethod">Forma de Pagamento</label>
          <div class="select-wrapper">
            <select id="editPaymentMethod"></select>
          </div>
        </div>
        <div class="form-group" id="editCreditCardGroup" style="display: none;">
          <label class="form-label" for="editCreditCard">Cartão de Crédito</label>
          <div class="select-wrapper">
            <select id="editCreditCard"></select>
          </div>
        </div>
        <div class="form-group">
          <div class="checkbox-wrapper">
            <input type="checkbox" id="editIsRecurrent">
            <label class="checkbox-label" for="editIsRecurrent">Transação Recorrente/Parcelada</label>
          </div>
        </div>
        <div class="form-group" id="editRecurrenceGroup" style="display: none;">
          <label class="form-label" for="editInstallments">Quantidade de Parcelas</label>
          <input type="number" id="editInstallments" min="2" value="2">
        </div>
        <div class="form-group" id="editStatusOuterGroup"> 
          <label class="form-label">Status</label>
          <div class="radio-group" id="editStatusGroup">
            <!-- Opções de status serão inseridas dinamicamente -->
          </div>
        </div>
        <div class="form-group" id="editScheduledDateGroup" style="display: none;">
          <label class="form-label" for="editScheduledDate">Data de Agendamento</label>
          <input type="date" id="editScheduledDate">
        </div>
        <div class="form-group">
          <label class="form-label" for="editNotes">Observação (opcional)</label>
          <textarea id="editNotes" rows="3"></textarea>
        </div>
      </form>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-outline" id="cancelEditBtn">Cancelar</button>
      <button type="button" class="btn btn-primary" id="saveEditBtn">Salvar Alterações</button>
    </div>
  </div>
 </div>

 <!-- Modal de Cartões -->
 <div class="modal-backdrop" id="cardsListModal">
  <div class="modal" style="max-width: 600px;">
    <div class="modal-header">
      <h2 class="modal-title">Meus Cartões</h2>
      <button class="modal-close" id="closeCardsListModal" aria-label="Fechar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <div id="cardsList" class="mb-6">
        <!-- Cards serão inseridos aqui dinamicamente -->
      </div>
      <button type="button" class="btn btn-primary w-full" id="newCardBtn">
        <i class="fas fa-plus"></i>
        Adicionar Novo Cartão
      </button>
    </div>
  </div>
 </div>

 <!-- Modal de Novo/Editar Cartão -->
 <div class="modal-backdrop" id="newCardModal">
  <div class="modal">
    <div class="modal-header">
      <h2 class="modal-title">Novo Cartão</h2> <!-- Será alterado para Editar Cartão via JS -->
      <button class="modal-close" id="closeNewCardModal" aria-label="Fechar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <form id="cardForm">
        <div class="form-group">
          <label class="form-label" for="cardName">Nome do Cartão</label>
          <input type="text" id="cardName" placeholder="Ex: Nubank Ultravioleta">
        </div>
        <div class="form-group">
          <label class="form-label" for="cardLimit">Limite Total</label>
          <input type="number" id="cardLimit" placeholder="0,00" min="0" step="0.01">
        </div>
        <div class="form-group">
          <label class="form-label" for="cardClosingDay">Dia de Fechamento da Fatura</label>
          <input type="number" id="cardClosingDay" placeholder="Ex: 20 (dia do mês)" min="1" max="31">
        </div>
        <div class="form-group">
          <label class="form-label" for="cardDueDay">Dia de Vencimento da Fatura</label>
          <input type="number" id="cardDueDay" placeholder="Ex: 28 (dia do mês)" min="1" max="31">
        </div>
      </form>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-outline" id="cancelCardBtn">Cancelar</button>
      <button type="button" class="btn btn-primary" id="saveCardBtn">Salvar Cartão</button>
    </div>
  </div>
 </div>

 <!-- Modal de Fatura do Cartão -->
 <div class="modal-backdrop" id="cardInvoiceModal">
  <div class="modal" style="max-width: 700px;">
    <div class="modal-header">
      <h2 class="modal-title" id="cardInvoiceTitle">Fatura do Cartão</h2>
      <button class="modal-close" id="closeCardInvoiceModal" aria-label="Fechar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <div class="card mb-6"> <!-- Usando card para agrupar detalhes -->
        <div id="cardInvoiceDetails" class="card-body">
          <!-- Detalhes da fatura serão inseridos aqui dinamicamente -->
        </div>
      </div>
      <h3 class="text-lg font-semibold mb-4 text-on-surface">Despesas desta Fatura</h3>
      <div class="transactions-table-container" style="max-height: 300px; overflow-y: auto;">
        <table class="transactions-table" id="cardInvoiceTable">
          <thead>
            <tr>
              <th>Nome</th>
              <th>Data</th>
              <th style="text-align: right;">Valor</th>
              <th style="text-align: center;">Pago?</th>
            </tr>
          </thead>
          <tbody id="cardInvoiceTableBody">
            <!-- Despesas da fatura serão inseridas aqui dinamicamente -->
          </tbody>
        </table>
      </div>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-outline" id="backToCardsBtn">Voltar</button>
      <button type="button" class="btn btn-primary" id="payInvoiceBtn">Pagar Fatura</button>
    </div>
  </div>
 </div>

 <!-- Modal de Confirmação de Exclusão -->
 <div class="modal-backdrop" id="deleteConfirmModal">
  <div class="modal" style="max-width: 450px;">
    <div class="modal-header">
      <h2 class="modal-title">
        <i class="fas fa-exclamation-triangle text-error" style="margin-right: 8px;"></i>
        Confirmar Exclusão
      </h2>
      <button class="modal-close" id="closeDeleteConfirmModal" aria-label="Fechar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <p class="text-on-surface mb-4">Você deseja realmente excluir esta transação? Esta ação é irreversível.</p>
      <div id="recurrenceDeleteOptions" style="display: none;">
        <p class="text-on-surface font-medium mb-2"><strong>Esta é uma transação recorrente/parcelada. O que deseja fazer?</strong></p>
        <div class="radio-group" style="flex-direction: column; gap: var(--spacing-3); align-items: flex-start;">
          <div class="radio-wrapper">
            <input type="radio" id="deleteSingle" name="deleteOption" value="single" checked>
            <label class="radio-label" for="deleteSingle">Excluir apenas esta parcela</label>
          </div>
          <div class="radio-wrapper">
            <input type="radio" id="deleteAllFuture" name="deleteOption" value="future">
            <label class="radio-label" for="deleteAllFuture">Excluir esta e todas as parcelas futuras (da mesma série)</label>
          </div>
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-outline" id="cancelDeleteBtn">Cancelar</button>
      <button type="button" class="btn btn-danger" id="confirmDeleteBtn">Excluir</button>
    </div>
  </div>
 </div>

 <!-- Modal de Confirmação de Pagamento de Fatura -->
 <div class="modal-backdrop" id="payInvoiceConfirmModal">
  <div class="modal" style="max-width: 400px;">
    <div class="modal-header">
      <h2 class="modal-title">
        <i class="fas fa-credit-card text-primary" style="margin-right: 8px;"></i>
        Pagar Fatura
      </h2>
      <button class="modal-close" id="closePayInvoiceConfirmModal" aria-label="Fechar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <p class="text-on-surface">Confirmar pagamento de todas as despesas pendentes desta fatura?</p>
      <p class="text-on-surface mt-2">Total: <strong id="invoiceConfirmAmount">R$ 0,00</strong></p>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-outline" id="cancelPayInvoiceBtn">Cancelar</button>
      <button type="button" class="btn btn-primary" id="confirmPayInvoiceBtn">Pagar</button>
    </div>
  </div>
 </div>

 <!-- Modal de Categorias -->
 <div class="modal-backdrop" id="categoriesModal">
  <div class="modal" style="max-width: 650px;"> <!-- Aumentado max-width -->
    <div class="modal-header">
      <h2 class="modal-title">Gerenciar Itens</h2>
      <button class="modal-close" id="closeCategoriesModal" aria-label="Fechar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body categories-container">
      <ul class="nav-tabs" id="categoryTabs" role="tablist">
        <li class="nav-item" role="presentation"><a class="nav-link active" id="income-cat-tab" data-toggle="tab" href="#income-cat" role="tab" aria-controls="income-cat" aria-selected="true">Receitas</a></li>
        <li class="nav-item" role="presentation"><a class="nav-link" id="expense-cat-tab" data-toggle="tab" href="#expense-cat" role="tab" aria-controls="expense-cat" aria-selected="false">Despesas</a></li>
        <li class="nav-item" role="presentation"><a class="nav-link" id="payment-methods-tab" data-toggle="tab" href="#payment-methods" role="tab" aria-controls="payment-methods" aria-selected="false">Pagamentos</a></li>
        <li class="nav-item" role="presentation"><a class="nav-link" id="people-tab" data-toggle="tab" href="#people" role="tab" aria-controls="people" aria-selected="false">Pessoas</a></li>
        <li class="nav-item" role="presentation"><a class="nav-link" id="investment-cat-tab" data-toggle="tab" href="#investment-cat" role="tab" aria-controls="investment-cat" aria-selected="false">Investimentos</a></li>
      </ul>
      <div class="tab-content" id="categoryTabContent">
        <div class="tab-pane fade show active" id="income-cat" role="tabpanel" aria-labelledby="income-cat-tab">
          <div class="category-list" id="incomeCategoriesList"></div>
          <form class="add-category-form">
            <div class="custom-icon-input"><div class="custom-icon-preview" id="newIncomeCategoryIconPreview">💰</div><input type="text" id="newIncomeCategoryIconInput" placeholder="Ícone (emoji)"></div>
            <input type="text" id="newIncomeCategoryInput" placeholder="Nova categoria de receita">
            <button type="button" class="btn btn-primary" id="addIncomeCategoryBtn">Adicionar</button>
          </form>
        </div>
        <div class="tab-pane fade" id="expense-cat" role="tabpanel" aria-labelledby="expense-cat-tab">
          <div class="category-list" id="expenseCategoriesList"></div>
          <form class="add-category-form">
            <div class="custom-icon-input"><div class="custom-icon-preview" id="newExpenseCategoryIconPreview">🛍️</div><input type="text" id="newExpenseCategoryIconInput" placeholder="Ícone (emoji)"></div>
            <input type="text" id="newExpenseCategoryInput" placeholder="Nova categoria de despesa">
            <button type="button" class="btn btn-primary" id="addExpenseCategoryBtn">Adicionar</button>
          </form>
        </div>
        <div class="tab-pane fade" id="payment-methods" role="tabpanel" aria-labelledby="payment-methods-tab">
          <div class="category-list" id="paymentMethodsList"></div>
          <form class="add-category-form">
            <div class="custom-icon-input"><div class="custom-icon-preview" id="newPaymentMethodIconPreview">💳</div><input type="text" id="newPaymentMethodIconInput" placeholder="Ícone (emoji)"></div>
            <input type="text" id="newPaymentMethodInput" placeholder="Nova forma de pagamento">
            <button type="button" class="btn btn-primary" id="addPaymentMethodBtn">Adicionar</button>
          </form>
        </div>
        <div class="tab-pane fade" id="people" role="tabpanel" aria-labelledby="people-tab">
          <div class="category-list" id="peopleList"></div>
          <form class="add-category-form">
            <div class="custom-icon-input"><div class="custom-icon-preview" id="newPersonIconPreview">👤</div><input type="text" id="newPersonIconInput" placeholder="Ícone (emoji)"></div>
            <input type="text" id="newPersonInput" placeholder="Nome da pessoa">
            <button type="button" class="btn btn-primary" id="addPersonBtn">Adicionar</button>
          </form>
        </div>
        <div class="tab-pane fade" id="investment-cat" role="tabpanel" aria-labelledby="investment-cat-tab">
          <div class="category-list" id="investmentCategoriesList"></div>
          <form class="add-category-form">
            <div class="custom-icon-input"><div class="custom-icon-preview" id="newInvestmentCategoryIconPreview">📈</div><input type="text" id="newInvestmentCategoryIconInput" placeholder="Ícone (emoji)"></div>
            <input type="text" id="newInvestmentCategoryInput" placeholder="Nova categoria de investimento">
            <button type="button" class="btn btn-primary" id="addInvestmentCategoryBtn">Adicionar</button>
          </form>
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-outline" id="closeCategoriesBtn">Fechar</button>
    </div>
  </div>
 </div>

 <!-- Modal de Edição de Categoria/Item -->
 <div class="modal-backdrop" id="editCategoryModal">
  <div class="modal" style="max-width: 450px;">
    <div class="modal-header">
      <h2 class="modal-title" id="editCategoryTitle">Editar Item</h2>
      <button class="modal-close" id="closeEditCategoryModal" aria-label="Fechar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <form id="editCategoryForm">
        <input type="hidden" id="editCategoryId">
        <input type="hidden" id="editCategoryType">
        <div class="form-group">
          <label class="form-label" for="editCategoryIconInput">Ícone (Emoji)</label>
          <div class="custom-icon-input">
            <div class="custom-icon-preview" id="editCategoryIconPreview">ℹ️</div>
            <input type="text" id="editCategoryIconInput" placeholder="Emoji ou ícone">
          </div>
        </div>
        <div class="form-group">
          <label class="form-label" for="editCategoryName">Nome</label>
          <input type="text" id="editCategoryName" placeholder="Nome do item">
        </div>
      </form>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-outline" id="cancelEditCategoryBtn">Cancelar</button>
      <button type="button" class="btn btn-primary" id="saveEditCategoryBtn">Salvar</button>
    </div>
  </div>
 </div>

 <!-- Modal Principal de Investimentos -->
 <div class="modal-backdrop" id="investmentsModal">
  <div class="modal" style="max-width: 900px;">
    <div class="modal-header">
      <h2 class="modal-title">Meus Investimentos</h2>
      <button class="modal-close" id="closeInvestmentsModal" aria-label="Fechar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <div class="flex justify-between items-center mb-6">
        <h3 class="text-xl font-semibold text-on-surface">Seus Objetivos Financeiros</h3>
        <button type="button" class="btn btn-primary" id="newInvestmentBtn">
          <i class="fas fa-plus"></i>
          Novo Objetivo
        </button>
      </div>
      <div class="grid grid-cols-3 md-grid-cols-2 sm-grid-cols-1 gap-6" id="investmentsGrid">
        <!-- Cards de investimentos -->
      </div>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-outline" id="closeInvestmentsBtn">Fechar</button>
    </div>
  </div>
 </div>

 <!-- Modal para Detalhe do Investimento -->
 <div class="modal-backdrop" id="investmentDetailModal">
  <div class="modal" style="max-width: 800px;">
    <div class="modal-header">
      <h2 class="modal-title" id="investmentDetailTitle" style="display: flex; align-items: center; gap: var(--spacing-3);">
        <button type="button" class="btn btn-icon btn-ghost" id="backToInvestmentsBtn" aria-label="Voltar">
          <i class="fas fa-arrow-left"></i>
        </button>
        <span id="investmentDetailName">Nome do Investimento</span>
      </h2>
      <button class="modal-close" id="closeInvestmentDetailModal" aria-label="Fechar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <div class="investment-detail mb-8">
        <div class="grid grid-cols-3 sm-grid-cols-1 gap-4 mb-6">
          <div class="card">
            <div class="card-body">
              <div class="text-sm font-medium text-muted">Valor Guardado</div>
              <div class="text-2xl font-bold text-on-surface" id="investmentDetailSaved">R$ 0,00</div>
            </div>
          </div>
          <div class="card">
            <div class="card-body">
              <div class="text-sm font-medium text-muted">Meta Total</div>
              <div class="text-2xl font-bold text-on-surface" id="investmentDetailGoal">R$ 0,00</div>
            </div>
          </div>
          <div class="card">
            <div class="card-body">
              <div class="text-sm font-medium text-muted">Progresso</div>
              <div class="text-2xl font-bold text-on-surface" id="investmentDetailProgress">0%</div>
            </div>
          </div>
        </div>
        
        <div class="grid grid-cols-3 sm-grid-cols-1 gap-4 mb-6">
          <div>
            <div class="text-sm font-medium text-muted">Categoria</div>
            <div id="investmentDetailCategory" class="text-on-surface">Viagem</div>
          </div>
          <div>
            <div class="text-sm font-medium text-muted">Criado em</div>
            <div id="investmentDetailCreatedAt" class="text-on-surface">01/01/2025</div>
          </div>
          <div>
            <div class="text-sm font-medium text-muted">Data Alvo</div>
            <div id="investmentDetailTarget" class="text-on-surface">Julho de 2026</div>
          </div>
        </div>
        
        <div class="mb-6">
          <div class="text-sm font-medium text-muted">Observação</div>
          <div id="investmentDetailNotes" class="text-on-surface">-</div>
        </div>
      </div>
      
      <div class="investment-history">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-semibold text-on-surface">Histórico de Aportes</h3>
          <button type="button" class="btn btn-primary btn-sm" id="addInvestmentContributionBtn">
            <i class="fas fa-plus"></i>
            Adicionar Aporte
          </button>
        </div>
        <div class="transactions-table-container" style="max-height: 250px; overflow-y: auto;">
          <table class="transactions-table">
            <thead>
              <tr>
                <th>Data</th>
                <th style="text-align: right;">Valor</th>
                <th>Descrição</th>
                <th style="text-align: right;">Ações</th>
              </tr>
            </thead>
            <tbody id="investmentHistoryTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-danger" id="deleteInvestmentBtn">Excluir Objetivo</button>
      <button type="button" class="btn btn-primary" id="editInvestmentBtn">Editar Objetivo</button>
    </div>
  </div>
 </div>

 <!-- Modal de Novo/Editar Investimento -->
 <div class="modal-backdrop" id="newInvestmentModal">
  <div class="modal">
    <div class="modal-header">
      <h2 class="modal-title" id="newInvestmentModalTitle">Novo Objetivo Financeiro</h2>
      <button class="modal-close" id="closeNewInvestmentModal" aria-label="Fechar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <form id="investmentForm">
        <div class="form-group">
          <label class="form-label" for="investmentName">Nome do objetivo</label>
          <input type="text" id="investmentName" placeholder="Ex: Viagem em Família para a Disney">
        </div>
        <div class="form-group">
          <label class="form-label" for="investmentAmount">Valor inicial (se houver)</label>
          <input type="number" id="investmentAmount" placeholder="0,00" min="0" step="0.01">
        </div>
        <div class="form-group">
          <label class="form-label" for="investmentGoal">Meta final (opcional)</label>
          <input type="number" id="investmentGoal" placeholder="0,00" min="0" step="0.01">
        </div>
        <div class="form-group">
          <label class="form-label" for="investmentCategorySelect">Tipo/Categoria do Objetivo</label>
          <div class="select-wrapper">
            <select id="investmentCategorySelect"></select> 
          </div>
        </div>
        <div class="form-group">
          <label class="form-label" for="investmentTargetDate">Data-alvo (opcional)</label>
          <input type="date" id="investmentTargetDate">
        </div>
        <div class="form-group">
          <label class="form-label" for="investmentNotes">Observações (opcional)</label>
          <textarea id="investmentNotes" rows="3" placeholder="Detalhes sobre o objetivo..."></textarea>
        </div>
      </form>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-outline" id="cancelInvestmentBtn">Cancelar</button>
      <button type="button" class="btn btn-primary" id="saveInvestmentBtn">Salvar Objetivo</button>
    </div>
  </div>
 </div>

 <!-- Modal para Adicionar/Editar Aporte -->
 <div class="modal-backdrop" id="newContributionModal">
  <div class="modal" style="max-width: 450px;">
    <div class="modal-header">
      <h2 class="modal-title" id="newContributionModalTitle">Adicionar Novo Valor</h2>
      <button class="modal-close" id="closeNewContributionModal" aria-label="Fechar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <form id="contributionForm">
        <input type="hidden" id="contributionInvestmentId">
        <div class="form-group">
          <label class="form-label" for="contributionAmount">Valor do Aporte</label>
          <input type="number" id="contributionAmount" placeholder="0,00" min="0" step="0.01" required>
        </div>
        <div class="form-group">
          <label class="form-label" for="contributionDate">Data do Aporte</label>
          <input type="date" id="contributionDate" required>
        </div>
        <div class="form-group">
          <label class="form-label" for="contributionDescription">Descrição (opcional)</label>
          <input type="text" id="contributionDescription" placeholder="Ex: Depósito mensal">
        </div>
      </form>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-outline" id="cancelContributionBtn">Cancelar</button>
      <button type="button" class="btn btn-primary" id="saveContributionBtn">Adicionar</button>
    </div>
  </div>
 </div>

 <!-- Modal para detalhes de contas vencidas/a vencer -->
 <div class="modal-backdrop" id="dueTransactionsModal">
  <div class="modal" style="max-width: 700px;">
    <div class="modal-header">
      <h2 class="modal-title" id="dueTransactionsModalTitle" style="display: flex; align-items: center; gap: var(--spacing-2);">
        <i class="fas fa-exclamation-triangle" id="dueTransactionsModalIcon" style="margin-right: 8px;"></i>
        <span id="dueTransactionsModalTitleText">Contas</span>
      </h2>
      <button class="modal-close" id="closeDueTransactionsModal" aria-label="Fechar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="modal-body">
      <div class="transactions-table-container" style="max-height: 400px; overflow-y: auto;">
        <table class="transactions-table" id="dueTransactionsTable">
          <thead>
            <tr>
              <th>Nome</th>
              <th>Categoria</th>
              <th>Vencimento</th>
              <th style="text-align: right;">Valor</th>
              <th style="text-align: right;">Ações</th>
            </tr>
          </thead>
          <tbody id="dueTransactionsTableBody"></tbody>
        </table>
      </div>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-outline" id="closeDueTransactionsBtn">Fechar</button>
      <button type="button" class="btn btn-primary" id="payAllDueBtn" style="display:none;">Pagar Todas</button>
    </div>
  </div>
 </div>

 <div class="toast-container" id="toastContainer"></div>

 <script>
  
  const $ = selector => document.querySelector(selector);
  const $$ = selector => Array.from(document.querySelectorAll(selector));

  const state = {
    year: new Date().getFullYear(),
    month: new Date().getMonth(),
    transactions: [],
    cards: [],
    filteredTransactions: [],
    insights: [],
    sortColumn: 'dueDate', 
    sortDirection: 'asc', 
    filters: {
      category: '',
      status: '',
      paymentMethod: '',
      person: '',
      transactionType: '' 
    },
    categories: {
      income: [
        { id: 'salario', name: 'Salário', icon: '💰', type: 'income' },
        { id: 'investimentos_income', name: 'Rend. Investimentos', icon: '📈', type: 'income' },
        { id: 'freelance', name: 'Freelance', icon: '💻', type: 'income' },
        { id: 'presente', name: 'Presente', icon: '🎁', type: 'income' },
        { id: 'outros_income', name: 'Outros', icon: 'ℹ️', type: 'income' }
      ],
      expense: [
        { id: 'alimentacao', name: 'Alimentação', icon: '🍔', type: 'expense' },
        { id: 'moradia', name: 'Moradia', icon: '🏠', type: 'expense' },
        { id: 'transporte', name: 'Transporte', icon: '🚗', type: 'expense' },
        { id: 'saude', name: 'Saúde', icon: '⚕️', type: 'expense' },
        { id: 'educacao', name: 'Educação', icon: '📚', type: 'expense' },
        { id: 'lazer', name: 'Lazer', icon: '🎮', type: 'expense' },
        { id: 'compras', name: 'Compras', icon: '🛍️', type: 'expense' },
        { id: 'contas', name: 'Contas e serviços', icon: '📝', type: 'expense' },
        { id: 'impostos', name: 'Impostos', icon: '💸', type: 'expense' },
        { id: 'outros_expense', name: 'Outros', icon: 'ℹ️', type: 'expense' }
      ],
      investment: [
        { id: 'viagem', name: 'Viagem', icon: '✈️', type: 'investment' },
        { id: 'emergencia', name: 'Emergência', icon: '🚨', type: 'investment' },
        { id: 'filho', name: 'Filho', icon: '👶', type: 'investment' },
        { id: 'tesouro', name: 'Tesouro Direto', icon: '🏛️', type: 'investment' },
        { id: 'acoes', name: 'Ações', icon: '📊', type: 'investment' },
        { id: 'outro_investment', name: 'Outro', icon: '💰', type: 'investment' }
      ]
    },
    paymentMethods: [
      { id: 'dinheiro', name: 'Dinheiro', icon: '💵' },
      { id: 'pix', name: 'Pix', icon: '⚡' },
      { id: 'debito', name: 'Débito', icon: '💳' },
      { id: 'debito_conta', name: 'Débito em Conta', icon: '🏦' },
      { id: 'transferencia', name: 'Transferência Bancária', icon: '🔄' },
      { id: 'boleto', name: 'Boleto', icon: '📄' },
      { id: 'credito', name: 'Cartão de Crédito', icon: '💳' }
    ],
    people: [
      { id: 'familia', name: 'Família', icon: '👨‍👩‍👧‍👦' },
      { id: 'wagner', name: 'Wagner', icon: '👨‍💻' },
      { id: 'barbara', name: 'Bárbara', icon: '👩‍🎨' },
      { id: 'joaquim', name: 'Joaquim', icon: '👶' }
    ],
    investments: [],
    investmentContributions: [],
    currentTransaction: null,
    currentCard: null,
    currentCategory: null,
    currentInvestment: null,
    currentContribution: null,
    themePreference: 'light'
  };

  const formatCurrency = value => {
    return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value || 0);
  };

  const parseLocalDateString = (dateInput) => {
    if (dateInput instanceof Date && !isNaN(dateInput)) return new Date(Date.UTC(dateInput.getFullYear(), dateInput.getMonth(), dateInput.getDate()));
    if (typeof dateInput === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(dateInput)) {
      const [year, month, day] = dateInput.split('-').map(Number);
      return new Date(Date.UTC(year, month - 1, day)); 
    }
    return null;
  };
  
  const formatDate = (date, options = {}) => {
    const dateObj = parseLocalDateString(date);
    if (!dateObj) return '--/--/----';
    return dateObj.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric', timeZone: 'UTC', ...options });
  };

  const localDateToISOString = (date) => {
    if (!date) return null;
    const d = date instanceof Date ? date : parseLocalDateString(date);
    if (!d) return null;
    const year = d.getUTCFullYear();
    const month = String(d.getUTCMonth() + 1).padStart(2, '0');
    const day = String(d.getUTCDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };

  const toggleTheme = () => {
    const newTheme = document.documentElement.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
    document.documentElement.setAttribute('data-theme', newTheme);
    state.themePreference = newTheme;
    localStorage.setItem('themePreference', newTheme);
    updateChartColors();
  };

  const initTheme = () => {
    const savedTheme = localStorage.getItem('themePreference') || (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
    document.documentElement.setAttribute('data-theme', savedTheme);
    state.themePreference = savedTheme;
    $('#themeToggle').addEventListener('click', toggleTheme);
  };

  // SUBSTITUÍDO PELA CONFIGURAÇÃO CORRETA FORNECIDA
  const firebaseConfig = {
    apiKey: "AIzaSyD9Q0TO8JVj9XN8gANWFndbRQ6QMUVkURs",
    authDomain: "sistema-financeiro-teste.firebaseapp.com",
    projectId: "sistema-financeiro-teste",
    storageBucket: "sistema-financeiro-teste.appspot.com", // Corrigido para .appspot.com se for o padrão
    messagingSenderId: "177026780096",
    appId: "1:177026780096:web:c1fcf41675036b2f3f9625"
  };


  let db;
  try {
    if (!firebase.apps.length) { // Evita reinicialização
        firebase.initializeApp(firebaseConfig);
    }
    db = firebase.firestore();
    // Tentativa de habilitar persistência, pode não funcionar em todos os navegadores/modos
    db.enablePersistence({experimentalForceOwningTab: true}).catch(err => {
        if (err.code == 'failed-precondition') {
            console.warn('Firebase persistence failed: Multiple tabs open or other issue.');
        } else if (err.code == 'unimplemented') {
            console.warn('Firebase persistence not available in this browser.');
        } else {
            console.warn('Firebase persistence error:', err.code);
        }
    });
    console.log('Firebase inicializado.');
  } catch (error) {
    console.error('Erro Firebase:', error);
    showToast('Erro de conexão com o Firebase.', 'error');
    // Fallback para um objeto 'db' mockado se a inicialização falhar
    db = { 
        collection: (name) => ({ 
            get: () => Promise.resolve({ docs: [], empty: true, forEach: () => {} }), 
            doc: (id) => ({ 
                get: () => Promise.resolve({ exists: false, data: () => ({}) }), 
                set: () => Promise.resolve(), 
                update: () => Promise.resolve(), 
                delete: () => Promise.resolve() 
            }), 
            add: () => Promise.resolve({ id: 'temp-id-' + Date.now() }) 
        }),
        batch: () => ({
            set: () => {},
            update: () => {},
            delete: () => {},
            commit: () => Promise.resolve()
        })
    };
  }

  const generateId = () => db.collection('any').doc().id; // Usa o gerador de ID do Firebase

  const showToast = (message, type = 'success') => {
    const container = $('#toastContainer');
    if (!container) return;
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    
    let iconClass = 'info-circle';
    if (type === 'success') iconClass = 'check-circle';
    if (type === 'error') iconClass = 'times-circle';
    if (type === 'warning') iconClass = 'exclamation-triangle';
    
    toast.innerHTML = `
      <div class="toast-icon">
        <i class="fas fa-${iconClass}"></i>
      </div>
      <div class="toast-content">${message}</div>
      <button type="button" class="toast-close" aria-label="Fechar toast">
        <i class="fas fa-times"></i>
      </button>
    `;
    
    container.appendChild(toast);
    // Força reflow para a animação funcionar na adição
    // eslint-disable-next-line no-unused-expressions
    toast.offsetHeight; 
    toast.classList.add('show');
    
    const closeButton = toast.querySelector('.toast-close');
    
    const removeToast = () => {
        toast.classList.remove('show');
        toast.addEventListener('transitionend', () => {
            if (toast.parentNode) { // Verifica se o toast ainda está no DOM
                 toast.remove();
            }
        }, { once: true });
    };

    closeButton.addEventListener('click', removeToast);
    
    setTimeout(removeToast, 5000);
  };

  const openModal = modalId => {
    const modalBackdrop = $(`#${modalId}`);
    if (modalBackdrop) {
      modalBackdrop.style.display = 'flex'; // Ativa o display flex antes da opacidade
      // eslint-disable-next-line no-unused-expressions
      modalBackdrop.offsetHeight; // Força reflow
      modalBackdrop.classList.add('active');
      
      const modalContent = modalBackdrop.querySelector('.modal');
      if(modalContent) {
        // eslint-disable-next-line no-unused-expressions
        modalContent.offsetHeight; // Força reflow para a animação do modal
        modalContent.style.transform = 'scale(1)';
        modalContent.style.opacity = '1';
      }
      document.body.style.overflow = 'hidden';
    }
  };
  
  const closeModal = modalId => {
    const modalBackdrop = $(`#${modalId}`);
    if (modalBackdrop) {
      modalBackdrop.classList.remove('active');
      const modalContent = modalBackdrop.querySelector('.modal');
      if(modalContent) {
        modalContent.style.transform = 'scale(0.95)';
        modalContent.style.opacity = '0';
      }
      // Espera a transição terminar para esconder o backdrop
      modalBackdrop.addEventListener('transitionend', function handler(e) {
          if (e.propertyName === 'opacity' && !modalBackdrop.classList.contains('active')) {
              modalBackdrop.style.display = 'none';
              if (!$$('.modal-backdrop.active').length) { 
                document.body.style.overflow = '';
              }
              modalBackdrop.removeEventListener('transitionend', handler);
          }
      });
    }
  };
  
  const closeAllModals = () => {
    $$('.modal-backdrop.active').forEach(modal => closeModal(modal.id));
  };

  const setDateInputValue = (inputId, date) => {
    const input = $(`#${inputId}`);
    if (input) input.value = localDateToISOString(date);
  };
  
  const getDateInputValue = inputId => {
    const input = $(`#${inputId}`);
    return input && input.value ? parseLocalDateString(input.value) : null;
  };

  const updateYearOptions = () => {
    const yearSelect = $('#yearSelect');
    if (yearSelect) {
      yearSelect.innerHTML = '';
      const currentYear = new Date().getFullYear();
      for (let year = currentYear - 2; year <= currentYear + 5; year++) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        option.selected = year === state.year;
        yearSelect.appendChild(option);
      }
    }
  };

  const calcularVencimentoReal = (dataCompraInput, cartao) => {
    if (!dataCompraInput || !cartao || !cartao.closingDay || !cartao.dueDay) return null;
    
    const compraDate = parseLocalDateString(dataCompraInput);
    if (!compraDate) return null;

    const compraDay = compraDate.getUTCDate();
    let mesFechamentoFatura = compraDate.getUTCMonth(); 
    let anoFechamentoFatura = compraDate.getUTCFullYear();

    if (compraDay > cartao.closingDay) {
        mesFechamentoFatura++;
        if (mesFechamentoFatura > 11) {
            mesFechamentoFatura = 0;
            anoFechamentoFatura++;
        }
    }

    let mesVencimentoFinal = mesFechamentoFatura;
    let anoVencimentoFinal = anoFechamentoFatura;

    if (cartao.dueDay < cartao.closingDay) { // Se vencimento é no mês seguinte ao fechamento
        mesVencimentoFinal++;
        if (mesVencimentoFinal > 11) {
            mesVencimentoFinal = 0;
            anoVencimentoFinal++;
        }
    }
    return new Date(Date.UTC(anoVencimentoFinal, mesVencimentoFinal, cartao.dueDay));
  };
  
  const calcularMelhorDiaCompras = (cartao) => {
    if (!cartao || !cartao.closingDay) return null;
    const dataFechamentoNoMesAtual = new Date(Date.UTC(state.year, state.month, cartao.closingDay));
    const dataMelhorDia = new Date(dataFechamentoNoMesAtual);
    dataMelhorDia.setUTCDate(dataFechamentoNoMesAtual.getUTCDate() + 1); // Dia seguinte ao fechamento
    return dataMelhorDia.getUTCDate();
  };

  const handleStatusField = (formPrefix) => {
    const paymentMethodEl = $(`#${formPrefix}PaymentMethod`);
    const isRecurrentEl = $(`#${formPrefix}IsRecurrent`);
    const statusGroupEl = $(`#${formPrefix}StatusGroup`);
    const statusPendingRadio = $(`#${formPrefix}StatusPending`); // Para despesas
    const statusPendingIncomeRadio = $(`#${formPrefix}StatusPending`); // Para receitas (mesmo ID, pode causar confusão se ambos modais abertos)


    if (!paymentMethodEl || !statusGroupEl ) return;
    
    const isCreditCard = paymentMethodEl.value === 'credito';
    const isRecurrent = isRecurrentEl ? isRecurrentEl.checked : false;

    if (formPrefix.includes('expense')) {
        if (isCreditCard) { 
            statusGroupEl.style.display = 'none';
            if (statusPendingRadio) statusPendingRadio.checked = true;
        } else if (isRecurrent) {
            statusGroupEl.style.display = 'none';
            if (statusPendingRadio) statusPendingRadio.checked = true;
        } else {
            statusGroupEl.style.display = 'block'; 
        }
    } else if (formPrefix.includes('income')) {
        if (isRecurrent) {
             statusGroupEl.style.display = 'none';
             const incomePendingRadio = $(`#incomeStatusPending`); // Específico para income modal
             if(incomePendingRadio) incomePendingRadio.checked = true;
        } else {
            statusGroupEl.style.display = 'block';
        }
    }
  };
  
  async function updateCardLimits(cardId, transactionAmount, operation, oldTransactionAmount = 0) {
    const card = state.cards.find(c => c.id === cardId);
    if (!card) return;

    let amountChange = 0;
    if (operation === 'add') {
        amountChange = transactionAmount;
    } else if (operation === 'subtract') {
        amountChange = -transactionAmount;
    } else if (operation === 'update') {
        amountChange = transactionAmount - oldTransactionAmount;
    }

    card.currentInvoice = (card.currentInvoice || 0) + amountChange;
    card.currentInvoice = Math.max(0, card.currentInvoice); 
    card.availableLimit = card.limit - card.currentInvoice;

    try {
        await db.collection('cards').doc(card.id).update({
            currentInvoice: card.currentInvoice, 
            availableLimit: card.availableLimit
        });
    } catch (error) {
        console.error("Error updating card limits in DB:", error);
        showToast('Erro ao atualizar limite do cartão.', 'error');
    }
    updateCreditCardSelects();
  }


  const loadCategoriesAndPaymentMethods = async () => {
    try {
      const collectionsToLoad = [
        { name: 'categories', stateKey: 'categories', defaultKey: true, typeField: 'type' },
        { name: 'paymentMethods', stateKey: 'paymentMethods', defaultKey: false },
        { name: 'people', stateKey: 'people', defaultKey: false }
      ];

      for (const coll of collectionsToLoad) {
        const snapshot = await db.collection(coll.name).get();
        if (!snapshot.empty) {
          if (coll.defaultKey) { 
            state[coll.stateKey].income = [];
            state[coll.stateKey].expense = [];
            state[coll.stateKey].investment = [];
            snapshot.docs.forEach(doc => {
              const item = { id: doc.id, ...doc.data() };
              if (item[coll.typeField] === 'income') state[coll.stateKey].income.push(item);
              else if (item[coll.typeField] === 'expense') state[coll.stateKey].expense.push(item);
              else if (item[coll.typeField] === 'investment') state[coll.stateKey].investment.push(item);
            });
          } else {
            state[coll.stateKey] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
          }
        } else if (state[coll.stateKey] && Object.keys(state[coll.stateKey]).length > 0) { 
            // Se a coleção no Firebase estiver vazia mas tivermos defaults no state, popular o Firebase
          const batch = db.batch();
          if (coll.defaultKey) {
            Object.values(state[coll.stateKey]).flat().forEach(item => {
              if(item.id) { // Garantir que o item tenha um ID
                const docRef = db.collection(coll.name).doc(item.id);
                batch.set(docRef, item); 
              }
            });
          } else {
            state[coll.stateKey].forEach(item => {
              if(item.id) { // Garantir que o item tenha um ID
                const docRef = db.collection(coll.name).doc(item.id);
                batch.set(docRef, item);
              }
            });
          }
          await batch.commit();
          console.log(`Default ${coll.name} written to Firebase.`);
        }
      }
      updateAllSelectsAndLists();
    } catch (error) {
      console.error('Erro ao carregar dados iniciais:', error);
      showToast('Erro ao carregar dados. Tente novamente.', 'error');
    }
  };
  
  const updateAllSelectsAndLists = () => {
    updateCategorySelects();
    updatePaymentMethodSelects();
    updatePeopleSelects();
    updateInvestmentCategorySelects(); 
    renderCategoriesList(); 
    renderExpenseCategoriesList(); // Adicionado
    renderInvestmentCategoriesList();
    updatePeopleList();
  };

  const updateCategorySelects = () => {
    const populateSelect = (selectEl, categories) => {
      if (selectEl) {
        const currentValue = selectEl.value;
        selectEl.innerHTML = '<option value="">Selecione...</option>';
        categories.forEach(category => {
          const option = document.createElement('option');
          option.value = category.id;
          option.textContent = `${category.icon || ''} ${category.name}`; 
          selectEl.appendChild(option);
        });
        if (categories.find(c => c.id === currentValue)) {
            selectEl.value = currentValue;
        } else {
            selectEl.value = ""; // Reseta se valor anterior não existe mais
        }
      }
    };
    populateSelect($('#incomeCategory'), state.categories.income);
    populateSelect($('#expenseCategory'), state.categories.expense);
    
    const editCategorySelect = $('#editCategory');
    if (editCategorySelect && state.currentTransaction) {
        const categories = state.currentTransaction.type === 'income' ? state.categories.income : state.categories.expense;
        populateSelect(editCategorySelect, categories);
        editCategorySelect.value = state.currentTransaction.category || "";
    }
  };

  const updatePaymentMethodSelects = () => {
    const selects = [$('#incomePaymentMethod'), $('#expensePaymentMethod'), $('#editPaymentMethod')];
    selects.forEach(selectEl => {
      if (selectEl) {
        const currentValue = selectEl.value;
        selectEl.innerHTML = '<option value="">Selecione...</option>';
        state.paymentMethods.forEach(method => {
          const option = document.createElement('option');
          option.value = method.id;
          option.textContent = `${method.icon || ''} ${method.name}`;
          selectEl.appendChild(option);
        });
         if (state.paymentMethods.find(m => m.id === currentValue)) {
            selectEl.value = currentValue;
        } else {
            selectEl.value = "";
        }
      }
    });
  };

  const updatePeopleSelects = () => {
    const selects = [$('#expensePerson'), $('#editPerson')];
    selects.forEach(selectEl => {
      if (selectEl) {
        const currentValue = selectEl.value;
        selectEl.innerHTML = '<option value="">Ninguém</option>'; 
        state.people.forEach(person => {
          const option = document.createElement('option');
          option.value = person.id;
          option.textContent = `${person.icon || ''} ${person.name}`;
          selectEl.appendChild(option);
        });
        if (state.people.find(p => p.id === currentValue)) {
            selectEl.value = currentValue;
        } else {
            selectEl.value = "";
        }
      }
    });
  };

  const updateInvestmentCategorySelects = () => {
    const selectEl = $('#investmentCategorySelect'); 
    if (selectEl) {
        const currentValue = selectEl.value;
        selectEl.innerHTML = '<option value="">Selecione...</option>';
        state.categories.investment.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = `${category.icon || ''} ${category.name}`;
            selectEl.appendChild(option);
        });
        if (state.categories.investment.find(c => c.id === currentValue)) {
            selectEl.value = currentValue;
        } else {
            selectEl.value = "";
        }
    }
  };


  const loadCards = async () => {
    try {
      const snapshot = await db.collection('cards').get();
      state.cards = snapshot.docs.map(doc => {
          const card = { id: doc.id, ...doc.data() };
          card.currentInvoice = card.currentInvoice || 0; 
          card.availableLimit = parseFloat(card.limit) - parseFloat(card.currentInvoice);
          return card;
      });
      updateCardsList();
      updateCreditCardSelects();
    } catch (error) {
      console.error('Erro ao carregar cartões:', error);
      showToast('Erro ao carregar cartões.', 'error');
    }
  };

  const addCard = async (cardData) => {
    try {
      const card = {
        ...cardData,
        currentInvoice: 0, 
        availableLimit: cardData.limit, 
        createdAt: localDateToISOString(new Date())
      };
      const docRef = await db.collection('cards').add(card);
      card.id = docRef.id;
      state.cards.push(card);
      await fullUIRefresh(); 
      showToast('Cartão adicionado com sucesso!', 'success');
    } catch (error) {
      console.error('Erro ao adicionar cartão:', error);
      showToast('Erro ao adicionar cartão.', 'error');
    }
  };

  const updateCard = async (cardId, updates) => {
    try {
      if (updates.limit !== undefined) {
        const card = state.cards.find(c => c.id === cardId);
        if (card) {
            updates.availableLimit = parseFloat(updates.limit) - (parseFloat(card.currentInvoice) || 0);
        }
      }
      await db.collection('cards').doc(cardId).update(updates);
      const index = state.cards.findIndex(c => c.id === cardId);
      if (index !== -1) state.cards[index] = { ...state.cards[index], ...updates };
      await fullUIRefresh(); 
      showToast('Cartão atualizado com sucesso!', 'success');
    } catch (error) {
      console.error('Erro ao atualizar cartão:', error);
      showToast('Erro ao atualizar cartão.', 'error');
    }
  };

  const deleteCard = async (cardId) => {
    try {
      if (!confirm('Tem certeza que deseja excluir este cartão? Transações associadas não serão alteradas, mas perderão o vínculo com este cartão.')) return;

      await db.collection('cards').doc(cardId).delete();
      state.cards = state.cards.filter(c => c.id !== cardId);
      const batch = db.batch();
      let changed = false;
      state.transactions.forEach(t => {
        if (t.creditCardId === cardId) {
            batch.update(db.collection('transactions').doc(t.id), { creditCardId: null, creditCardName: null });
            t.creditCardId = null; t.creditCardName = null;
            changed = true;
        }
      });
      if (changed) await batch.commit();

      await fullUIRefresh(); 
      showToast('Cartão excluído com sucesso!', 'success');
    } catch (error) {
      console.error('Erro ao excluir cartão:', error);
      showToast('Erro ao excluir cartão.', 'error');
    }
  };

  const payCardInvoice = async (cardId) => {
    try {
      const card = state.cards.find(c => c.id === cardId);
      if (!card) return;

      const faturaVencimentoRef = new Date(Date.UTC(state.year, state.month, card.dueDay));
      const { previousClosing, currentClosingDate } = getInvoicePeriod(card, faturaVencimentoRef);

      const batch = db.batch();
      let totalFaturaPagaEsteMes = 0;

      state.transactions.forEach(t => {
        if (t.type === 'expense' && t.paymentMethod === 'credito' && t.creditCardId === cardId) {
          const dataCompra = parseLocalDateString(t.date);
          // Inclui transações do período da fatura que não estão pagas
          if (dataCompra >= previousClosing && dataCompra < currentClosingDate && t.status !== 'paid') {
            const docRef = db.collection('transactions').doc(t.id);
            batch.update(docRef, { status: 'paid' });
            t.status = 'paid'; 
            totalFaturaPagaEsteMes += parseFloat(t.amount);
          }
        }
      });
      
      if (totalFaturaPagaEsteMes > 0) {
        // O currentInvoice do cartão já reflete o total gasto. Ao pagar, não alteramos o currentInvoice,
        // pois ele representa o gasto total no cartão, não o saldo devedor de faturas anteriores.
        // A lógica de `updateCardLimits` já cuida disso ao adicionar/remover transações.
        // O que precisamos é garantir que as transações individuais sejam marcadas como pagas.
        // Se o `currentInvoice` no cartão representa o "saldo devedor da fatura atual + compras recentes",
        // então ele deveria ser reduzido. Assumindo que `currentInvoice` é o total de compras não faturadas/pagas.
        card.currentInvoice = Math.max(0, (parseFloat(card.currentInvoice) || 0) - totalFaturaPagaEsteMes);
        card.availableLimit = parseFloat(card.limit) - parseFloat(card.currentInvoice);
        batch.update(db.collection('cards').doc(card.id), {
            currentInvoice: card.currentInvoice,
            availableLimit: card.availableLimit
        });
      }
      
      await batch.commit();
      await fullUIRefresh(); 
      closeModal('payInvoiceConfirmModal');
      showToast('Fatura paga com sucesso!', 'success');
    } catch (error) {
      console.error('Erro ao pagar fatura:', error);
      showToast('Erro ao pagar fatura.', 'error');
    }
  };

  const updateCreditCardSelects = () => {
    const selects = [$('#expenseCreditCard'), $('#editCreditCard')];
    selects.forEach(selectEl => {
      if (selectEl) {
        const currentValue = selectEl.value;
        selectEl.innerHTML = '';
        if (state.cards.length === 0) {
          selectEl.innerHTML = '<option value="" disabled selected>Nenhum cartão cadastrado</option>';
        } else {
          selectEl.innerHTML = '<option value="">Selecione o cartão...</option>';
          state.cards.forEach(card => {
            const option = document.createElement('option');
            option.value = card.id;
            option.textContent = `${card.name} (Disp: ${formatCurrency(card.availableLimit)})`;
            selectEl.appendChild(option);
          });
        }
        if (state.cards.find(c => c.id === currentValue)) {
            selectEl.value = currentValue;
        } else {
            selectEl.value = "";
        }
      }
    });
  };
  
  const loadInvestments = async () => {
    try {
      const [invSnapshot, contribSnapshot] = await Promise.all([
        db.collection('investments').get(),
        db.collection('investmentContributions').get()
      ]);
      state.investments = invSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      state.investmentContributions = contribSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      renderInvestmentCards();
    } catch (error) {
      console.error('Erro ao carregar investimentos:', error);
      showToast('Erro ao carregar investimentos.', 'error');
    }
  };

  const renderInvestmentCards = () => {
    const grid = $('#investmentsGrid');
    if (!grid) return;
    grid.innerHTML = '';
    if (state.investments.length === 0) {
      grid.innerHTML = '<p class="text-center text-muted p-4 col-span-full">Nenhum objetivo financeiro cadastrado.</p>';
      return;
    }
    state.investments.sort((a,b) => (parseLocalDateString(b.createdAt) || 0) - (parseLocalDateString(a.createdAt) || 0)).forEach(inv => {
      const contributions = state.investmentContributions.filter(c => c.investmentId === inv.id);
      const totalContributed = contributions.reduce((sum, c) => sum + parseFloat(c.amount), 0) + parseFloat(inv.amount || 0);
      const category = state.categories.investment.find(c => c.id === inv.category);
      const hasGoal = inv.goal && parseFloat(inv.goal) > 0;
      const progress = hasGoal ? Math.min(100, (totalContributed / parseFloat(inv.goal)) * 100) : 0;

      const cardEl = document.createElement('div');
      cardEl.className = 'card'; 
      cardEl.dataset.id = inv.id;
      cardEl.style.cursor = 'pointer';
      
      cardEl.innerHTML = `
        <div class="card-body">
          <div class="flex justify-between items-start mb-2">
            <h3 class="card-title">${inv.name}</h3>
            ${category ? `<span class="badge" style="background-color: var(--color-primary-bg); color: var(--color-primary); font-size: var(--font-size-xs);">
              ${category.icon} ${category.name}
            </span>` : ''}
          </div>
          <div class="mb-2 text-on-surface-variant">Guardado: <strong class="text-on-surface">${formatCurrency(totalContributed)}</strong></div>
          ${hasGoal ? `<div class="mb-2 text-on-surface-variant">Meta: <strong class="text-on-surface">${formatCurrency(inv.goal)}</strong></div>` : ''}
          ${hasGoal ? `
            <div class="mb-3">
              <div class="commitment-progress" style="height: 6px;">
                <div class="commitment-progress-bar" style="width: ${progress.toFixed(0)}%; background-color: var(--color-primary);"></div>
              </div>
              <div class="flex justify-between text-xs text-muted mt-1">
                <span>${progress.toFixed(0)}%</span>
                ${inv.targetDate ? `<span>Meta: ${formatDate(inv.targetDate)}</span>` : ''}
              </div>
            </div>` : ''}
          <div class="flex justify-between items-center mt-4 pt-3 border-t border-divider">
            <small class="text-xs text-muted">Criado em: ${formatDate(inv.createdAt)}</small>
            <div>
              <button type="button" class="btn btn-icon btn-sm btn-ghost edit-investment-btn" aria-label="Editar Objetivo">
                <i class="fas fa-edit"></i>
              </button>
              <button type="button" class="btn btn-icon btn-sm btn-ghost delete-investment-btn" aria-label="Excluir Objetivo">
                <i class="fas fa-trash text-error"></i>
              </button>
            </div>
          </div>
        </div>`;
      
      cardEl.addEventListener('click', (e) => {
        if (!e.target.closest('.edit-investment-btn') && !e.target.closest('.delete-investment-btn')) {
          openInvestmentDetail(inv.id);
        }
      });
      
      grid.appendChild(cardEl);
    });
    
    $$('#investmentsGrid .edit-investment-btn').forEach(btn => btn.addEventListener('click', (e) => {
        e.stopPropagation(); 
        openEditInvestmentModal(e.currentTarget.closest('.card').dataset.id);
    }));
    
    $$('#investmentsGrid .delete-investment-btn').forEach(btn => btn.addEventListener('click', (e) => {
        e.stopPropagation(); 
        if (confirm('Excluir este objetivo e todos os aportes relacionados?')) 
          deleteInvestment(e.currentTarget.closest('.card').dataset.id);
    }));
  };
  
  const openInvestmentDetail = (investmentId) => {
    const investment = state.investments.find(i => i.id === investmentId);
    if (!investment) return;
    state.currentInvestment = investment;
    const contributions = state.investmentContributions.filter(c => c.investmentId === investment.id);
    const totalContributed = contributions.reduce((sum, c) => sum + parseFloat(c.amount), 0) + parseFloat(investment.amount || 0);
    const category = state.categories.investment.find(c => c.id === investment.category);
    const hasGoal = investment.goal && parseFloat(investment.goal) > 0;
    const progress = hasGoal ? Math.min(100, (totalContributed / parseFloat(investment.goal)) * 100) : 0;

    $('#investmentDetailName').textContent = investment.name;
    $('#investmentDetailSaved').textContent = formatCurrency(totalContributed);
    $('#investmentDetailGoal').textContent = hasGoal ? formatCurrency(investment.goal) : 'N/A';
    $('#investmentDetailProgress').textContent = hasGoal ? `${progress.toFixed(0)}%` : 'N/A';
    $('#investmentDetailCategory').innerHTML = category ? `${category.icon} ${category.name}` : 'N/A';
    $('#investmentDetailCreatedAt').textContent = formatDate(investment.createdAt);
    $('#investmentDetailTarget').textContent = investment.targetDate ? formatDate(investment.targetDate) : 'N/A';
    $('#investmentDetailNotes').textContent = investment.notes || '-';
    renderInvestmentContributions(investmentId);
    closeModal('investmentsModal');
    openModal('investmentDetailModal');
  };

  const renderInvestmentContributions = (investmentId) => {
    const tableBody = $('#investmentHistoryTableBody');
    if (!tableBody) return;
    tableBody.innerHTML = '';
    const investment = state.investments.find(i => i.id === investmentId);
    let allContributions = [];
    if (investment && parseFloat(investment.amount) > 0) {
        allContributions.push({ id: 'initial-' + investment.id, date: investment.createdAt, amount: investment.amount, description: 'Valor inicial', isInitial: true });
    }
    allContributions = allContributions.concat(state.investmentContributions.filter(c => c.investmentId === investmentId));
    allContributions.sort((a, b) => (parseLocalDateString(b.date)||0) - (parseLocalDateString(a.date)||0));

    if (allContributions.length === 0) {
      tableBody.innerHTML = '<tr><td colspan="4" class="text-center text-muted p-4">Nenhum aporte realizado.</td></tr>';
      return;
    }
    allContributions.forEach(c => {
      const row = tableBody.insertRow();
      row.innerHTML = `
        <td>${formatDate(c.date)}</td>
        <td style="text-align: right;">${formatCurrency(c.amount)}</td>
        <td>${c.description || '-'}</td>
        <td class="transaction-actions" style="text-align: right;">
          ${c.isInitial ? '<span class="text-xs text-muted">Inicial</span>' : `
            <button type="button" class="btn btn-icon btn-sm btn-ghost edit-contribution-btn" data-id="${c.id}" aria-label="Editar Aporte">
              <i class="fas fa-edit"></i>
            </button>
            <button type="button" class="btn btn-icon btn-sm btn-ghost delete-contribution-btn" data-id="${c.id}" aria-label="Excluir Aporte">
              <i class="fas fa-trash text-error"></i>
            </button>
          `}
        </td>`;
    });
    $$('#investmentHistoryTableBody .edit-contribution-btn').forEach(btn => btn.addEventListener('click', (e) => openEditContributionModal(e.currentTarget.dataset.id)));
    $$('#investmentHistoryTableBody .delete-contribution-btn').forEach(btn => btn.addEventListener('click', (e) => { if (confirm('Excluir este aporte?')) deleteContribution(e.currentTarget.dataset.id); }));
  };

  const addInvestment = async (data) => {
    try {
      const investment = { ...data, createdAt: localDateToISOString(new Date()) };
      const docRef = await db.collection('investments').add(investment);
      investment.id = docRef.id;
      state.investments.push(investment);
      await fullUIRefresh(); 
      showToast('Objetivo financeiro adicionado!', 'success');
      return investment;
    } catch (e) { console.error(e); showToast('Erro ao adicionar objetivo.', 'error'); return null; }
  };
  const updateInvestment = async (id, data) => {
    try {
      await db.collection('investments').doc(id).update(data);
      const index = state.investments.findIndex(i => i.id === id);
      if (index !== -1) state.investments[index] = { ...state.investments[index], ...data };
      await fullUIRefresh(); 
      showToast('Objetivo atualizado!', 'success'); return true;
    } catch (e) { console.error(e); showToast('Erro ao atualizar objetivo.', 'error'); return false; }
  };
  const deleteInvestment = async (id) => {
    try {
      const batch = db.batch();
      batch.delete(db.collection('investments').doc(id));
      state.investmentContributions.filter(c => c.investmentId === id).forEach(c => batch.delete(db.collection('investmentContributions').doc(c.id)));
      await batch.commit();
      state.investments = state.investments.filter(i => i.id !== id);
      state.investmentContributions = state.investmentContributions.filter(c => c.investmentId !== id);
      await fullUIRefresh(); 
      if ($('#investmentDetailModal').classList.contains('active') && state.currentInvestment?.id === id) {
        closeModal('investmentDetailModal');
        openModal('investmentsModal');
      }
      showToast('Objetivo excluído!', 'success');
    } catch (e) { console.error(e); showToast('Erro ao excluir objetivo.', 'error'); }
  };
  const addContribution = async (data) => {
    try {
      const contribution = { ...data, createdAt: localDateToISOString(new Date()) };
      const docRef = await db.collection('investmentContributions').add(contribution);
      contribution.id = docRef.id;
      state.investmentContributions.push(contribution);
      await fullUIRefresh(); 
      if ($('#investmentDetailModal').classList.contains('active') && state.currentInvestment?.id === data.investmentId) {
        renderInvestmentContributions(data.investmentId); 
        openInvestmentDetail(data.investmentId); // Reabre para atualizar totais
      }
      showToast('Aporte adicionado!', 'success'); return contribution;
    } catch (e) { console.error(e); showToast('Erro ao adicionar aporte.', 'error'); return null; }
  };
  const updateContribution = async (id, data) => {
    try {
      await db.collection('investmentContributions').doc(id).update(data);
      const index = state.investmentContributions.findIndex(c => c.id === id);
      if (index !== -1) state.investmentContributions[index] = { ...state.investmentContributions[index], ...data };
      await fullUIRefresh(); 
      if ($('#investmentDetailModal').classList.contains('active') && state.currentInvestment?.id === data.investmentId) {
        renderInvestmentContributions(data.investmentId);
        openInvestmentDetail(data.investmentId); // Reabre para atualizar totais
      }
      showToast('Aporte atualizado!', 'success'); return true;
    } catch (e) { console.error(e); showToast('Erro ao atualizar aporte.', 'error'); return false; }
  };
  const deleteContribution = async (id) => {
    try {
      const contribToDelete = state.investmentContributions.find(c => c.id === id);
      if (!contribToDelete) return;
      await db.collection('investmentContributions').doc(id).delete();
      state.investmentContributions = state.investmentContributions.filter(c => c.id !== id);
      await fullUIRefresh(); 
      if ($('#investmentDetailModal').classList.contains('active') && state.currentInvestment?.id === contribToDelete.investmentId) {
        renderInvestmentContributions(contribToDelete.investmentId);
        openInvestmentDetail(contribToDelete.investmentId); // Reabre para atualizar totais
      }
      showToast('Aporte excluído!', 'success');
    } catch (e) { console.error(e); showToast('Erro ao excluir aporte.', 'error'); }
  };

  const openNewInvestmentModal = () => {
    $('#investmentForm').reset();
    setDateInputValue('investmentTargetDate', null); // Sem data padrão
    $('#newInvestmentModalTitle').textContent = 'Novo Objetivo Financeiro';
    $('#saveInvestmentBtn').textContent = 'Salvar Objetivo';
    $('#saveInvestmentBtn').dataset.action = 'add';
    $('#saveInvestmentBtn').removeAttribute('data-id');
    updateInvestmentCategorySelects(); 
    closeModal('investmentsModal'); 
    openModal('newInvestmentModal');
  };
  const openEditInvestmentModal = (id) => {
    const inv = state.investments.find(i => i.id === id);
    if (!inv) return;
    state.currentInvestment = inv;
    $('#investmentName').value = inv.name;
    $('#investmentAmount').value = inv.amount || 0;
    $('#investmentGoal').value = inv.goal || '';
    updateInvestmentCategorySelects(); 
    $('#investmentCategorySelect').value = inv.category || '';
    if (inv.targetDate) setDateInputValue('investmentTargetDate', inv.targetDate); else $('#investmentTargetDate').value = '';
    $('#investmentNotes').value = inv.notes || '';
    $('#newInvestmentModalTitle').textContent = 'Editar Objetivo Financeiro';
    $('#saveInvestmentBtn').textContent = 'Atualizar Objetivo';
    $('#saveInvestmentBtn').dataset.action = 'update';
    $('#saveInvestmentBtn').dataset.id = id;
    closeModal('investmentDetailModal'); 
    openModal('newInvestmentModal');
  };
  const openNewContributionModal = () => {
    $('#contributionForm').reset();
    setDateInputValue('contributionDate', new Date());
    $('#contributionInvestmentId').value = state.currentInvestment?.id || '';
    $('#newContributionModalTitle').textContent = 'Adicionar Novo Aporte';
    $('#saveContributionBtn').textContent = 'Adicionar';
    $('#saveContributionBtn').dataset.action = 'add';
    $('#saveContributionBtn').removeAttribute('data-id');
    openModal('newContributionModal');
  };
  const openEditContributionModal = (id) => {
    const contrib = state.investmentContributions.find(c => c.id === id);
    if (!contrib) return;
    state.currentContribution = contrib;
    $('#contributionInvestmentId').value = contrib.investmentId;
    $('#contributionAmount').value = contrib.amount;
    setDateInputValue('contributionDate', contrib.date);
    $('#contributionDescription').value = contrib.description || '';
    $('#newContributionModalTitle').textContent = 'Editar Aporte';
    $('#saveContributionBtn').textContent = 'Atualizar';
    $('#saveContributionBtn').dataset.action = 'update';
    $('#saveContributionBtn').dataset.id = id;
    openModal('newContributionModal');
  };

  const loadTransactions = async () => {
    try {
      const snapshot = await db.collection('transactions').get();
      state.transactions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      await fullUIRefresh(); 
    } catch (error) {
      console.error('Erro ao carregar transações:', error);
      showToast('Erro ao carregar transações.', 'error');
    }
  };

  const getInvoicePeriod = (card, invoiceDueDateRef) => {
    const refDate = parseLocalDateString(invoiceDueDateRef);
    if (!refDate || !card) return { previousClosing: null, currentClosingDate: null };

    let closingDay = parseInt(card.closingDay); // Garantir que é número
    let dueDay = parseInt(card.dueDay); // Garantir que é número

    let currentClosingYear = refDate.getUTCFullYear();
    let currentClosingMonth = refDate.getUTCMonth(); 

    // Se o dia de vencimento for menor que o dia de fechamento, o fechamento refere-se ao mês anterior ao vencimento.
    // Ex: Vence dia 05/JUL, fecha dia 28/JUN. Se estamos em JUL, fechamento foi JUN.
    // Ex: Vence dia 28/JUL, fecha dia 20/JUL. Se estamos em JUL, fechamento foi JUL.
    if (dueDay < closingDay) {
        currentClosingMonth--; // O fechamento é no mês anterior ao mês de vencimento
        if (currentClosingMonth < 0) {
            currentClosingMonth = 11;
            currentClosingYear--;
        }
    }
    // Se dueDay >= closingDay, o fechamento é no mesmo mês do vencimento
    // (ex: fecha dia 20, vence dia 28 do mesmo mês)
    
    const currentClosingDate = new Date(Date.UTC(currentClosingYear, currentClosingMonth, closingDay));
    currentClosingDate.setUTCHours(0,0,0,0); // Zera hora para comparações

    // O período de compras da fatura anterior começa no dia seguinte ao fechamento anterior
    // e vai até o dia do fechamento atual (exclusive).
    let previousClosingMonth = currentClosingMonth - 1;
    let previousClosingYear = currentClosingYear;
    if (previousClosingMonth < 0) {
        previousClosingMonth = 11;
        previousClosingYear--;
    }
    const previousClosing = new Date(Date.UTC(previousClosingYear, previousClosingMonth, closingDay));
    previousClosing.setUTCHours(0,0,0,0); // Zera hora
    
    return { previousClosing, currentClosingDate }; 
  };


  const filterTransactionsByMonth = () => {
    state.filteredTransactions = state.transactions.filter(transaction => {
        const transactionLaunchDate = parseLocalDateString(transaction.date); 
        if (!transactionLaunchDate) return false;

        let effectiveDateForFilter = transactionLaunchDate;

        if (transaction.type === 'expense') { 
            if (transaction.paymentMethod === 'credito' && transaction.creditCardId) {
                const card = state.cards.find(c => c.id === transaction.creditCardId);
                if (card) {
                    const realDueDate = calcularVencimentoReal(transactionLaunchDate, card);
                    if (realDueDate) effectiveDateForFilter = realDueDate;
                }
            } else if (transaction.dueDate) { 
                const explicitDueDate = parseLocalDateString(transaction.dueDate);
                if (explicitDueDate) effectiveDateForFilter = explicitDueDate;
            }
        }
        
        return effectiveDateForFilter.getUTCMonth() === state.month && 
               effectiveDateForFilter.getUTCFullYear() === state.year;
    });
  };

  const updateKPIs = () => {
    filterTransactionsByMonth(); 
    const currentMonthTransactions = state.filteredTransactions;

    const totalIncome = currentMonthTransactions.filter(t => t.type === 'income').reduce((sum, t) => sum + parseFloat(t.amount), 0);
    const totalExpense = currentMonthTransactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + parseFloat(t.amount), 0);
    const incomeReceived = currentMonthTransactions.filter(t => t.type === 'income' && t.status === 'received').reduce((sum, t) => sum + parseFloat(t.amount), 0);
    const incomePending = totalIncome - incomeReceived;
    const expensePaid = currentMonthTransactions.filter(t => t.type === 'expense' && t.status === 'paid').reduce((sum, t) => sum + parseFloat(t.amount), 0);
    const expensePending = totalExpense - expensePaid;

    const saldoReal = incomeReceived - expensePaid;
    const saldoComprometido = totalIncome - totalExpense;

    $('#incomeValue').textContent = formatCurrency(totalIncome);
    $('#expenseValue').textContent = formatCurrency(totalExpense); 
    $('#balanceValue').textContent = formatCurrency(saldoReal);
    const balanceSubtitleSpan = $('.kpi-balance .kpi-subtitle span');
    if (balanceSubtitleSpan) balanceSubtitleSpan.textContent = `Saldo comprometido: ${formatCurrency(saldoComprometido)}`;
    
    $('#incomeReceivedValue').textContent = `${formatCurrency(incomeReceived)} recebidos`;
    $('#incomePendingValue').textContent = `${formatCurrency(incomePending)} pendentes`;
    $('#expensePaidValue').textContent = `${formatCurrency(expensePaid)} pagos`;
    $('#expensePendingValue').textContent = `${formatCurrency(expensePending)} pendentes`;

    let totalCardDueThisMonth = 0; 
    let earliestCardDueDateThisMonth = null; 

    state.transactions.forEach(t => {
        if (t.type === 'expense' && t.paymentMethod === 'credito' && t.creditCardId) {
            const card = state.cards.find(c => c.id === t.creditCardId);
            const launchDate = parseLocalDateString(t.date);
            if(card && launchDate) {
                const effectiveDueDate = calcularVencimentoReal(launchDate, card); 
                if (effectiveDueDate &&
                    effectiveDueDate.getUTCMonth() === state.month &&
                    effectiveDueDate.getUTCFullYear() === state.year) {
                    totalCardDueThisMonth += parseFloat(t.amount);
                    if (!earliestCardDueDateThisMonth || effectiveDueDate < earliestCardDueDateThisMonth) {
                        earliestCardDueDateThisMonth = effectiveDueDate;
                    }
                }
            }
        }
    });
    $('#invoiceValue').textContent = formatCurrency(totalCardDueThisMonth); 
    $('#invoiceDueDate').textContent = earliestCardDueDateThisMonth ? formatDate(earliestCardDueDateThisMonth) : '--/--/----';
  };

  const updateCardsList = () => {
    const listEl = $('#cardsList');
    if (!listEl) return;
    listEl.innerHTML = '';
    if (state.cards.length === 0) {
      listEl.innerHTML = '<p class="text-center text-muted p-4">Nenhum cartão cadastrado.</p>';
      return;
    }
    state.cards.forEach(card => {
        const cardEl = document.createElement('div');
        cardEl.className = 'card'; 
        cardEl.style.marginBottom = 'var(--spacing-4)';
        
        const faturaVencimentoNoMesSelecionado = new Date(Date.UTC(state.year, state.month, card.dueDay));
        const { previousClosing, currentClosingDate } = getInvoicePeriod(card, faturaVencimentoNoMesSelecionado);

        let currentInvoiceAmountForMonth = 0;
        if (previousClosing && currentClosingDate) {
            const currentInvoiceTransactions = state.transactions.filter(t => {
                const tLaunchDate = parseLocalDateString(t.date);
                return t.type === 'expense' &&
                       t.paymentMethod === 'credito' &&
                       t.creditCardId === card.id &&
                       tLaunchDate >= previousClosing && // Compra feita após o fechamento anterior
                       tLaunchDate < currentClosingDate; // Compra feita antes do fechamento atual
            });
            currentInvoiceAmountForMonth = currentInvoiceTransactions.reduce((sum, t) => sum + parseFloat(t.amount), 0);
        }

        const limitPercentage = card.limit > 0 ? ((parseFloat(card.limit) - parseFloat(card.availableLimit)) / parseFloat(card.limit)) * 100 : 0;
        const melhorDia = calcularMelhorDiaCompras(card);
        const nomeMesFatura = new Date(state.year, state.month).toLocaleDateString('pt-BR', {month: 'long'});


        cardEl.innerHTML = `
            <div class="card-body">
                <div class="flex justify-between items-start mb-2">
                    <h3 class="card-title">${card.name}</h3>
                    <div>
                        <button type="button" class="btn btn-icon btn-sm btn-ghost edit-card-btn" data-id="${card.id}" aria-label="Editar Cartão">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button type="button" class="btn btn-icon btn-sm btn-ghost delete-card-btn" data-id="${card.id}" aria-label="Excluir Cartão">
                            <i class="fas fa-trash text-error"></i>
                        </button>
                    </div>
                </div>
                <div class="mb-1 text-sm text-on-surface-variant">Limite: ${formatCurrency(card.limit)}</div>
                <div class="mb-2 text-sm text-on-surface-variant">Disponível: <strong class="text-on-surface">${formatCurrency(card.availableLimit)}</strong></div>
                <div class="mb-2 commitment-progress" style="height: 6px;">
                     <div class="commitment-progress-bar" style="width: ${limitPercentage.toFixed(0)}%; background-color: ${limitPercentage > 80 ? 'var(--color-error)' : (limitPercentage > 60 ? 'var(--color-warning)' : 'var(--color-primary)')};"></div>
                </div>
                <div class="mb-1 text-xs text-muted">Fecha dia: ${card.closingDay} | Vence dia: ${card.dueDay}</div>
                <div class="mb-2 text-sm text-on-surface-variant">Fatura de ${nomeMesFatura}: <strong class="text-on-surface">${formatCurrency(currentInvoiceAmountForMonth)}</strong></div>
                ${melhorDia ? `<div class="mb-3 text-xs text-info"><i class="fas fa-info-circle"></i> Melhor dia p/ compra (próx. fatura): dia ${melhorDia}</div>` : ''}
                <button type="button" class="btn btn-primary btn-sm w-full mt-2 view-invoice-btn" data-id="${card.id}">
                    Ver Fatura de ${new Date(state.year, state.month).toLocaleDateString('pt-BR', {month: 'short'})}
                </button>
            </div>
        `;
        listEl.appendChild(cardEl);
    });
    $$('#cardsList .edit-card-btn').forEach(btn => btn.addEventListener('click', e => {
        const cardToEdit = state.cards.find(c => c.id === e.currentTarget.dataset.id);
        if(cardToEdit) openEditCardModal(cardToEdit);
    }));
    $$('#cardsList .delete-card-btn').forEach(btn => btn.addEventListener('click', e => deleteCard(e.currentTarget.dataset.id)));
    $$('#cardsList .view-invoice-btn').forEach(btn => btn.addEventListener('click', e => openCardInvoice(e.currentTarget.dataset.id)));
  };

  const openCardInvoice = (cardId) => {
    const card = state.cards.find(c => c.id === cardId);
    if (!card) return;
    state.currentCard = card; 

    const faturaVencimentoNoMesSelecionado = new Date(Date.UTC(state.year, state.month, card.dueDay));

    $('#cardInvoiceTitle').textContent = `Fatura ${card.name} - Venc. ${formatDate(faturaVencimentoNoMesSelecionado)}`;

    let currentInvoiceSum = 0;
    const { previousClosing, currentClosingDate } = getInvoicePeriod(card, faturaVencimentoNoMesSelecionado);
    
    const invoiceTransactions = state.transactions.filter(t => {
        if (t.type === 'expense' && t.paymentMethod === 'credito' && t.creditCardId === cardId) {
            const launchDate = parseLocalDateString(t.date);
            return launchDate && previousClosing && currentClosingDate &&
                   launchDate >= previousClosing &&
                   launchDate < currentClosingDate;
        }
        return false; 
    }).sort((a,b) => (parseLocalDateString(a.date)||0) - (parseLocalDateString(b.date)||0)); 

    currentInvoiceSum = invoiceTransactions.reduce((sum, t) => sum + parseFloat(t.amount), 0);

    let endOfPurchasePeriod = null;
    if (currentClosingDate) {
        endOfPurchasePeriod = new Date(currentClosingDate.getTime());
        endOfPurchasePeriod.setUTCDate(currentClosingDate.getUTCDate() - 1); // Um dia antes do fechamento atual
    }

    $('#cardInvoiceDetails').innerHTML = `
        <p class="text-sm text-on-surface-variant"><strong>Período de Compras:</strong> ${previousClosing ? formatDate(previousClosing) : 'N/A'} até ${endOfPurchasePeriod ? formatDate(endOfPurchasePeriod) : 'N/A'}</p>
        <p class="text-sm text-on-surface-variant"><strong>Vencimento desta Fatura:</strong> <strong class="text-on-surface">${formatDate(faturaVencimentoNoMesSelecionado)}</strong></p>
        <p class="text-sm text-on-surface-variant"><strong>Limite Total:</strong> ${formatCurrency(card.limit)} | <strong>Disponível:</strong> ${formatCurrency(card.availableLimit)}</p>
        <p class="text-md font-semibold text-on-surface mt-2"><strong>Valor desta Fatura:</strong> <span id="currentInvoiceValueDisplay">${formatCurrency(currentInvoiceSum)}</span></p>
    `;

    const tableBody = $('#cardInvoiceTableBody');
    tableBody.innerHTML = '';

    if (invoiceTransactions.length === 0) {
      tableBody.innerHTML = '<tr><td colspan="4" class="text-center text-muted p-4">Nenhuma despesa nesta fatura.</td></tr>';
    } else {
      invoiceTransactions.forEach(t => {
        const row = tableBody.insertRow();
        row.innerHTML = `
          <td>${t.name} ${t.isRecurrent && t.installments > 1 ? `(${t.installmentNumber}/${t.installments})` : ''}</td>
          <td>${formatDate(t.date)}</td>
          <td style="text-align: right;">${formatCurrency(t.amount)}</td>
          <td style="text-align: center;">
            <div class="form-check" style="justify-content: center; margin-bottom: 0;">
              <input type="checkbox" class="invoice-paid-checkbox" id="invoice-paid-${t.id}"
                     data-id="${t.id}" ${t.status === 'paid' ? 'checked' : ''}>
              <label class="form-check-label sr-only" for="invoice-paid-${t.id}">Pago</label>
            </div>
          </td>`;
      });
      $$('.invoice-paid-checkbox').forEach(cb => cb.addEventListener('change', async (e) => {
          await updateTransactionStatus(e.target.dataset.id, e.target.checked ? 'paid' : 'pending');
          openCardInvoice(cardId); // Reabre para atualizar a UI
      }));
    }
    $('#invoiceConfirmAmount').textContent = formatCurrency(currentInvoiceSum);
    const payInvoiceBtn = $('#payInvoiceBtn');
    if (invoiceTransactions.some(t => t.status !== 'paid')) {
        payInvoiceBtn.style.display = 'inline-flex';
        payInvoiceBtn.disabled = false;
    } else {
        payInvoiceBtn.disabled = true; // Ou payInvoiceBtn.style.display = 'none';
    }
    closeModal('cardsListModal'); 
    openModal('cardInvoiceModal');
  };

  let categoryExpensesChart, cardUsageDonutChart, annualBarsChart, fixedVsVariableChart, personAnalysisChart;
  
  const getChartPalette = () => {
    const style = getComputedStyle(document.documentElement);
    return [
        style.getPropertyValue('--chart-color-1').trim(),
        style.getPropertyValue('--chart-color-2').trim(),
        style.getPropertyValue('--chart-color-3').trim(),
        style.getPropertyValue('--chart-color-4').trim(),
        style.getPropertyValue('--chart-color-5').trim(),
        style.getPropertyValue('--chart-color-6').trim(),
        style.getPropertyValue('--chart-color-7').trim(),
        style.getPropertyValue('--chart-color-8').trim(),
    ];
  };
  
  const createCharts = () => {
    const isDarkTheme = document.documentElement.getAttribute('data-theme') === 'dark';
    const style = getComputedStyle(document.documentElement);
    const textColor = style.getPropertyValue('--color-on-surface-variant').trim();
    const onSurfaceColor = style.getPropertyValue('--color-on-surface').trim();
    const gridColor = style.getPropertyValue('--color-divider').trim();
    const chartPalette = getChartPalette();
    
    const commonChartOptions = {
        fontFamily: 'var(--font-sans)',
        foreColor: textColor,
        tooltip: { theme: isDarkTheme ? 'dark' : 'light' },
        grid: { borderColor: gridColor, strokeDashArray: 3, padding: { left: 0, right: 0 } },
        xaxis: { labels: { style: { colors: textColor, fontFamily: 'var(--font-sans)' } }, axisBorder: { show: false }, axisTicks: { show: false } },
        yaxis: { labels: { style: { colors: textColor, fontFamily: 'var(--font-sans)' }, formatter: val => 'R$ ' + val.toFixed(0) } }
    };

    const categoryExpensesOptions = {
      series: [{ name: 'Valor', data: [] }],
      chart: { type: 'bar', height: 350, toolbar: { show: false }, ...commonChartOptions.chart },
      plotOptions: { bar: { borderRadius: 6, columnWidth: '55%', distributed: true, dataLabels: { position: 'top' } } },
      dataLabels: { enabled: true, formatter: (val, opts) => {
          const total = opts.w.globals.seriesTotals.reduce((a, b) => a + b, 0);
          return total > 0 ? Math.round((val / total) * 100) + '%' : '0%';
        }, offsetY: -20, style: { fontSize: '11px', fontFamily: 'var(--font-sans)', colors: [textColor] }
      },
      colors: chartPalette,
      xaxis: { ...commonChartOptions.xaxis, categories: [] },
      yaxis: { ...commonChartOptions.yaxis, title: { text: 'Valor (R$)', style: { color: textColor, fontFamily: 'var(--font-sans)' } } },
      grid: commonChartOptions.grid, tooltip: commonChartOptions.tooltip,
    };
    
    const cardUsageDonutOptions = {
      series: [0, 0],
      chart: { type: 'donut', height: 350, ...commonChartOptions.chart },
      labels: ['Utilizado', 'Disponível'],
      colors: [style.getPropertyValue('--color-error').trim(), style.getPropertyValue('--color-primary').trim()],
      plotOptions: { pie: { donut: { size: '70%', labels: { show: false } } } },
      dataLabels: { enabled: false }, legend: { show: false }, stroke: { width: 0 },
      tooltip: { ...commonChartOptions.tooltip, y: { formatter: (val, opts) => {
            const total = opts.w.globals.seriesTotals.reduce((a, b) => a + b, 0);
            return `${formatCurrency(val)} (${total > 0 ? Math.round((val / total) * 100) : 0}%)`;
      }}},
      responsive: [{ breakpoint: 480, options: { chart: { height: 300 } } }],
    };
    
    const fixedVsVariableOptions = {
      series: [0, 0],
      chart: { type: 'donut', height: 350, ...commonChartOptions.chart },
      labels: ['Fixas', 'Variáveis'],
      colors: [style.getPropertyValue('--chart-color-2').trim(), style.getPropertyValue('--chart-color-4').trim()],
      plotOptions: { pie: { donut: { size: '65%', labels: { show: true, name: { show: true, color: textColor }, 
            value: { show: true, color: onSurfaceColor, formatter: (val, opts) => {
                const total = opts.w.globals.seriesTotals.reduce((a, b) => a + b, 0);
                return total > 0 ? Math.round((val / total) * 100) + '%' : '0%';
            }},
            total: { show: true, label: 'Total', color: onSurfaceColor, formatter: w => formatCurrency(w.globals.seriesTotals.reduce((a, b) => a + b, 0)) }
      }}}},
      dataLabels: { enabled: false }, legend: { show: false }, stroke: { width: 0 },
      tooltip: { ...commonChartOptions.tooltip, y: { formatter: (val, opts) => {
        const total = opts.w.globals.seriesTotals.reduce((a, b) => a + b, 0);
        return `${formatCurrency(val)} (${total > 0 ? Math.round((val / total) * 100) : 0}%)`;
      }}},
      responsive: [{ breakpoint: 480, options: { chart: { height: 300 } } }],
    };
    
    const personAnalysisOptions = {
      series: [{ name: 'Valor', data: [] }],
      chart: { type: 'bar', height: 350, toolbar: { show: false }, ...commonChartOptions.chart },
      plotOptions: { bar: { horizontal: true, borderRadius: 6, dataLabels: { position: 'top' } } }, // position: 'top' for horizontal
      colors: chartPalette.slice(0,4), // Use a subset of the palette
      dataLabels: { enabled: true, formatter: (val, opts) => {
          const total = opts.w.globals.seriesTotals.reduce((a,b) => a+b,0); return total > 0 ? Math.round((val/total)*100) + '%' : '0%';
        }, offsetX: 5, style: { fontSize: '11px', fontFamily: 'var(--font-sans)', colors: [onSurfaceColor] }
      },
      xaxis: { ...commonChartOptions.xaxis, labels: { ...commonChartOptions.xaxis.labels, formatter: val => 'R$ ' + val.toFixed(0) }},
      yaxis: { ...commonChartOptions.yaxis, labels: { ...commonChartOptions.yaxis.labels, style: { ...commonChartOptions.yaxis.labels.style, colors: onSurfaceColor } } },
      grid: commonChartOptions.grid, tooltip: commonChartOptions.tooltip,
    };
    
    const annualBarsOptions = {
      series: [ { name: 'Receitas', type: 'column', data: [] }, { name: 'Despesas', type: 'column', data: [] }, { name: 'Saldo', type: 'line', data: [] } ],
      chart: { height: 350, type: 'line', stacked: false, toolbar: { show: false }, ...commonChartOptions.chart },
      stroke: { width: [0, 0, 2.5], curve: 'smooth' },
      plotOptions: { bar: { borderRadius: 6, columnWidth: '60%' } },
      colors: [style.getPropertyValue('--color-income').trim(), style.getPropertyValue('--color-expense').trim(), style.getPropertyValue('--color-primary').trim()],
      fill: { opacity: [0.85, 0.85, 1], gradient: { inverseColors: false, shade: 'light', type: "vertical", opacityFrom: 0.85, opacityTo: 0.55, stops: [0, 100, 100, 100] } },
      labels: [], markers: { size: 4, hover: { size: 6 } }, legend: { show: false },
      xaxis: { ...commonChartOptions.xaxis },
      yaxis: { ...commonChartOptions.yaxis, title: { text: 'Valor (R$)', style: { color: textColor, fontFamily: 'var(--font-sans)' } } },
      tooltip: { ...commonChartOptions.tooltip, shared: true, intersect: false, y: { formatter: y => typeof y !== "undefined" ? "R$ " + y.toFixed(2) : y } },
      grid: commonChartOptions.grid
    };
    
    if ($('#categoryExpensesChart')) categoryExpensesChart = new ApexCharts($('#categoryExpensesChart'), categoryExpensesOptions);
    if ($('#cardUsageDonutChart')) cardUsageDonutChart = new ApexCharts($('#cardUsageDonutChart'), cardUsageDonutOptions);
    if ($('#fixedVsVariableChart')) fixedVsVariableChart = new ApexCharts($('#fixedVsVariableChart'), fixedVsVariableOptions);
    if ($('#personAnalysisChart')) personAnalysisChart = new ApexCharts($('#personAnalysisChart'), personAnalysisOptions);
    if ($('#annualBarsChart')) annualBarsChart = new ApexCharts($('#annualBarsChart'), annualBarsOptions);
    
    if (categoryExpensesChart) categoryExpensesChart.render();
    if (cardUsageDonutChart) cardUsageDonutChart.render();
    if (fixedVsVariableChart) fixedVsVariableChart.render();
    if (personAnalysisChart) personAnalysisChart.render();
    if (annualBarsChart) annualBarsChart.render();
  };
  
  const updateChartColors = () => {
    if (!categoryExpensesChart) return; 
    
    const isDarkTheme = document.documentElement.getAttribute('data-theme') === 'dark';
    const style = getComputedStyle(document.documentElement);
    const textColor = style.getPropertyValue('--color-on-surface-variant').trim();
    const onSurfaceColor = style.getPropertyValue('--color-on-surface').trim();
    const gridColor = style.getPropertyValue('--color-divider').trim();
    const chartPalette = getChartPalette();

    const chartsToUpdate = [
        { chart: categoryExpensesChart, options: { colors: chartPalette, xaxis: { labels: { style: {colors: textColor}}}, yaxis: { labels: { style: {colors: textColor}}, title: {style: {color: textColor}}} } },
        { chart: cardUsageDonutChart, options: { colors: [style.getPropertyValue('--color-error').trim(), style.getPropertyValue('--color-primary').trim()] } },
        { chart: fixedVsVariableChart, options: { colors: [style.getPropertyValue('--chart-color-2').trim(), style.getPropertyValue('--chart-color-4').trim()], plotOptions: { pie: { donut: { labels: { name: {color: textColor}, value: {color: onSurfaceColor}, total: {color: onSurfaceColor} } } } } } },
        { chart: personAnalysisChart, options: { colors: chartPalette.slice(0,4), xaxis: { labels: { style: {colors: textColor}}}, yaxis: { labels: { style: {colors: onSurfaceColor}}}, dataLabels: {style: {colors: [onSurfaceColor]}} } },
        { chart: annualBarsChart, options: { colors: [style.getPropertyValue('--color-income').trim(), style.getPropertyValue('--color-expense').trim(), style.getPropertyValue('--color-primary').trim()], xaxis: { labels: { style: {colors: textColor}}}, yaxis: { labels: { style: {colors: textColor}}, title: {style: {color: textColor}}} } }
    ];
    
    chartsToUpdate.forEach(item => {
      if (item.chart) {
        item.chart.updateOptions({
          ...item.options,
          grid: { borderColor: gridColor },
          tooltip: { theme: isDarkTheme ? 'dark' : 'light' }
        });
      }
    });
    // Atualiza o texto central do donut de uso do cartão
    if (cardUsageDonutChart && cardUsageDonutChart.w && cardUsageDonutChart.w.globals && cardUsageDonutChart.w.globals.series) {
        const usado = cardUsageDonutChart.w.globals.series[0] !== undefined ? cardUsageDonutChart.w.globals.series[0] : 0;
        const total = cardUsageDonutChart.w.globals.series.reduce((a, b) => a + b, 0);
        const percentual = total > 0 ? Math.round((usado / total) * 100) : 0;
        
        const limitValueEl = $('.limit-value');
        if (limitValueEl) {
            limitValueEl.textContent = `${percentual}%`;
            if (percentual > 80) limitValueEl.style.color = 'var(--color-error)';
            else if (percentual > 60) limitValueEl.style.color = 'var(--color-warning)';
            else limitValueEl.style.color = 'var(--color-on-surface)';
        }
    }
  };

  const updateCharts = () => {
    if (!categoryExpensesChart) { // Se não existem, cria
        createCharts();
        // A primeira chamada a updateChartColors é feita dentro de createCharts implicitamente pelos temas
    }
    const currentMonthTransactions = state.filteredTransactions;

    // 1. Despesas por Categoria
    const expenseCategories = currentMonthTransactions
      .filter(t => t.type === 'expense')
      .reduce((acc, t) => {
        const cat = state.categories.expense.find(c => c.id === t.category);
        const displayName = cat ? `${cat.icon || ''} ${cat.name}` : (t.categoryName || 'Outros');
        acc[displayName] = (acc[displayName] || 0) + parseFloat(t.amount);
        return acc;
      }, {});
    const sortedCategories = Object.entries(expenseCategories).sort((a, b) => b[1] - a[1]);

    if (categoryExpensesChart) {
      categoryExpensesChart.updateOptions({ xaxis: { categories: sortedCategories.map(item => item[0]) } });
      categoryExpensesChart.updateSeries([{ data: sortedCategories.map(item => item[1]) }]);
    }

    // 2. Uso do Limite (Cartões)
    const totalLimitAllCards = state.cards.reduce((sum, c) => sum + parseFloat(c.limit || 0), 0);
    const totalAvailableAllCards = state.cards.reduce((sum, c) => sum + parseFloat(c.availableLimit || 0), 0);
    const totalUsedAllCards = totalLimitAllCards - totalAvailableAllCards;
    
    if (cardUsageDonutChart) {
      cardUsageDonutChart.updateSeries(totalLimitAllCards > 0 ? [totalUsedAllCards, totalAvailableAllCards] : [1, 0]); // Evita erro com 0 total
      // O texto central é atualizado em updateChartColors
    }
    
    // 3. Despesas Fixas vs Variáveis
    const fixed = currentMonthTransactions.filter(t => t.type === 'expense' && t.isFixed === 'fixed').reduce((s, t) => s + parseFloat(t.amount), 0);
    const variable = currentMonthTransactions.filter(t => t.type === 'expense' && t.isFixed === 'variable').reduce((s, t) => s + parseFloat(t.amount), 0);
    if (fixedVsVariableChart) {
      fixedVsVariableChart.updateSeries([fixed, variable]);
    }
    
    // 4. Despesas por Pessoa
    const personExpenses = currentMonthTransactions
      .filter(t => t.type === 'expense' && t.person)
      .reduce((acc, t) => {
        const person = state.people.find(p => p.id === t.person);
        const personName = person ? `${person.icon || ''} ${person.name}` : 'Não atribuído';
        acc[personName] = (acc[personName] || 0) + parseFloat(t.amount);
        return acc;
      }, {});
    const sortedPersons = Object.entries(personExpenses).sort((a, b) => b[1] - a[1]);
    
    if (personAnalysisChart) {
      personAnalysisChart.updateOptions({ yaxis: { categories: sortedPersons.map(item => item[0]) } });
      personAnalysisChart.updateSeries([{ data: sortedPersons.map(item => item[1]) }]);
    }
    
    // 5. Receitas x Despesas (12 meses)
    const annualData = Array(12).fill(null).map(() => ({ income: 0, expense: 0 }));
    const todayForAnnual = new Date(Date.UTC(state.year, state.month, 1));
    
    state.transactions.forEach(t => {
      const tLaunchDate = parseLocalDateString(t.date);
      if (!tLaunchDate) return;
      
      let effectiveDateForAnnualChart = tLaunchDate;
      if (t.type === 'expense') {
        if (t.paymentMethod === 'credito' && t.creditCardId) {
          const card = state.cards.find(c => c.id === t.creditCardId);
          if (card) {
            const realDueDate = calcularVencimentoReal(tLaunchDate, card);
            if (realDueDate) effectiveDateForAnnualChart = realDueDate;
          }
        } else if (t.dueDate) {
          const explicitDueDate = parseLocalDateString(t.dueDate);
          if (explicitDueDate) effectiveDateForAnnualChart = explicitDueDate;
        }
      }
      
      const monthDiff = (todayForAnnual.getUTCFullYear() - effectiveDateForAnnualChart.getUTCFullYear()) * 12 + (todayForAnnual.getUTCMonth() - effectiveDateForAnnualChart.getUTCMonth());
      if (monthDiff >= 0 && monthDiff < 12) {
        const indexInAnnualArray = 11 - monthDiff;
        if (t.type === 'income') annualData[indexInAnnualArray].income += parseFloat(t.amount);
        else if (t.type === 'expense') annualData[indexInAnnualArray].expense += parseFloat(t.amount);
      }
    });
    
    const labels = Array(12).fill(null).map((_, i) => {
      const d = new Date(todayForAnnual);
      d.setUTCMonth(todayForAnnual.getUTCMonth() - (11 - i));
      return d.toLocaleDateString('pt-BR', { month: 'short', year: '2-digit', timeZone: 'UTC' });
    });
    
    if (annualBarsChart) {
      annualBarsChart.updateOptions({ labels: labels });
      annualBarsChart.updateSeries([
        { name: 'Receitas', data: annualData.map(d => d.income) },
        { name: 'Despesas', data: annualData.map(d => d.expense) },
        { name: 'Saldo', data: annualData.map(d => d.income - d.expense) }
      ]);
    }
    updateChartColors(); // Garante que as cores sejam aplicadas após a atualização dos dados
  };

  const toggleCommitments = () => {
    const content = $('#commitmentsContent');
    const icon = $('#commitmentToggleIcon');
    if (!content || !icon) return;
    
    const isExpanded = content.classList.contains('expanded');
    if (isExpanded) {
      content.style.maxHeight = '0px';
      icon.style.transform = 'rotate(0deg)';
      content.classList.remove('expanded');
    } else {
      content.style.maxHeight = content.scrollHeight + 'px';
      icon.style.transform = 'rotate(-180deg)';
      content.classList.add('expanded');
    }
  };

  const generateInsights = () => {
    const container = $('#insightsBannerContainer');
    if (!container) return;
    container.innerHTML = '';
    state.insights = [];
    const today = new Date(); today.setUTCHours(0,0,0,0); 

    const overdue = state.transactions.filter(t => {
        if (t.type !== 'expense' || t.status === 'paid') return false;
        let effectiveDueDate = getEffectiveDueDateForSort(t); // Usa a função de data efetiva
        if (!effectiveDueDate) return false;
        return effectiveDueDate < today;
    });

    if (overdue.length > 0) {
      state.insights.push({ 
        id: 'overdue', level: 'danger', icon: 'exclamation-triangle', 
        message: `Você tem ${overdue.length} conta(s) vencida(s).`, 
        actionText: 'Ver Contas', 
        action: () => openDueTransactionsModal(overdue, 'Contas Vencidas', 'danger') 
      });
    }

    const upcomingDateLimit = new Date(today); upcomingDateLimit.setUTCDate(today.getUTCDate() + 5);
    const upcoming = state.transactions.filter(t => {
        if (t.type !== 'expense' || t.status === 'paid') return false;
        let effectiveDueDate = getEffectiveDueDateForSort(t);
        if (!effectiveDueDate) return false;
        return effectiveDueDate >= today && effectiveDueDate <= upcomingDateLimit;
    });
    
    if (upcoming.length > 0) {
      state.insights.push({ 
        id: 'upcoming', level: 'warning', icon: 'calendar-alt', 
        message: `Você tem ${upcoming.length} conta(s) a vencer nos próximos 5 dias.`, 
        actionText: 'Ver Contas', 
        action: () => openDueTransactionsModal(upcoming, 'Contas a Vencer', 'warning') 
      }); 
    }
    
    state.cards.filter(c => parseFloat(c.availableLimit) < (parseFloat(c.limit) * 0.2)).forEach(c => {
        state.insights.push({ 
          id: `low-limit-${c.id}`, level: 'info', icon: 'credit-card', 
          message: `Limite baixo no cartão ${c.name}. (Disponível: ${formatCurrency(c.availableLimit)})`, 
          actionText: 'Ver Cartão', 
          action: () => { 
            openModal('cardsListModal'); 
            // Não é possível abrir diretamente a fatura, pois openCardInvoice pode depender de contexto não presente
          } 
        });
    });

    state.insights.forEach(insight => {
      const el = document.createElement('div');
      el.className = `insight-banner insight-${insight.level}`;
      el.innerHTML = `
        <div class="insight-icon">
          <i class="fas fa-${insight.icon}"></i>
        </div>
        <div class="insight-content">
          <div class="insight-title">${insight.message}</div>
        </div>
        <button type="button" class="btn btn-sm btn-outline insight-action" data-id="${insight.id}">${insight.actionText}</button>`;
      container.appendChild(el);
    });
    
    $$('.insight-action').forEach(btn => btn.addEventListener('click', e => {
      const insight = state.insights.find(i => i.id === e.currentTarget.dataset.id);
      if (insight && insight.action) insight.action();
    }));
  };
  
  const openDueTransactionsModal = (transactions, title, type) => {
    $('#dueTransactionsModalTitleText').textContent = title;
    const iconEl = $('#dueTransactionsModalIcon');
    iconEl.className = type === 'danger' ? 'fas fa-exclamation-triangle text-error' : 'fas fa-calendar-alt text-warning';
    
    const tableBody = $('#dueTransactionsTableBody');
    tableBody.innerHTML = '';
    if (transactions.length === 0) {
      tableBody.innerHTML = `<tr><td colspan="5" class="text-center text-muted p-4">Nenhuma conta encontrada.</td></tr>`;
    } else {
      transactions.sort((a,b) => (getEffectiveDueDateForSort(a)||0) - (getEffectiveDueDateForSort(b)||0) )
      .forEach(t => {
        const cat = state.categories.expense.find(c => c.id === t.category);
        const effectiveDueDateForDisplay = getEffectiveDueDateForSort(t);

        const row = tableBody.insertRow();
        row.innerHTML = `
          <td>${t.name}</td>
          <td>${cat ? `${cat.icon} ${cat.name}` : (t.categoryName || t.category)}</td>
          <td>${effectiveDueDateForDisplay ? formatDate(effectiveDueDateForDisplay) : formatDate(t.date)}</td>
          <td style="text-align: right;">${formatCurrency(t.amount)}</td>
          <td class="transaction-actions" style="text-align: right;">
            <button type="button" class="btn btn-success btn-sm mark-paid-due-btn" data-id="${t.id}">
              <i class="fas fa-check"></i> Pagar
            </button>
            <button type="button" class="btn btn-outline btn-sm edit-due-btn" data-id="${t.id}">
              <i class="fas fa-edit"></i> Editar
            </button>
          </td>`;
      });
      $$('.mark-paid-due-btn').forEach(btn => btn.addEventListener('click', async e => {
          await updateTransactionStatus(e.target.dataset.id, 'paid');
          const remaining = transactions.filter(tr => tr.id !== e.target.dataset.id && tr.status !== 'paid'); 
          if (remaining.length > 0) openDueTransactionsModal(remaining, title, type);
          else closeModal('dueTransactionsModal');
          generateInsights(); 
      }));
      $$('.edit-due-btn').forEach(btn => btn.addEventListener('click', e => {
          const transaction = state.transactions.find(t => t.id === e.target.dataset.id);
          if (transaction) {
              closeModal('dueTransactionsModal');
              openEditModal(transaction);
          }
      }));
    }
    $('#payAllDueBtn').style.display = transactions.some(t => t.status !== 'paid') ? 'inline-flex' : 'none';
    openModal('dueTransactionsModal');
  };


  const renderCommitments = () => {
    const content = $('#commitmentsContent');
    if (!content) return;
    content.innerHTML = '';
    const recurrent = state.transactions.filter(t => t.isRecurrent && t.installments && t.installmentNumber && parseInt(t.installments) > parseInt(t.installmentNumber));
    if (recurrent.length === 0) {
      content.innerHTML = '<p class="text-center text-muted p-6">Nenhum compromisso longo ativo.</p>';
      // Se estiver expandido e ficar vazio, recolhe
      if (content.classList.contains('expanded')) toggleCommitments();
      return;
    }
    const grouped = recurrent.reduce((acc, t) => {
        const key = t.recurrenceId || t.id; 
        if (!acc[key] || parseInt(acc[key].installmentNumber) > parseInt(t.installmentNumber)) { 
            acc[key] = t;
        }
        return acc;
    }, {});

    const commitmentList = document.createElement('div');
    commitmentList.className = 'commitment-list';
    
    Object.values(grouped).sort((a,b) => (parseInt(a.installmentNumber)/parseInt(a.installments)) - (parseInt(b.installmentNumber)/parseInt(b.installments))).forEach(c => {
      const progress = (parseInt(c.installmentNumber) / parseInt(c.installments)) * 100;
      const cat = c.type === 'income' ? state.categories.income.find(cat=>cat.id===c.category) : state.categories.expense.find(cat=>cat.id===c.category);
      
      const item = document.createElement('div');
      item.className = 'commitment-item';
      item.innerHTML = `
        <div class="commitment-icon" style="background-color: ${c.type==='income'?'var(--color-income)':'var(--color-expense)'};">
          ${cat?.icon ? cat.icon : (c.type === 'income' ? '💰' : '💸')}
        </div>
        <div class="commitment-item .commitment-content"> <!-- Corrigido nome da classe -->
          <div class="commitment-info">
            <span class="commitment-name">${c.name}</span>
            <span class="commitment-amount">${formatCurrency(c.amount)}</span>
          </div>
          <div class="commitment-details">
            <span>${cat?.name || c.categoryName || c.category}</span>
            <span>Parcela ${c.installmentNumber}/${c.installments}</span>
          </div>
          <div class="commitment-progress">
            <div class="commitment-progress-bar" style="width:${progress}%; background-color:${c.type==='income'?'var(--color-income)':'var(--color-expense)'};"></div>
          </div>
        </div>`;
      commitmentList.appendChild(item);
    });
    
    content.appendChild(commitmentList);
    // Se estava expandido, recalcula a altura
    if (content.classList.contains('expanded')) {
        content.style.maxHeight = content.scrollHeight + "px";
    }
  };

  const createTransactionFilters = () => {
    const container = $('#transaction-filters');
    if (!container) return;
    container.innerHTML = ''; 

    const createSelect = (id, label, options) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'select-wrapper';
        let optionsHTML = `<option value="">${label}</option>`;
        options.forEach(opt => optionsHTML += `<option value="${opt.value}">${opt.text}</option>`);
        wrapper.innerHTML = `<select id="${id}" class="filter-select">${optionsHTML}</select>`;
        container.appendChild(wrapper);
        return $(`#${id}`);
    };

    createSelect('filter-transaction-type', 'Todos os Tipos', [
        {value: 'income', text: 'Receitas'}, {value: 'expense', text: 'Despesas'}
    ]).addEventListener('change', e => { state.filters.transactionType = e.target.value; updateTransactionsTable(); });
    
    createSelect('filter-category', 'Todas Categorias', 
        [...state.categories.income, ...state.categories.expense]
        .sort((a,b) => a.name.localeCompare(b.name))
        .map(c => ({value: c.id, text: `${c.icon||''} ${c.name}`})) 
    ).addEventListener('change', e => { state.filters.category = e.target.value; updateTransactionsTable(); });

    createSelect('filter-status', 'Todos Status', [
        {value:'paid',text:'Pago'},{value:'pending',text:'Pendente'},{value:'scheduled',text:'Agendado'},{value:'received',text:'Recebido'}
    ]).addEventListener('change', e => { state.filters.status = e.target.value; updateTransactionsTable(); });
    
    createSelect('filter-payment-method', 'Todos Pagamentos', 
        state.paymentMethods.map(p => ({value: p.id, text: `${p.icon||''} ${p.name}`}))
    ).addEventListener('change', e => { state.filters.paymentMethod = e.target.value; updateTransactionsTable(); });
    
    createSelect('filter-person', 'Todas Pessoas', 
        state.people.map(p => ({value: p.id, text: `${p.icon||''} ${p.name}`}))
    ).addEventListener('change', e => { state.filters.person = e.target.value; updateTransactionsTable(); });
  };

  const setupSortableColumns = () => {
    $$('#transactionsTable th.sortable').forEach(header => {
      header.addEventListener('click', () => {
        const column = header.dataset.sort;
        if (state.sortColumn === column) {
          state.sortDirection = state.sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          state.sortColumn = column;
          state.sortDirection = (column === 'date' || column === 'dueDate') ? 'asc' : (column === 'amount' ? 'desc' : 'asc');
        }
        $$('#transactionsTable th.sortable').forEach(h => {
          h.classList.remove('sorted-asc', 'sorted-desc');
          if (h.dataset.sort === state.sortColumn) {
            h.classList.add(`sorted-${state.sortDirection}`);
          }
        });
        updateTransactionsTable();
      });
    });
  };

  const getEffectiveDueDateForSort = (transaction) => {
    let effectiveDate = parseLocalDateString(transaction.date); 
    if (transaction.type === 'expense') {
        if (transaction.paymentMethod === 'credito' && transaction.creditCardId) {
            const card = state.cards.find(c => c.id === transaction.creditCardId);
            const launchDate = parseLocalDateString(transaction.date);
            if (card && launchDate) {
                const realCardDueDate = calcularVencimentoReal(launchDate, card);
                if (realCardDueDate) effectiveDate = realCardDueDate;
            }
        } else if (transaction.dueDate) {
            const explicitDueDate = parseLocalDateString(transaction.dueDate);
            if (explicitDueDate) effectiveDate = explicitDueDate;
        }
    }
    return effectiveDate;
  };


  const updateTransactionsTable = () => {
    const tableBody = $('#transactionsTableBody');
    if (!tableBody) return;
    if (!$('#filter-transaction-type')) createTransactionFilters(); 
    
    const sortableHeaders = $$('#transactionsTable th.sortable');
    if (sortableHeaders.length > 0 && !sortableHeaders[0].classList.contains('has-listener')) { 
        setupSortableColumns();
        sortableHeaders.forEach(h => h.classList.add('has-listener'));
         // Set initial sort indicator for dueDate
        const dueDateHeader = Array.from(sortableHeaders).find(h => h.dataset.sort === 'dueDate');
        if(dueDateHeader) dueDateHeader.classList.add('sorted-asc');
    }


    let transactionsToDisplay = [...state.filteredTransactions]; 
    if (state.filters.transactionType) transactionsToDisplay = transactionsToDisplay.filter(t => t.type === state.filters.transactionType);
    if (state.filters.category) transactionsToDisplay = transactionsToDisplay.filter(t => t.category === state.filters.category);
    if (state.filters.status) transactionsToDisplay = transactionsToDisplay.filter(t => t.status === state.filters.status);
    if (state.filters.paymentMethod) transactionsToDisplay = transactionsToDisplay.filter(t => t.paymentMethod === state.filters.paymentMethod);
    if (state.filters.person) transactionsToDisplay = transactionsToDisplay.filter(t => t.person === state.filters.person);

    transactionsToDisplay.sort((a, b) => {
      let valA, valB;
      switch(state.sortColumn) {
        case 'name': valA = (a.name || '').toLowerCase(); valB = (b.name || '').toLowerCase(); break;
        case 'person': 
            valA = (state.people.find(p=>p.id===a.person)?.name || '').toLowerCase(); 
            valB = (state.people.find(p=>p.id===b.person)?.name || '').toLowerCase(); 
            break;
        case 'date': valA = parseLocalDateString(a.date); valB = parseLocalDateString(b.date); break; 
        case 'dueDate': 
            valA = getEffectiveDueDateForSort(a); valB = getEffectiveDueDateForSort(b);
            if (valA === null && valB !== null) return state.sortDirection === 'asc' ? 1 : -1; 
            if (valA !== null && valB === null) return state.sortDirection === 'asc' ? -1 : 1; 
            if (valA === null && valB === null) return 0;
            break;
        case 'amount': valA = parseFloat(a.amount || 0); valB = parseFloat(b.amount || 0); break;
        case 'status': valA = a.status || ''; valB = b.status || ''; break;
        case 'paymentMethod': 
            valA = (state.paymentMethods.find(p=>p.id===a.paymentMethod)?.name || '').toLowerCase(); 
            valB = (state.paymentMethods.find(p=>p.id===b.paymentMethod)?.name || '').toLowerCase(); 
            break;
        default: valA = getEffectiveDueDateForSort(a); valB = getEffectiveDueDateForSort(b);
      }
      const comparison = (valA < valB) ? -1 : ((valA > valB) ? 1 : 0);
      return state.sortDirection === 'desc' ? -comparison : comparison;
    });

    tableBody.innerHTML = '';
    if (transactionsToDisplay.length === 0) {
      tableBody.innerHTML = `<tr><td colspan="9" class="text-center text-muted p-6">Nenhuma transação encontrada para este mês ou filtros aplicados.</td></tr>`;
      return;
    }
    
    transactionsToDisplay.forEach(t => {
      const row = tableBody.insertRow();
      const cat = t.type === 'income' ? state.categories.income.find(c=>c.id===t.category) : state.categories.expense.find(c=>c.id===t.category);
      const person = state.people.find(p=>p.id===t.person);
      const payment = state.paymentMethods.find(p=>p.id===t.paymentMethod);
      
      let statusText, statusClass;
      if (t.type === 'income') {
          statusText = t.status === 'received' ? 'Recebido' : 'A Receber';
          statusClass = t.status === 'received' ? 'badge-success' : 'badge-warning';
      } else { 
          if (t.status === 'paid') { statusText = 'Pago'; statusClass = 'badge-success'; }
          else if (t.status === 'scheduled') { statusText = 'Agendado'; statusClass = 'badge-info'; }
          else { statusText = 'Pendente'; statusClass = 'badge-warning'; }
      }
      
      const effectiveDueDateForDisplay = getEffectiveDueDateForSort(t);
      const iconHTML = cat?.icon ? cat.icon : (t.type === 'income' ? '💰' : '💸');
      
      row.innerHTML = `
        <td>
          <div class="transaction-name-cell">
            <div class="transaction-icon" style="background-color: ${t.type==='income'? 'var(--color-income-light)' : 'var(--color-error-light)'}; color: ${t.type==='income'?'var(--color-income)':'var(--color-expense)'};">
              ${iconHTML}
            </div>
            <span>${t.name} ${t.isRecurrent && t.installments > 1 ? `(${t.installmentNumber}/${t.installments})` : ''}</span>
          </div>
        </td>
        <td>${person ? `${person.icon||''} ${person.name}` : '-'}</td>
        <td>${formatDate(t.date)}</td> 
        <td>${effectiveDueDateForDisplay ? formatDate(effectiveDueDateForDisplay) : '-'}</td> 
        <td style="text-align: right;">${formatCurrency(t.amount)}</td>
        <td style="text-align: center;"><span class="badge ${statusClass}">${statusText}</span></td>
        <td>${payment ? `${payment.icon||''} ${payment.name}` : (t.paymentMethodName || t.paymentMethod || '-')}</td>
        <td style="text-align: center;">
          <div class="form-check" style="justify-content: center; margin-bottom: 0;">
            <input type="checkbox" class="transaction-paid-checkbox" id="paid-${t.id}" 
                   data-id="${t.id}" data-type="${t.type}" 
                   ${t.status === (t.type === 'income' ? 'received' : 'paid') ? 'checked' : ''}>
            <label class="form-check-label sr-only" for="paid-${t.id}">Pago</label>
          </div>
        </td>
        <td class="transaction-actions" style="text-align: right;">
          <button type="button" class="btn btn-icon btn-sm btn-ghost edit-transaction-btn" data-id="${t.id}" aria-label="Editar Transação">
            <i class="fas fa-edit"></i>
          </button>
          <button type="button" class="btn btn-icon btn-sm btn-ghost delete-transaction-btn" data-id="${t.id}" aria-label="Excluir Transação">
            <i class="fas fa-trash text-error"></i>
          </button>
        </td>`;
    });
    
    $$('.transaction-paid-checkbox').forEach(cb => cb.addEventListener('change', e => updateTransactionStatus(e.target.dataset.id, e.target.checked ? (e.target.dataset.type === 'income' ? 'received' : 'paid') : 'pending')));
    $$('.edit-transaction-btn').forEach(btn => btn.addEventListener('click', e => openEditModal(state.transactions.find(t => t.id === e.currentTarget.dataset.id))));
    $$('.delete-transaction-btn').forEach(btn => btn.addEventListener('click', e => openDeleteConfirmModal(state.transactions.find(t => t.id === e.currentTarget.dataset.id))));
  };

  const updateTransactionStatus = async (id, status) => {
    try {
      const transaction = state.transactions.find(t => t.id === id);
      if (!transaction) return;
      
      const oldStatus = transaction.status;
      transaction.status = status; 
      
      await db.collection('transactions').doc(id).update({ status });

      // Lógica de atualização de limite do cartão se a transação for de cartão e o status mudou para/de 'paid'
      if (transaction.type === 'expense' && transaction.paymentMethod === 'credito' && transaction.creditCardId) {
        const card = state.cards.find(c => c.id === transaction.creditCardId);
        if (card) {
            // Esta lógica pode ser complexa. Assumimos que 'currentInvoice' do cartão reflete o saldo devedor.
            // Se uma despesa de cartão é marcada como paga, ela não deveria mais impactar o currentInvoice
            // da mesma forma que uma despesa pendente.
            // Por simplicidade, vamos apenas refazer o cálculo do cartão.
            // Idealmente, a transação paga sairia do cômputo de 'currentInvoice'.
            // Esta parte pode precisar de uma revisão mais profunda da lógica de 'currentInvoice'.
            // Por ora, vamos focar na mudança de status e no refresh da UI.
        }
      }
      await fullUIRefresh(); 
      showToast('Status da transação atualizado!', 'success');
    } catch (error) {
      console.error('Erro ao atualizar status:', error);
      showToast('Erro ao atualizar status.', 'error');
      // Reverter a mudança no estado local se o DB falhar
      const transactionOnError = state.transactions.find(t => t.id === id);
      if(transactionOnError) transactionOnError.status = oldStatus;
      await fullUIRefresh();
    }
  };

  const addTransaction = async (transactionData) => {
    try {
      const transaction = { ...transactionData, createdAt: localDateToISOString(new Date()) };
      const catList = transaction.type === 'income' ? state.categories.income : state.categories.expense;
      const category = catList.find(c => c.id === transaction.category);
      if (category) { transaction.categoryName = category.name; transaction.categoryIcon = category.icon; }
      
      const payment = state.paymentMethods.find(p => p.id === transaction.paymentMethod);
      if (payment) { transaction.paymentMethodName = payment.name; transaction.paymentMethodIcon = payment.icon; }

      if (transaction.person) {
          const personObj = state.people.find(p => p.id === transaction.person);
          if (personObj) { transaction.personName = personObj.name; transaction.personIcon = personObj.icon; }
      }

      if (transaction.type === 'expense' && transaction.paymentMethod === 'credito' && transaction.creditCardId && !transaction.isRecurrent) {
        // Apenas adiciona ao limite se NÃO for uma parcela de uma compra já registrada
        // (a lógica de `addRecurrentTransactions` já lida com o valor total da compra parcelada)
        await updateCardLimits(transaction.creditCardId, parseFloat(transaction.amount), 'add');
        const card = state.cards.find(c => c.id === transaction.creditCardId);
        if (card) transaction.creditCardName = card.name;
      }

      const docRef = await db.collection('transactions').add(transaction);
      transaction.id = docRef.id;
      state.transactions.push(transaction);
      await fullUIRefresh(); 
      showToast(`${transaction.type === 'income' ? 'Receita' : 'Despesa'} adicionada!`, 'success');
      return transaction;
    } catch (e) { console.error(e); showToast('Erro ao adicionar transação.', 'error'); return null; }
  };

  const addRecurrentTransactions = async (baseTransaction, installments) => {
    try {
      const recurrenceId = generateId();
      const batch = db.batch();
      const transactionsToAdd = [];
      // O valor da baseTransaction é o valor TOTAL da compra/despesa recorrente.
      // Cada parcela terá amount = baseTransaction.amount / installments
      const installmentValue = parseFloat(baseTransaction.amount) / installments; 
      const totalPurchaseAmount = parseFloat(baseTransaction.amount);


      for (let i = 0; i < installments; i++) {
        const currentInstallmentLaunchDate = parseLocalDateString(baseTransaction.date);
        currentInstallmentLaunchDate.setUTCMonth(currentInstallmentLaunchDate.getUTCMonth() + i);
        
        let currentEffectiveDueDate = null;
        if (baseTransaction.paymentMethod === 'credito' && baseTransaction.creditCardId) {
            const card = state.cards.find(c => c.id === baseTransaction.creditCardId);
            if (card) {
                // Para parcelas de cartão, a data de lançamento é a data da compra. O vencimento de cada parcela será calculado.
                // O importante é que a data da transação (compra) seja a original.
                currentEffectiveDueDate = calcularVencimentoReal(currentInstallmentLaunchDate, card); 
            }
        } else if (baseTransaction.dueDate) { // Para boletos, etc.
            currentEffectiveDueDate = parseLocalDateString(baseTransaction.dueDate);
            currentEffectiveDueDate.setUTCMonth(currentEffectiveDueDate.getUTCMonth() + i);
        }


        const installment = { 
          ...baseTransaction, 
          amount: installmentValue, // Valor da parcela
          date: localDateToISOString(parseLocalDateString(baseTransaction.date)), // Data da compra original para todas as parcelas
          dueDate: currentEffectiveDueDate ? localDateToISOString(currentEffectiveDueDate) : null, 
          recurrenceId, 
          installmentNumber: i + 1, 
          installments,
          isRecurrent: true,
          status: (baseTransaction.paymentMethod === 'credito') ? 'pending' : (baseTransaction.status || 'pending') // Cartão sempre pendente
        };
        delete installment.id; // Firebase gera novo ID

        const docRef = db.collection('transactions').doc(); 
        batch.set(docRef, installment);
        installment.id = docRef.id; 
        transactionsToAdd.push(installment);
      }
      
      if (baseTransaction.type === 'expense' && baseTransaction.paymentMethod === 'credito' && baseTransaction.creditCardId) {
          // Atualiza o limite do cartão com o VALOR TOTAL da compra parcelada
          await updateCardLimits(baseTransaction.creditCardId, totalPurchaseAmount, 'add'); 
      }

      await batch.commit();
      state.transactions.push(...transactionsToAdd);
      await fullUIRefresh(); 
      showToast('Transação parcelada adicionada!', 'success');
      return transactionsToAdd;
    } catch (e) { console.error(e); showToast('Erro ao adicionar parcelas.', 'error'); return null; }
  };

  const updateTransaction = async (id, updates) => {
    try {
      const transaction = state.transactions.find(t => t.id === id);
      if (!transaction) return;

      const oldAmount = parseFloat(transaction.amount);
      const oldPaymentMethod = transaction.paymentMethod;
      const oldCardId = transaction.creditCardId;
      const oldIsRecurrent = transaction.isRecurrent; // Se ERA recorrente (parcela individual)
      const oldRecurrenceId = transaction.recurrenceId;


      if (updates.category) {
        const catList = updates.type === 'income' ? state.categories.income : state.categories.expense;
        const cat = catList.find(c => c.id === updates.category);
        if (cat) { updates.categoryName = cat.name; updates.categoryIcon = cat.icon; }
      }
      if (updates.paymentMethod) {
        const pay = state.paymentMethods.find(p => p.id === updates.paymentMethod);
        if (pay) { updates.paymentMethodName = pay.name; updates.paymentMethodIcon = pay.icon; }
      }
      if (updates.person) {
        const pers = state.people.find(p => p.id === updates.person);
        if (pers) { updates.personName = pers.name; updates.personIcon = pers.icon; }
      }
      if (updates.creditCardId) {
        const cardUpd = state.cards.find(c => c.id === updates.creditCardId);
        if (cardUpd) updates.creditCardName = cardUpd.name;
      }


      const newAmount = updates.amount !== undefined ? parseFloat(updates.amount) : oldAmount;
      const newPaymentMethod = updates.paymentMethod || oldPaymentMethod;
      const newCardId = updates.creditCardId || oldCardId;
      const newIsRecurrent = updates.isRecurrent !== undefined ? updates.isRecurrent : oldIsRecurrent;

      // Lógica de atualização de limite de cartão
      // Só mexer no limite se a transação NÃO for uma parcela de uma série já existente
      // E se não estiver se tornando uma nova série (isso é tratado em addRecurrentTransactions)
      if (!oldRecurrenceId && !newIsRecurrent) { 
        if (transaction.type === 'expense') {
            if (oldPaymentMethod === 'credito' && newPaymentMethod === 'credito') { 
              if (oldCardId === newCardId) { 
                if (newAmount !== oldAmount && oldCardId) {
                  await updateCardLimits(oldCardId, newAmount, 'update', oldAmount);
                }
              } else { 
                if (oldCardId) await updateCardLimits(oldCardId, oldAmount, 'subtract');
                if (newCardId) await updateCardLimits(newCardId, newAmount, 'add');
              }
            }
            else if (oldPaymentMethod !== 'credito' && newPaymentMethod === 'credito') { 
              if (newCardId) await updateCardLimits(newCardId, newAmount, 'add');
            }
            else if (oldPaymentMethod === 'credito' && newPaymentMethod !== 'credito') { 
              if (oldCardId) await updateCardLimits(oldCardId, oldAmount, 'subtract');
              updates.creditCardId = null; updates.creditCardName = null; 
            }
        }
      }
      
      // Se está se tornando recorrente AGORA (e não era antes), não fazemos nada aqui.
      // A UI não permite editar uma transação para se tornar recorrente (ela só permite criar nova recorrente).
      // Se a transação já é parte de uma série (tem recurrenceId), a edição de valor/parcelas é complexa e não está implementada.
      // O checkbox 'isRecurrent' é desabilitado na edição se transaction.recurrenceId existe.
      // Então, a lógica de updateCardLimits acima é principalmente para transações únicas.

      if (updates.date && updates.date instanceof Date) updates.date = localDateToISOString(updates.date);
      if (updates.dueDate && updates.dueDate instanceof Date) updates.dueDate = localDateToISOString(updates.dueDate);
      if (updates.scheduledDate && updates.scheduledDate instanceof Date) updates.scheduledDate = localDateToISOString(updates.scheduledDate);


      await db.collection('transactions').doc(id).update(updates);
      Object.assign(transaction, updates); 
      await fullUIRefresh(); 
      showToast('Transação atualizada!', 'success');
      return transaction;
    } catch (e) { console.error(e); showToast('Erro ao atualizar transação.', 'error'); return null; }
  };

  const deleteTransaction = async (id, options = {}) => {
    try {
      const transaction = state.transactions.find(t => t.id === id);
      if (!transaction) return;

      const isRecurrentSeries = transaction.isRecurrent && transaction.recurrenceId;
      const batch = db.batch();
      
      if (isRecurrentSeries && options.deleteOption === 'future') {
        const futureParcels = state.transactions.filter(t => t.recurrenceId === transaction.recurrenceId && parseInt(t.installmentNumber) >= parseInt(transaction.installmentNumber));
        
        // Se for cartão de crédito, precisamos ajustar o limite pelo valor total das parcelas excluídas.
        if (transaction.type === 'expense' && transaction.paymentMethod === 'credito' && transaction.creditCardId) {
            const totalAmountOfFutureParcels = futureParcels.reduce((sum, p) => sum + parseFloat(p.amount), 0);
            await updateCardLimits(transaction.creditCardId, totalAmountOfFutureParcels, 'subtract');
        }

        futureParcels.forEach(parcel => {
          batch.delete(db.collection('transactions').doc(parcel.id));
        });
        await batch.commit();
        state.transactions = state.transactions.filter(t => !(t.recurrenceId === transaction.recurrenceId && parseInt(t.installmentNumber) >= parseInt(transaction.installmentNumber)));
      
      } else { // Excluir apenas esta parcela ou uma transação única
        if (transaction.type === 'expense' && transaction.paymentMethod === 'credito' && transaction.creditCardId) {
            // Se é uma parcela de uma série, subtrai apenas o valor desta parcela.
            // Se é uma transação única, subtrai o valor total.
            await updateCardLimits(transaction.creditCardId, parseFloat(transaction.amount), 'subtract');
        }
        await db.collection('transactions').doc(id).delete();
        state.transactions = state.transactions.filter(t => t.id !== id);
      }
      await fullUIRefresh(); 
      showToast('Transação excluída!', 'success');
      return true;
    } catch (e) { console.error(e); showToast('Erro ao excluir transação.', 'error'); return false; }
  };

  const openEditModal = (transaction) => {
    if (!transaction) return;
    state.currentTransaction = transaction;
    $('#editTransactionId').value = transaction.id;
    $('#editTransactionType').value = transaction.type;
    $('#editName').value = transaction.name;
    $('#editAmount').value = transaction.amount;

    const categorySelect = $('#editCategory');
    categorySelect.dataset.type = transaction.type; 
    updateCategorySelects(); 
    categorySelect.value = transaction.category || "";

    $('#editPerson').value = transaction.person || '';
    updatePeopleSelects(); // Garante que as opções de pessoa estejam atualizadas
    $('#editPerson').value = transaction.person || ''; // Seta o valor novamente após popular
    
    const expenseTypeGroup = $('#editExpenseTypeGroup');
    if (transaction.type === 'expense') {
        expenseTypeGroup.style.display = 'block';
        if (transaction.isFixed === 'fixed') $('#editExpenseTypeFixed').checked = true;
        else $('#editExpenseTypeVariable').checked = true;
    } else {
        expenseTypeGroup.style.display = 'none';
    }

    setDateInputValue('editDate', transaction.date); 
    
    const dueDateGroup = $('#editDueDateGroup');
    // const dueDateInput = $('#editDueDate'); // Não usado diretamente para desabilitar

    let effectiveDueDateForEdit = transaction.dueDate ? parseLocalDateString(transaction.dueDate) : null; 
    if (transaction.type === 'expense' && transaction.paymentMethod === 'credito' && transaction.creditCardId) {
        const card = state.cards.find(c => c.id === transaction.creditCardId);
        const launchDate = parseLocalDateString(transaction.date);
        if (card && launchDate) {
            const realCardDueDate = calcularVencimentoReal(launchDate, card);
            if (realCardDueDate) effectiveDueDateForEdit = realCardDueDate;
        }
    }
    
    if (effectiveDueDateForEdit) {
        dueDateGroup.style.display = 'block';
        setDateInputValue('editDueDate', effectiveDueDateForEdit);
    } else { 
        // Para despesas não-cartão, permitir edição da data de vencimento.
        // Para receitas, o campo de vencimento pode não ser relevante ou ser igual à data de lançamento.
        dueDateGroup.style.display = (transaction.type === 'expense' && transaction.paymentMethod !== 'credito') ? 'block' : 'none';
        if(transaction.type === 'expense' && transaction.paymentMethod !== 'credito') {
            setDateInputValue('editDueDate', transaction.dueDate || transaction.date);
        }
    }
    $('#editDueDate').disabled = (transaction.type === 'expense' && transaction.paymentMethod === 'credito');


    $('#editPaymentMethod').value = transaction.paymentMethod || "";
    updatePaymentMethodSelects(); // Garante opções atualizadas
    $('#editPaymentMethod').value = transaction.paymentMethod || ""; // Seta valor novamente
    
    handleEditCreditCardVisibility(); // Mostra/esconde campo de cartão
    if (transaction.paymentMethod === 'credito') {
        updateCreditCardSelects(); // Garante opções de cartão atualizadas
        $('#editCreditCard').value = transaction.creditCardId || '';
        handleEditDueDateForCard(); 
    }
    
    const isParcelOfSeries = !!transaction.recurrenceId;
    $('#editIsRecurrent').checked = transaction.isRecurrent || false;
    $('#editIsRecurrent').disabled = isParcelOfSeries; // Não pode mudar se já é parte de uma série
    
    handleEditRecurrenceGroupVisibility();
    if (transaction.isRecurrent) {
      $('#editInstallments').value = transaction.installments || 2;
    }
    $('#editInstallments').disabled = !$('#editIsRecurrent').checked || isParcelOfSeries;

    const statusGroup = $('#editStatusGroup');
    const statusOuterGroup = $('#editStatusOuterGroup'); // Renomeado para evitar conflito de nome
    statusGroup.innerHTML = ''; 
    if (transaction.type === 'income') {
      statusOuterGroup.style.display = 'block';
      statusGroup.innerHTML = `
        <div class="radio-wrapper"><input type="radio" class="radio" id="editStatusReceived" name="editStatus" value="received"><label class="radio-label" for="editStatusReceived">Recebido</label></div>
        <div class="radio-wrapper"><input type="radio" class="radio" id="editStatusPendingIncome" name="editStatus" value="pending"><label class="radio-label" for="editStatusPendingIncome">A Receber</label></div>`;
      if (transaction.status === 'received') $('#editStatusReceived').checked = true; else $('#editStatusPendingIncome').checked = true;
    } else { // Expense
      statusOuterGroup.style.display = transaction.paymentMethod === 'credito' ? 'none' : 'block'; // Esconde status para cartão de crédito
      statusGroup.innerHTML = `
        <div class="radio-wrapper"><input type="radio" class="radio" id="editStatusPaid" name="editStatus" value="paid"><label class="radio-label" for="editStatusPaid">Pago</label></div>
        <div class="radio-wrapper"><input type="radio" class="radio" id="editStatusPendingExpense" name="editStatus" value="pending"><label class="radio-label" for="editStatusPendingExpense">Pendente</label></div>
        <div class="radio-wrapper"><input type="radio" class="radio" id="editStatusScheduled" name="editStatus" value="scheduled"><label class="radio-label" for="editStatusScheduled">Agendado</label></div>`;
      if (transaction.status === 'paid') $('#editStatusPaid').checked = true;
      else if (transaction.status === 'scheduled') $('#editStatusScheduled').checked = true;
      else $('#editStatusPendingExpense').checked = true; // Default para pendente
    }
    
    // Listener para o status 'Agendado' no modal de edição
    if (transaction.type === 'expense') {
        const editStatusScheduledRadio = $('#editStatusScheduled');
        if (editStatusScheduledRadio) {
            editStatusScheduledRadio.addEventListener('change', handleEditScheduledDateVisibility);
        }
    }
    handleEditScheduledDateVisibility(); // Chama para setar o estado inicial

    if (transaction.status === 'scheduled' && transaction.scheduledDate) {
      setDateInputValue('editScheduledDate', transaction.scheduledDate);
    } else {
      $('#editScheduledDate').value = ''; // Limpa se não for agendado ou não tiver data
    }

    $('#editNotes').value = transaction.notes || '';
    $('#editModalTitle').textContent = transaction.type === 'income' ? 'Editar Receita' : 'Editar Despesa';
    openModal('editModal');
  }; // Fim da função openEditModal

  const openDeleteConfirmModal = (transaction) => {
    if (!transaction) return;
    state.currentTransaction = transaction;
    const reccOptions = $('#recurrenceDeleteOptions');
    const isPartOfRecurrentSeries = transaction.isRecurrent && transaction.recurrenceId && parseInt(transaction.installments) > 1;
    reccOptions.style.display = isPartOfRecurrentSeries ? 'block' : 'none';
    if (isPartOfRecurrentSeries) $('#deleteSingle').checked = true;
    openModal('deleteConfirmModal');
  };

  const openEditCardModal = (card) => {
    if (!card) return;
    state.currentCard = card;
    $('#cardName').value = card.name;
    $('#cardLimit').value = card.limit;
    $('#cardClosingDay').value = card.closingDay;
    $('#cardDueDay').value = card.dueDay;
    $('.modal-title', $('#newCardModal')).textContent = 'Editar Cartão';
    $('#saveCardBtn').textContent = 'Salvar Alterações';
    $('#saveCardBtn').dataset.id = card.id; // Adiciona ID para saber que é edição
    closeModal('cardsListModal');
    openModal('newCardModal');
  };

  const renderGenericList = (containerId, items, type, editFn, deleteFn, nameField = 'name', iconField = 'icon') => {
    const listEl = $(`#${containerId}`);
    if (!listEl) return;
    listEl.innerHTML = '';
    if (items.length === 0) {
        listEl.innerHTML = `<p class="text-center text-muted p-4">Nenhum item cadastrado.</p>`;
        return;
    }
    items.sort((a,b) => (a[nameField] || "").localeCompare(b[nameField] || "")).forEach(item => {
      const itemEl = document.createElement('div');
      itemEl.className = 'category-item';
      itemEl.dataset.id = item.id;
      itemEl.dataset.type = type;
      itemEl.innerHTML = `
        <div class="category-item-content">
          <div class="category-item-icon">${item[iconField] || '●'}</div>
          <div>${item[nameField]}</div>
        </div>
        <div class="category-item-actions">
          <button type="button" class="btn btn-icon btn-sm btn-ghost edit-item-btn" aria-label="Editar Item">
            <i class="fas fa-edit"></i>
          </button>
          <button type="button" class="btn btn-icon btn-sm btn-ghost delete-item-btn" aria-label="Excluir Item">
            <i class="fas fa-trash text-error"></i>
          </button>
        </div>`;
      listEl.appendChild(itemEl);
      itemEl.querySelector('.edit-item-btn').addEventListener('click', () => editFn(item, type));
      itemEl.querySelector('.delete-item-btn').addEventListener('click', () => deleteFn(item.id, type));
    });
  };
  const renderCategoriesList = () => renderGenericList('incomeCategoriesList', state.categories.income, 'income', openEditCategoryModal, deleteCategory);
  const renderExpenseCategoriesList = () => renderGenericList('expenseCategoriesList', state.categories.expense, 'expense', openEditCategoryModal, deleteCategory); 
  const renderInvestmentCategoriesList = () => renderGenericList('investmentCategoriesList', state.categories.investment, 'investment', openEditCategoryModal, deleteCategory);
  const renderPaymentMethodsList = () => renderGenericList('paymentMethodsList', state.paymentMethods, 'paymentMethod', openEditCategoryModal, deletePaymentMethod);
  const updatePeopleList = () => renderGenericList('peopleList', state.people, 'person', openEditCategoryModal, deletePerson);

  const openEditCategoryModal = (item, type) => {
    state.currentCategory = item; 
    $('#editCategoryId').value = item.id;
    $('#editCategoryType').value = type; 
    $('#editCategoryName').value = item.name;
    $('#editCategoryIconInput').value = item.icon || '';
    $('#editCategoryIconPreview').innerHTML = item.icon || '●'; // Usar innerHTML para renderizar emoji
    const titles = {
        'income':'Editar Categoria de Receita', 
        'expense':'Editar Categoria de Despesa', 
        'investment':'Editar Categoria de Investimento', 
        'paymentMethod':'Editar Forma de Pagamento', 
        'person':'Editar Pessoa'
    };
    $('#editCategoryTitle').textContent = titles[type] || 'Editar Item';
    openModal('editCategoryModal');
  };

  const addCategory = async (name, icon, type) => {
    if (!name.trim()) { showToast('Nome não pode ser vazio.', 'error'); return null; }
    const id = generateId(); // Usar ID do Firebase
    const category = { id, name, icon, type }; 
    try {
      await db.collection('categories').doc(id).set(category);
      if (type === 'income') state.categories.income.push(category);
      else if (type === 'expense') state.categories.expense.push(category);
      else if (type === 'investment') state.categories.investment.push(category);
      await fullUIRefresh(); 
      showToast('Categoria adicionada!', 'success'); return category;
    } catch (e) { console.error(e); showToast('Erro ao adicionar categoria.', 'error'); return null; }
  };
  const addPaymentMethod = async (name, icon) => {
    if (!name.trim()) { showToast('Nome não pode ser vazio.', 'error'); return null; }
    const id = generateId();
    const method = { id, name, icon };
    try {
      await db.collection('paymentMethods').doc(id).set(method);
      state.paymentMethods.push(method);
      await fullUIRefresh(); 
      showToast('Forma de pagamento adicionada!', 'success'); return method;
    } catch (e) { console.error(e); showToast('Erro ao adicionar forma de pagamento.', 'error'); return null; }
  };
  const addPerson = async (name, icon) => {
    if (!name.trim()) { showToast('Nome não pode ser vazio.', 'error'); return null; }
    const id = generateId();
    const person = { id, name, icon };
    try {
      await db.collection('people').doc(id).set(person);
      state.people.push(person);
      await fullUIRefresh(); 
      showToast('Pessoa adicionada!', 'success'); return person;
    } catch (e) { console.error(e); showToast('Erro ao adicionar pessoa.', 'error'); return null; }
  };

  const updateCategory = async (id, updates, type) => {
    try {
      await db.collection('categories').doc(id).update(updates);
      let listToUpdate;
      if (type === 'income') listToUpdate = state.categories.income;
      else if (type === 'expense') listToUpdate = state.categories.expense;
      else if (type === 'investment') listToUpdate = state.categories.investment;
      else return false; // Tipo inválido
      
      const index = listToUpdate.findIndex(c => c.id === id);
      if (index !== -1) listToUpdate[index] = { ...listToUpdate[index], ...updates };
      
      const batch = db.batch();
      let transactionsUpdated = false;
      state.transactions.forEach(t => {
        if (t.category === id && t.type === type) { // Garante que o tipo da transação corresponda ao tipo da categoria
          batch.update(db.collection('transactions').doc(t.id), { categoryName: updates.name, categoryIcon: updates.icon });
          t.categoryName = updates.name; t.categoryIcon = updates.icon; 
          transactionsUpdated = true;
        }
      });
      if (transactionsUpdated) await batch.commit();
      
      await fullUIRefresh(); 
      showToast('Categoria atualizada!', 'success'); return true;
    } catch (e) { console.error(e); showToast('Erro ao atualizar categoria.', 'error'); return false; }
  };
  const updatePaymentMethod = async (id, updates) => {
    try {
      await db.collection('paymentMethods').doc(id).update(updates);
      const index = state.paymentMethods.findIndex(m => m.id === id);
      if (index !== -1) state.paymentMethods[index] = { ...state.paymentMethods[index], ...updates };
      
      const batch = db.batch();
      let transactionsUpdated = false;
      state.transactions.forEach(t => {
        if (t.paymentMethod === id) {
          batch.update(db.collection('transactions').doc(t.id), { paymentMethodName: updates.name, paymentMethodIcon: updates.icon });
          t.paymentMethodName = updates.name; t.paymentMethodIcon = updates.icon;
          transactionsUpdated = true;
        }
      });
      if (transactionsUpdated) await batch.commit();

      await fullUIRefresh(); 
      showToast('Forma de pagamento atualizada!', 'success'); return true;
    } catch (e) { console.error(e); showToast('Erro ao atualizar forma de pagamento.', 'error'); return false; }
  };
  const updatePerson = async (id, updates) => {
    try {
      await db.collection('people').doc(id).update(updates);
      const index = state.people.findIndex(p => p.id === id);
      if (index !== -1) state.people[index] = { ...state.people[index], ...updates };

      const batch = db.batch();
      let transactionsUpdated = false;
      state.transactions.forEach(t => {
        if (t.person === id) {
          batch.update(db.collection('transactions').doc(t.id), { personName: updates.name, personIcon: updates.icon });
          t.personName = updates.name; t.personIcon = updates.icon;
          transactionsUpdated = true;
        }
      });
      if (transactionsUpdated) await batch.commit();

      await fullUIRefresh(); 
      showToast('Pessoa atualizada!', 'success'); return true;
    } catch (e) { console.error(e); showToast('Erro ao atualizar pessoa.', 'error'); return false; }
  };

  const deleteCategory = async (id, type) => {
    if (!confirm(`Excluir esta categoria? Transações associadas perderão esta categoria.`)) return false;
    try {
      await db.collection('categories').doc(id).delete();
      if (type === 'income') state.categories.income = state.categories.income.filter(c => c.id !== id);
      else if (type === 'expense') state.categories.expense = state.categories.expense.filter(c => c.id !== id);
      else if (type === 'investment') state.categories.investment = state.categories.investment.filter(c => c.id !== id);
      
      const batch = db.batch();
      let transactionsUpdated = false;
      state.transactions.forEach(t => { 
        if (t.category === id && t.type === type) { 
            batch.update(db.collection('transactions').doc(t.id), { category: null, categoryName: 'Sem Categoria', categoryIcon: '❓' });
            t.category = null; t.categoryName = 'Sem Categoria'; t.categoryIcon = '❓'; 
            transactionsUpdated = true;
        }
      });
      if (transactionsUpdated) await batch.commit();

      await fullUIRefresh(); 
      showToast('Categoria excluída!', 'success'); return true;
    } catch (e) { console.error(e); showToast('Erro ao excluir categoria.', 'error'); return false; }
  };
  const deletePaymentMethod = async (id) => {
    if (!confirm(`Excluir esta forma de pagamento? Transações associadas perderão esta forma de pagamento.`)) return false;
    try {
      await db.collection('paymentMethods').doc(id).delete();
      state.paymentMethods = state.paymentMethods.filter(m => m.id !== id);

      const batch = db.batch();
      let transactionsUpdated = false;
      state.transactions.forEach(t => { 
        if (t.paymentMethod === id) { 
            batch.update(db.collection('transactions').doc(t.id), { paymentMethod: null, paymentMethodName: 'N/A', paymentMethodIcon: '❓' });
            t.paymentMethod = null; t.paymentMethodName = 'N/A'; t.paymentMethodIcon = '❓'; 
            transactionsUpdated = true;
        }
      });
      if (transactionsUpdated) await batch.commit();

      await fullUIRefresh(); 
      showToast('Forma de pagamento excluída!', 'success'); return true;
    } catch (e) { console.error(e); showToast('Erro ao excluir forma de pagamento.', 'error'); return false; }
  };
  const deletePerson = async (id) => {
    if (!confirm(`Excluir esta pessoa? Transações associadas perderão esta pessoa.`)) return false;
    try {
      await db.collection('people').doc(id).delete();
      state.people = state.people.filter(p => p.id !== id);

      const batch = db.batch();
      let transactionsUpdated = false;
      state.transactions.forEach(t => { 
        if (t.person === id) { 
            batch.update(db.collection('transactions').doc(t.id), { person: null, personName: 'N/A', personIcon: '❓' });
            t.person = null; t.personName = 'N/A'; t.personIcon = '❓'; 
            transactionsUpdated = true;
        }
      });
      if (transactionsUpdated) await batch.commit();
      
      await fullUIRefresh(); 
      showToast('Pessoa excluída!', 'success'); return true;
    } catch (e) { console.error(e); showToast('Erro ao excluir pessoa.', 'error'); return false; }
  };

  async function fullUIRefresh() {
    filterTransactionsByMonth(); 
    updateTransactionsTable(); 
    updateKPIs();             
    updateCharts();           
    updateCardsList();             
    updateCreditCardSelects();     
    renderCommitments();           
    generateInsights();            
    renderCategoriesList();        
    renderExpenseCategoriesList(); 
    renderInvestmentCategoriesList(); 
    renderPaymentMethodsList();    
    updatePeopleList();            
    updateCategorySelects();
    updatePaymentMethodSelects();
    updatePeopleSelects();
    updateInvestmentCategorySelects();
  }

  function handleDueDateForCard(formPrefix) {
    const paymentMethodEl = $(`#${formPrefix}PaymentMethod`);
    const creditCardEl = $(`#${formPrefix}CreditCard`);
    const dateEl = $(`#${formPrefix}Date`); 
    const dueDateEl = $(`#${formPrefix}DueDate`); 
    const dueDateGroupEl = $(`#${formPrefix}DueDateGroup`);

    if (!paymentMethodEl || !dueDateEl || !dueDateGroupEl) return;

    if (paymentMethodEl.value === 'credito') {
        dueDateGroupEl.style.display = 'block'; 
        dueDateEl.disabled = true; 
        if (creditCardEl && creditCardEl.value && dateEl && dateEl.value) {
            const card = state.cards.find(c => c.id === creditCardEl.value);
            const launchDate = getDateInputValue(`${formPrefix}Date`);
            if (card && launchDate) {
                const realDueDate = calcularVencimentoReal(launchDate, card);
                if (realDueDate) setDateInputValue(`${formPrefix}DueDate`, realDueDate);
                else setDateInputValue(`${formPrefix}DueDate`, null); 
            } else {
                 setDateInputValue(`${formPrefix}DueDate`, null); 
            }
        } else {
            setDateInputValue(`${formPrefix}DueDate`, null); 
        }
    } else { 
        dueDateEl.disabled = false;
        dueDateGroupEl.style.display = 'block'; // Mantém visível para outros tipos de pagamento
        // Não preenche automaticamente para não sobrescrever entrada manual, a menos que explicitamente desejado
        // if (!dueDateEl.value && formPrefix !== 'edit') { 
        //     if (dateEl && dateEl.value) {
        //         setDateInputValue(`${formPrefix}DueDate`, getDateInputValue(`${formPrefix}Date`));
        //     }
        // }
    }
  }
  
  function handleStatusFieldVisibility(formPrefix) { // Usado em Nova Despesa
    const paymentMethodEl = $(`#${formPrefix}PaymentMethod`);
    const isRecurrentEl = $(`#${formPrefix}IsRecurrent`);
    const statusGroupEl = $(`#${formPrefix}StatusGroup`);
    const statusPendingRadio = $(`#${formPrefix}StatusPending`); // Assume expense context

    if (!paymentMethodEl || !statusGroupEl) return;
    
    const isCreditCard = paymentMethodEl.value === 'credito';
    const isRecurrent = isRecurrentEl ? isRecurrentEl.checked : false;

    if (isCreditCard || isRecurrent) { 
        statusGroupEl.style.display = 'none';
        if (statusPendingRadio) statusPendingRadio.checked = true;
    } else {
        statusGroupEl.style.display = 'block'; 
    }
  }

  function handleRecurrenceGroupVisibility(formPrefix) {
    const isRecurrentEl = $(`#${formPrefix}IsRecurrent`);
    const recurrenceGroupEl = $(`#${formPrefix}RecurrenceGroup`);
    
    if (!isRecurrentEl || !recurrenceGroupEl) return;
    
    recurrenceGroupEl.style.display = isRecurrentEl.checked ? 'block' : 'none';
  }

  function handleEditRecurrenceGroupVisibility() { // Para o modal de edição
    const isRecurrentEl = $('#editIsRecurrent');
    const recurrenceGroupEl = $('#editRecurrenceGroup');
    
    if (!isRecurrentEl || !recurrenceGroupEl) return;
    
    recurrenceGroupEl.style.display = isRecurrentEl.checked ? 'block' : 'none';
  }

  function handleEditDueDateForCard() { // Para o modal de edição
    const paymentMethodEl = $('#editPaymentMethod');
    const creditCardEl = $('#editCreditCard');
    const dateEl = $('#editDate');
    const dueDateEl = $('#editDueDate');
    // const dueDateGroupEl = $('#editDueDateGroup'); // Já tratado em openEditModal
    
    if (!paymentMethodEl || !dueDateEl) return;
    
    if (paymentMethodEl.value === 'credito') {
        dueDateEl.disabled = true;
        if (creditCardEl && creditCardEl.value && dateEl && dateEl.value) {
            const card = state.cards.find(c => c.id === creditCardEl.value);
            const launchDate = getDateInputValue('editDate');
            if (card && launchDate) {
                const realDueDate = calcularVencimentoReal(launchDate, card);
                if (realDueDate) setDateInputValue('editDueDate', realDueDate);
                else setDateInputValue('editDueDate', null);
            } else {
                setDateInputValue('editDueDate', null);
            }
        } else {
            setDateInputValue('editDueDate', null);
        }
    } else {
        dueDateEl.disabled = false;
    }
  }

  function handleEditCreditCardVisibility() { // Para o modal de edição
    const paymentMethodEl = $('#editPaymentMethod');
    const creditCardGroupEl = $('#editCreditCardGroup');
    const dueDateGroupEl = $('#editDueDateGroup'); // Necessário para mostrar/esconder vencimento
    
    if (!paymentMethodEl || !creditCardGroupEl || !dueDateGroupEl) return;
    
    if (paymentMethodEl.value === 'credito') {
        creditCardGroupEl.style.display = 'block';
        dueDateGroupEl.style.display = 'block'; // Vencimento é relevante para cartão
        handleEditDueDateForCard();
    } else {
        creditCardGroupEl.style.display = 'none';
        // Vencimento pode ou não ser relevante para outros métodos, openEditModal decide
        // Aqui só garantimos que não está desabilitado se não for cartão
        $('#editDueDate').disabled = false; 
    }
  }

  function handleEditStatusFieldVisibility() { // Para o modal de edição
    const paymentMethodEl = $('#editPaymentMethod');
    // const isRecurrentEl = $('#editIsRecurrent'); // Recorrência já tratada em openEditModal
    const statusOuterGroupEl = $('#editStatusOuterGroup');
    
    if (!paymentMethodEl || !statusOuterGroupEl) return;
    
    const isCreditCard = paymentMethodEl.value === 'credito';
    statusOuterGroupEl.style.display = isCreditCard ? 'none' : 'block';
  }

  function handleEditScheduledDateVisibility() { // Para o modal de edição
    const statusScheduledRadio = $('#editStatusScheduled'); // Assume que existe se for despesa
    const scheduledDateGroupEl = $('#editScheduledDateGroup');
    
    if (!scheduledDateGroupEl) return; // Se o grupo não existe, nada a fazer
    
    // Se o radio de agendado não existe (ex: receita), esconde o campo de data agendada
    if (!statusScheduledRadio) {
        scheduledDateGroupEl.style.display = 'none';
        return;
    }
    scheduledDateGroupEl.style.display = statusScheduledRadio.checked ? 'block' : 'none';
  }

  function handleCreditCardGroupVisibility(formPrefix) { // Para modais de Nova Receita/Despesa
    const paymentMethodEl = $(`#${formPrefix}PaymentMethod`);
    const creditCardGroupEl = $(`#${formPrefix}CreditCardGroup`);
    const dueDateGroupEl = $(`#${formPrefix}DueDateGroup`);
    
    if (!paymentMethodEl || !creditCardGroupEl || !dueDateGroupEl) return;
    
    const isCreditCard = paymentMethodEl.value === 'credito';
    creditCardGroupEl.style.display = isCreditCard ? 'block' : 'none';
    dueDateGroupEl.style.display = 'block'; // Vencimento sempre visível para nova despesa
    
    if (isCreditCard) {
        handleDueDateForCard(formPrefix);
    } else {
        $(`#${formPrefix}DueDate`).disabled = false; // Garante que não está desabilitado
    }
  }

  function handleScheduledDateVisibility(formPrefix) { // Para modais de Nova Receita/Despesa
    const statusScheduledRadio = $(`#${formPrefix}StatusScheduled`); // Assume que existe se for despesa
    const scheduledDateGroupEl = $(`#${formPrefix}ScheduledDateGroup`);
    
    if (!scheduledDateGroupEl) return;
    if (!statusScheduledRadio) { // Se não é despesa, não há radio de agendado
        scheduledDateGroupEl.style.display = 'none';
        return;
    }
    scheduledDateGroupEl.style.display = statusScheduledRadio.checked ? 'block' : 'none';
  }

  // Setup dos ouvintes de eventos
  function setupEventListeners() {
    // Filtros de cabeçalho
    $('#yearSelect').addEventListener('change', e => { state.year = parseInt(e.target.value); fullUIRefresh(); });
    $('#monthSelect').addEventListener('change', e => { state.month = parseInt(e.target.value); fullUIRefresh(); });
    
    // Header actions
    $('#newIncomeBtn').addEventListener('click', () => { $('#incomeForm').reset(); setDateInputValue('incomeDate', new Date()); openModal('incomeModal'); });
    $('#newExpenseBtn').addEventListener('click', () => { 
        $('#expenseForm').reset(); 
        setDateInputValue('expenseDate', new Date()); 
        setDateInputValue('expenseDueDate', new Date()); 
        $('#expenseTypeVariable').checked = true; // Default
        $('#expenseStatusPending').checked = true; // Default
        handleCreditCardGroupVisibility('expense'); // Atualiza visibilidade inicial
        handleStatusFieldVisibility('expense');
        handleScheduledDateVisibility('expense');
        openModal('expenseModal'); 
    });
    $('#cardsBtn').addEventListener('click', () => openModal('cardsListModal'));
    $('#categoriesBtn').addEventListener('click', () => openModal('categoriesModal'));
    $('#investmentsBtn').addEventListener('click', () => openModal('investmentsModal'));
    
    // Compromissos
    $('#commitmentsHeader').addEventListener('click', toggleCommitments);
    
    // Modal de Nova Receita
    $('#closeIncomeModal').addEventListener('click', () => closeModal('incomeModal'));
    $('#cancelIncomeBtn').addEventListener('click', () => closeModal('incomeModal'));
    $('#saveIncomeBtn').addEventListener('click', handleSaveIncome);
    $('#incomePaymentMethod').addEventListener('change', () => handleStatusField('income')); // Atualiza visibilidade do status
    $('#incomeIsRecurrent').addEventListener('change', () => {
      handleRecurrenceGroupVisibility('income');
      handleStatusField('income'); // Recorrência também afeta status
    });
    
    // Modal de Nova Despesa
    $('#closeExpenseModal').addEventListener('click', () => closeModal('expenseModal'));
    $('#cancelExpenseBtn').addEventListener('click', () => closeModal('expenseModal'));
    $('#saveExpenseBtn').addEventListener('click', handleSaveExpense);
    $('#expensePaymentMethod').addEventListener('change', () => {
      handleCreditCardGroupVisibility('expense');
      handleStatusFieldVisibility('expense'); // Status da despesa
    });
    $('#expenseIsRecurrent').addEventListener('change', () => {
      handleRecurrenceGroupVisibility('expense');
      handleStatusFieldVisibility('expense'); // Status da despesa
    });
    $('#expenseStatusScheduled').addEventListener('change', () => handleScheduledDateVisibility('expense'));
    $('#expenseCreditCard').addEventListener('change', () => handleDueDateForCard('expense'));
    $('#expenseDate').addEventListener('change', () => handleDueDateForCard('expense')); // Se data de lançamento muda, recalcular venc. cartão
    
    // Modal de Edição de Transação
    $('#closeEditModal').addEventListener('click', () => closeModal('editModal'));
    $('#cancelEditBtn').addEventListener('click', () => closeModal('editModal'));
    $('#saveEditBtn').addEventListener('click', handleSaveEdit);
    $('#editPaymentMethod').addEventListener('change', () => {
      handleEditCreditCardVisibility();
      handleEditStatusFieldVisibility(); // Status da edição
    });
    $('#editIsRecurrent').addEventListener('change', () => {
      handleEditRecurrenceGroupVisibility();
      handleEditStatusFieldVisibility(); // Status da edição
    });
    $('#editCreditCard').addEventListener('change', handleEditDueDateForCard);
    $('#editDate').addEventListener('change', handleEditDueDateForCard); // Se data de lançamento muda na edição
    // Listener para status agendado no modal de edição
    // Precisa ser adicionado dinamicamente ou garantir que os elementos existem
    // Adicionado dentro de openEditModal para garantir que os rádios existam

    
    // Modal de Cartões
    $('#closeCardsListModal').addEventListener('click', () => closeModal('cardsListModal'));
    $('#newCardBtn').addEventListener('click', () => {
      state.currentCard = null;
      $('#cardForm').reset();
      $('.modal-title', $('#newCardModal')).textContent = 'Novo Cartão';
      $('#saveCardBtn').textContent = 'Salvar Cartão';
      $('#saveCardBtn').removeAttribute('data-id'); // Garante que não está em modo edição
      closeModal('cardsListModal');
      openModal('newCardModal');
    });
    
    // Modal de Novo Cartão
    $('#closeNewCardModal').addEventListener('click', () => closeModal('newCardModal'));
    $('#cancelCardBtn').addEventListener('click', () => closeModal('newCardModal'));
    $('#saveCardBtn').addEventListener('click', handleSaveCard);
    
    // Modal de Fatura de Cartão
    $('#closeCardInvoiceModal').addEventListener('click', () => closeModal('cardInvoiceModal'));
    $('#backToCardsBtn').addEventListener('click', () => {
      closeModal('cardInvoiceModal');
      openModal('cardsListModal');
    });
    $('#payInvoiceBtn').addEventListener('click', handlePayInvoice);
    
    // Modal de Confirmação de Exclusão
    $('#closeDeleteConfirmModal').addEventListener('click', () => closeModal('deleteConfirmModal'));
    $('#cancelDeleteBtn').addEventListener('click', () => closeModal('deleteConfirmModal'));
    $('#confirmDeleteBtn').addEventListener('click', handleConfirmDelete);
    
    // Modal de Confirmação de Pagamento de Fatura
    $('#closePayInvoiceConfirmModal').addEventListener('click', () => closeModal('payInvoiceConfirmModal'));
    $('#cancelPayInvoiceBtn').addEventListener('click', () => closeModal('payInvoiceConfirmModal'));
    $('#confirmPayInvoiceBtn').addEventListener('click', handleConfirmPayInvoice);
    
    // Modal de Categorias
    $('#closeCategoriesModal').addEventListener('click', () => closeModal('categoriesModal'));
    $('#closeCategoriesBtn').addEventListener('click', () => closeModal('categoriesModal'));
    
    // Navegação por abas nas categorias
    $$('#categoryTabs .nav-link').forEach(link => {
      link.addEventListener('click', e => {
        e.preventDefault();
        $$('#categoryTabs .nav-link').forEach(l => l.classList.remove('active'));
        $$('#categoryTabContent .tab-pane').forEach(p => {
          p.classList.remove('show', 'active');
        });
        e.target.classList.add('active');
        const tabId = e.target.getAttribute('href').substring(1);
        const targetPane = $(`#${tabId}`);
        if(targetPane) targetPane.classList.add('show', 'active');
      });
    });
    
    // Adição de categorias
    $('#addIncomeCategoryBtn').addEventListener('click', () => {
      const name = $('#newIncomeCategoryInput').value.trim();
      const icon = $('#newIncomeCategoryIconInput').value.trim() || '💰';
      if (name) {
        addCategory(name, icon, 'income').then(() => {
          $('#newIncomeCategoryInput').value = '';
          $('#newIncomeCategoryIconInput').value = '';
          $('#newIncomeCategoryIconPreview').textContent = '💰';
        });
      }
    });
    
    $('#addExpenseCategoryBtn').addEventListener('click', () => {
      const name = $('#newExpenseCategoryInput').value.trim();
      const icon = $('#newExpenseCategoryIconInput').value.trim() || '🛍️';
      if (name) {
        addCategory(name, icon, 'expense').then(() => {
          $('#newExpenseCategoryInput').value = '';
          $('#newExpenseCategoryIconInput').value = '';
          $('#newExpenseCategoryIconPreview').textContent = '🛍️';
        });
      }
    });
    
    $('#addInvestmentCategoryBtn').addEventListener('click', () => {
      const name = $('#newInvestmentCategoryInput').value.trim();
      const icon = $('#newInvestmentCategoryIconInput').value.trim() || '📈';
      if (name) {
        addCategory(name, icon, 'investment').then(() => {
          $('#newInvestmentCategoryInput').value = '';
          $('#newInvestmentCategoryIconInput').value = '';
          $('#newInvestmentCategoryIconPreview').textContent = '📈';
        });
      }
    });
    
    $('#addPaymentMethodBtn').addEventListener('click', () => {
      const name = $('#newPaymentMethodInput').value.trim();
      const icon = $('#newPaymentMethodIconInput').value.trim() || '💳';
      if (name) {
        addPaymentMethod(name, icon).then(() => {
          $('#newPaymentMethodInput').value = '';
          $('#newPaymentMethodIconInput').value = '';
          $('#newPaymentMethodIconPreview').textContent = '💳';
        });
      }
    });
    
    $('#addPersonBtn').addEventListener('click', () => {
      const name = $('#newPersonInput').value.trim();
      const icon = $('#newPersonIconInput').value.trim() || '👤';
      if (name) {
        addPerson(name, icon).then(() => {
          $('#newPersonInput').value = '';
          $('#newPersonIconInput').value = '';
          $('#newPersonIconPreview').textContent = '👤';
        });
      }
    });
    
    // Modal de Edição de Categoria
    $('#closeEditCategoryModal').addEventListener('click', () => closeModal('editCategoryModal'));
    $('#cancelEditCategoryBtn').addEventListener('click', () => closeModal('editCategoryModal'));
    $('#saveEditCategoryBtn').addEventListener('click', handleSaveEditCategory);
    
    // Preview de ícones
    ['newIncomeCategory', 'newExpenseCategory', 'newInvestmentCategory', 'newPaymentMethod', 'newPerson', 'editCategory'].forEach(prefix => {
      const input = $(`#${prefix}IconInput`);
      const preview = $(`#${prefix}IconPreview`);
      if (input && preview) {
        input.addEventListener('input', () => {
          preview.textContent = input.value || '●';
        });
      }
    });

    // Modal de Investimentos
    $('#closeInvestmentsModal').addEventListener('click', () => closeModal('investmentsModal'));
    $('#closeInvestmentsBtn').addEventListener('click', () => closeModal('investmentsModal'));
    $('#newInvestmentBtn').addEventListener('click', openNewInvestmentModal);
    
    // Modal de Novo Investimento
    $('#closeNewInvestmentModal').addEventListener('click', () => closeModal('newInvestmentModal'));
    $('#cancelInvestmentBtn').addEventListener('click', () => closeModal('newInvestmentModal'));
    $('#saveInvestmentBtn').addEventListener('click', handleSaveInvestment);
    
    // Modal de Detalhe do Investimento
    $('#closeInvestmentDetailModal').addEventListener('click', () => closeModal('investmentDetailModal'));
    $('#backToInvestmentsBtn').addEventListener('click', () => {
      closeModal('investmentDetailModal');
      openModal('investmentsModal');
    });
    $('#editInvestmentBtn').addEventListener('click', () => {
      if (state.currentInvestment) openEditInvestmentModal(state.currentInvestment.id);
    });
    $('#deleteInvestmentBtn').addEventListener('click', () => {
      if (state.currentInvestment && confirm('Tem certeza que deseja excluir este objetivo e todos os seus aportes?')) {
        deleteInvestment(state.currentInvestment.id);
      }
    });
    $('#addInvestmentContributionBtn').addEventListener('click', openNewContributionModal);
    
    // Modal de Novo Aporte
    $('#closeNewContributionModal').addEventListener('click', () => closeModal('newContributionModal'));
    $('#cancelContributionBtn').addEventListener('click', () => closeModal('newContributionModal'));
    $('#saveContributionBtn').addEventListener('click', handleSaveContribution);
    
    // Modal de Contas Vencidas/A Vencer
    $('#closeDueTransactionsModal').addEventListener('click', () => closeModal('dueTransactionsModal'));
    $('#closeDueTransactionsBtn').addEventListener('click', () => closeModal('dueTransactionsModal'));
    $('#payAllDueBtn').addEventListener('click', handlePayAllDue);
  }

  function handleSaveIncome() {
    const data = {
      name: $('#incomeName').value.trim(),
      amount: parseFloat($('#incomeAmount').value),
      category: $('#incomeCategory').value,
      date: getDateInputValue('incomeDate'),
      paymentMethod: $('#incomePaymentMethod').value,
      isRecurrent: $('#incomeIsRecurrent').checked,
      type: 'income'
    };
    
    if (!data.name || isNaN(data.amount) || data.amount <= 0 || !data.category || !data.date || !data.paymentMethod) {
      showToast('Preencha todos os campos obrigatórios corretamente.', 'error');
      return;
    }
    
    if (data.isRecurrent) {
      data.installments = parseInt($('#incomeInstallments').value);
      if (isNaN(data.installments) || data.installments < 2) {
        showToast('Para recorrência, informe pelo menos 2 parcelas.', 'error');
        return;
      }
      addRecurrentTransactions(data, data.installments).then(() => {
        closeModal('incomeModal');
        $('#incomeForm').reset();
        setDateInputValue('incomeDate', new Date()); // Reset date to today
      });
    } else {
      data.status = $('input[name="incomeStatus"]:checked').value;
      data.notes = $('#incomeNotes').value.trim();
      addTransaction(data).then(() => {
        closeModal('incomeModal');
        $('#incomeForm').reset();
        setDateInputValue('incomeDate', new Date()); // Reset date to today
      });
    }
  }

  function handleSaveExpense() {
    const data = {
      name: $('#expenseName').value.trim(),
      amount: parseFloat($('#expenseAmount').value),
      category: $('#expenseCategory').value,
      date: getDateInputValue('expenseDate'),
      dueDate: getDateInputValue('expenseDueDate'),
      paymentMethod: $('#expensePaymentMethod').value,
      person: $('#expensePerson').value,
      isFixed: $('input[name="expenseType"]:checked') ? $('input[name="expenseType"]:checked').value : null,
      isRecurrent: $('#expenseIsRecurrent').checked,
      type: 'expense'
    };
    
    if (!data.name || isNaN(data.amount) || data.amount <=0 || !data.category || !data.date || !data.paymentMethod || !data.isFixed) {
      showToast('Preencha todos os campos obrigatórios corretamente.', 'error');
      return;
    }
    
    if (data.paymentMethod === 'credito') {
      data.creditCardId = $('#expenseCreditCard').value;
      if (!data.creditCardId) {
        showToast('Selecione o cartão de crédito.', 'error');
        return;
      }
      data.status = 'pending'; // Despesas de cartão são sempre pendentes inicialmente
      // Data de vencimento já deve ter sido calculada por handleDueDateForCard
    } else {
      const statusChecked = $('input[name="expenseStatus"]:checked');
      data.status = statusChecked ? statusChecked.value : 'pending'; // Default para pendente se nada selecionado
    }
    
    if (data.status === 'scheduled') {
      data.scheduledDate = getDateInputValue('expenseScheduledDate');
      if (!data.scheduledDate) {
        showToast('Informe a data de agendamento.', 'error');
        return;
      }
    }
    
    data.notes = $('#expenseNotes').value.trim();
    
    if (data.isRecurrent) {
      data.installments = parseInt($('#expenseInstallments').value);
      if (isNaN(data.installments) || data.installments < 2) {
        showToast('Para recorrência/parcelamento, informe pelo menos 2 parcelas.', 'error');
        return;
      }
      addRecurrentTransactions(data, data.installments).then(() => {
        closeModal('expenseModal');
        $('#expenseForm').reset();
        setDateInputValue('expenseDate', new Date()); 
        setDateInputValue('expenseDueDate', new Date());
      });
    } else {
      addTransaction(data).then(() => {
        closeModal('expenseModal');
        $('#expenseForm').reset();
        setDateInputValue('expenseDate', new Date());
        setDateInputValue('expenseDueDate', new Date());
      });
    }
  }

  function handleSaveEdit() {
    const id = $('#editTransactionId').value;
    const type = $('#editTransactionType').value;
    
    const updates = {
      name: $('#editName').value.trim(),
      amount: parseFloat($('#editAmount').value),
      category: $('#editCategory').value,
      date: getDateInputValue('editDate'),
      paymentMethod: $('#editPaymentMethod').value,
      type // Manter o tipo original
    };
    
    if (isNaN(updates.amount) || updates.amount <= 0 || !updates.name || !updates.category || !updates.date || !updates.paymentMethod) {
        showToast('Preencha todos os campos obrigatórios corretamente.', 'error');
        return;
    }
    
    if (type === 'expense') {
      updates.dueDate = getDateInputValue('editDueDate'); // Sempre pegar, mesmo que desabilitado para cartão
      updates.person = $('#editPerson').value;
      updates.isFixed = $('input[name="editExpenseType"]:checked') ? $('input[name="editExpenseType"]:checked').value : null;
      
      if (updates.paymentMethod === 'credito') {
        updates.creditCardId = $('#editCreditCard').value;
        if (!updates.creditCardId) {
            showToast('Selecione o cartão de crédito.', 'error');
            return;
        }
        updates.status = 'pending'; // Cartão sempre pendente
      } else {
        const statusChecked = $('input[name="editStatus"]:checked');
        updates.status = statusChecked ? statusChecked.value : 'pending';
      }
    } else { // Income
      const statusChecked = $('input[name="editStatus"]:checked');
      updates.status = statusChecked ? statusChecked.value : 'pending';
    }
    
    if (updates.status === 'scheduled') {
      updates.scheduledDate = getDateInputValue('editScheduledDate');
       if (!updates.scheduledDate) {
        showToast('Informe a data de agendamento.', 'error');
        return;
      }
    } else {
        updates.scheduledDate = null; // Limpa se não for mais agendado
    }
    
    // Edição de recorrência/parcelas é complexo.
    // O checkbox editIsRecurrent é desabilitado se já for uma parcela.
    // Se não for uma parcela, e o usuário marcar, idealmente deveria criar novas parcelas.
    // Por simplicidade, a edição não transforma uma transação única em recorrente.
    // Apenas permite editar os detalhes de uma transação única que PODE ser marcada como recorrente (mas sem efeito prático aqui sem lógica adicional).
    updates.isRecurrent = $('#editIsRecurrent').checked;
    if (updates.isRecurrent && !state.currentTransaction.recurrenceId) { // Só se está tornando recorrente e não era parcela
      updates.installments = parseInt($('#editInstallments').value);
      if(isNaN(updates.installments) || updates.installments < 2) {
          showToast('Para recorrência, informe ao menos 2 parcelas.', 'error');
          return;
      }
      // Aqui, a lógica deveria ser deletar a transação original e criar uma nova série.
      // Por ora, a edição de 'isRecurrent' para uma transação não-parcelada não terá o efeito de criar parcelas.
      // Ela apenas marca a flag, o que pode ser confuso.
      // TODO: Revisar lógica de edição para 'isRecurrent'.
    } else if (state.currentTransaction.recurrenceId) { // Se já era parcela, mantém os dados da série
        updates.installments = state.currentTransaction.installments;
        updates.installmentNumber = state.currentTransaction.installmentNumber;
        updates.recurrenceId = state.currentTransaction.recurrenceId;
    }
    
    updates.notes = $('#editNotes').value.trim();
    
    updateTransaction(id, updates).then(() => {
      closeModal('editModal');
    });
  }

  function handleSaveCard() {
    const data = {
      name: $('#cardName').value.trim(),
      limit: parseFloat($('#cardLimit').value),
      closingDay: parseInt($('#cardClosingDay').value),
      dueDay: parseInt($('#cardDueDay').value)
    };
    
    if (!data.name || isNaN(data.limit) || data.limit < 0 || isNaN(data.closingDay) || isNaN(data.dueDay)) {
      showToast('Preencha todos os campos corretamente.', 'error');
      return;
    }
    
    if (data.closingDay < 1 || data.closingDay > 31 || data.dueDay < 1 || data.dueDay > 31) {
      showToast('Informe dias válidos (1-31) para fechamento e vencimento.', 'error');
      return;
    }
    
    const cardId = $('#saveCardBtn').dataset.id; // Pega o ID se estiver editando
    if (cardId) {
      updateCard(cardId, data).then(() => {
        closeModal('newCardModal');
        openModal('cardsListModal');
      });
    } else {
      addCard(data).then(() => {
        closeModal('newCardModal');
        openModal('cardsListModal');
      });
    }
  }

  function handlePayInvoice() {
    if (!state.currentCard) return;
    $('#invoiceConfirmAmount').textContent = $('#currentInvoiceValueDisplay').textContent;
    openModal('payInvoiceConfirmModal');
  }

  function handleConfirmPayInvoice() {
    if (!state.currentCard) return;
    payCardInvoice(state.currentCard.id);
  }

  function handleConfirmDelete() {
    if (!state.currentTransaction) return;
    
    const options = {};
    if (state.currentTransaction.isRecurrent && state.currentTransaction.recurrenceId) {
      const deleteOptionChecked = $('input[name="deleteOption"]:checked');
      if (deleteOptionChecked) options.deleteOption = deleteOptionChecked.value;
      else { // Default para excluir apenas esta se nada for selecionado (não deveria acontecer com radio)
          options.deleteOption = 'single'; 
      }
    }
    
    deleteTransaction(state.currentTransaction.id, options).then(() => {
      closeModal('deleteConfirmModal');
    });
  }

  function handleSaveEditCategory() {
    const id = $('#editCategoryId').value;
    const type = $('#editCategoryType').value;
    
    const updates = {
      name: $('#editCategoryName').value.trim(),
      icon: $('#editCategoryIconInput').value.trim() || '●'
    };
    
    if (!updates.name) {
      showToast('Nome não pode ser vazio.', 'error');
      return;
    }
    
    let promise;
    if (type === 'income' || type === 'expense' || type === 'investment') {
      promise = updateCategory(id, updates, type);
    } else if (type === 'paymentMethod') {
      promise = updatePaymentMethod(id, updates);
    } else if (type === 'person') {
      promise = updatePerson(id, updates);
    } else {
        showToast('Tipo de item inválido para edição.', 'error');
        return;
    }
    
    promise.then((success) => {
      if (success) closeModal('editCategoryModal');
    });
  }

  function handleSaveInvestment() {
    const data = {
      name: $('#investmentName').value.trim(),
      amount: parseFloat($('#investmentAmount').value) || 0,
      goal: parseFloat($('#investmentGoal').value) || 0,
      category: $('#investmentCategorySelect').value,
      targetDate: getDateInputValue('investmentTargetDate'), // Pode ser null
      notes: $('#investmentNotes').value.trim()
    };
    
    if (!data.name) {
      showToast('Informe um nome para o objetivo.', 'error');
      return;
    }
    if (isNaN(data.amount) || data.amount < 0) {
        showToast('Valor inicial inválido.', 'error');
        return;
    }
    if (isNaN(data.goal) || data.goal < 0) {
        showToast('Meta final inválida.', 'error');
        return;
    }
    if (!data.category) {
        showToast('Selecione uma categoria para o objetivo.', 'error');
        return;
    }
    
    const action = $('#saveInvestmentBtn').dataset.action;
    const id = $('#saveInvestmentBtn').dataset.id;
    
    if (action === 'update' && id) {
      updateInvestment(id, data).then((success) => {
        if(success) {
            closeModal('newInvestmentModal');
            if ($('#investmentDetailModal').classList.contains('active')) {
              openInvestmentDetail(id); // Reabre para atualizar
            } else {
              openModal('investmentsModal');
            }
        }
      });
    } else {
      addInvestment(data).then(investment => {
        if(investment) {
            closeModal('newInvestmentModal');
            openModal('investmentsModal');
        }
      });
    }
  }

  function handleSaveContribution() {
    const data = {
      investmentId: $('#contributionInvestmentId').value,
      amount: parseFloat($('#contributionAmount').value),
      date: getDateInputValue('contributionDate'),
      description: $('#contributionDescription').value.trim()
    };
    
    if (!data.investmentId || isNaN(data.amount) || data.amount <= 0 || !data.date) {
      showToast('Preencha todos os campos obrigatórios corretamente.', 'error');
      return;
    }
    
    const action = $('#saveContributionBtn').dataset.action;
    const id = $('#saveContributionBtn').dataset.id;
    
    if (action === 'update' && id) {
      updateContribution(id, data).then((success) => {
        if(success) closeModal('newContributionModal');
      });
    } else {
      addContribution(data).then((contribution) => {
        if(contribution) closeModal('newContributionModal');
      });
    }
  }

  async function handlePayAllDue() {
    const dueTransactionRows = $$('#dueTransactionsTableBody tr .mark-paid-due-btn');
    if (dueTransactionRows.length === 0) {
        showToast('Nenhuma conta para pagar.', 'info');
        return;
    }
    
    // Coleta todos os IDs das transações a serem pagas
    const transactionIdsToPay = dueTransactionRows.map(btn => btn.dataset.id);
    
    // Cria um array de promessas para atualizar o status de cada transação
    const paymentPromises = transactionIdsToPay.map(id => updateTransactionStatus(id, 'paid'));
    
    try {
        await Promise.all(paymentPromises);
        closeModal('dueTransactionsModal');
        showToast('Todas as contas selecionadas foram marcadas como pagas!', 'success');
        // fullUIRefresh será chamado por cada updateTransactionStatus, mas podemos chamar uma vez no final
        // para garantir, embora possa ser redundante.
        await fullUIRefresh(); 
    } catch (error) {
        console.error("Erro ao pagar todas as contas:", error);
        showToast('Ocorreu um erro ao tentar pagar todas as contas.', 'error');
    }
  }

  // Inicialização da aplicação
  async function init() {
    try {
      initTheme();
      updateYearOptions();
      
      const currentDate = new Date();
      state.year = currentDate.getFullYear();
      state.month = currentDate.getMonth();
      
      $('#yearSelect').value = state.year;
      $('#monthSelect').value = state.month;
      
      setupEventListeners();
      
      await loadCategoriesAndPaymentMethods();
      await loadCards();
      await loadInvestments();
      await loadTransactions(); // Chama fullUIRefresh internamente após carregar
      
      // Configurar valores iniciais para inputs de data dos modais de "Novo"
      setDateInputValue('incomeDate', new Date());
      setDateInputValue('expenseDate', new Date());
      setDateInputValue('expenseDueDate', new Date());
      
      showToast('Aplicativo carregado!', 'success');
    } catch (error) {
      console.error('Erro fatal ao inicializar aplicativo:', error);
      showToast('Erro crítico ao inicializar. Verifique o console.', 'error');
    }
  }

  document.addEventListener('DOMContentLoaded', init);

  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
    const newTheme = e.matches ? 'dark' : 'light';
    if (!localStorage.getItem('themePreference')) { // Só muda se não houver preferência salva
      document.documentElement.setAttribute('data-theme', newTheme);
      state.themePreference = newTheme; // Atualiza o estado
      updateChartColors(); // Atualiza cores dos gráficos
    }
  });

 </script>
</body>
</html>
